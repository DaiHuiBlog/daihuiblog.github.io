<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git简明指南</title>
    <url>/2018/04/24/Git%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Git简明指南/3-2023-03-06-10-23-18.jpg" alt="3-2023-03-06-10-23-18"></p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载-git-OSX-版"><a href="#下载-git-OSX-版" class="headerlink" title="下载 git OSX 版"></a><a href="http://git-scm.com/download/mac" target="_blank" rel="noopener">下载 git OSX 版</a></h2><h2 id="下载-git-Windows-版"><a href="#下载-git-Windows-版" class="headerlink" title="下载 git Windows 版"></a><a href="http://git-for-windows.github.io/" target="_blank" rel="noopener">下载 git Windows 版</a></h2><h2 id="下载-git-Linux-版"><a href="#下载-git-Linux-版" class="headerlink" title="下载 git Linux 版"></a><a href="http://book.git-scm.com/2_installing_git.html" target="_blank" rel="noopener">下载 git Linux 版</a></h2><h1 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h1><p>创建新文件夹，打开，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>以创建新的 git 仓库。</p>
<h1 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h1><p>执行如下命令以创建一个本地仓库的克隆版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone /path/to/repository</span><br></pre></td></tr></table></figure>
<p>如果是远端服务器上的仓库，你的命令会是这个样子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone username@host:/path/to/repository</span><br></pre></td></tr></table></figure>
<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的<code>工作目录</code>，它持有实际文件；<br>第二个是<code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；<br>最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Git简明指南/1-2023-03-06-10-23-02.png" alt="1-2023-03-06-10-23-02"></p>
<h1 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h1><p>你可以提出更改（把它们添加到暂存区），使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure>
<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m "代码提交信息"</span><br></pre></td></tr></table></figure>
<p>现在，你的改动已经提交到了<code>HEAD</code>，但是还没到你的远端仓库。</p>
<h1 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h1><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>可以把 master 换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Git简明指南/2-2023-03-06-10-25-39.png" alt="2-2023-03-06-10-25-39"></p>
<p>创建一个叫做“feature_x”的分支，并切换过去：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure>
<p>切换回主分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>再把新建的分支删掉：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure>
<p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<h1 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h1><p>要更新你的本地仓库至最新改动，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>
<p>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。<br>这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>在合并改动之前，你可以使用如下命令预览差异：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure>
<p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p>
<h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>如果你想了解本地仓库的历史记录，最简单的命令就是使用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --author=bob</span><br></pre></td></tr></table></figure>
<p>一个压缩后的每一条提交记录只占一行的输出:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>或者你想通过<strong>ASCII</strong>艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure>
<p>看看哪些文件改变了:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --name-status</span><br></pre></td></tr></table></figure>
<p>这些只是你可以使用的参数中很小的一部分。更多的信息，参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --help</span><br></pre></td></tr></table></figure>
<h1 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h1><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>此命令会使用<code>HEAD</code>中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p>
<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>
<h1 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h1><p>内建的图形化 git：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure>
<p>彩色的 git 输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config color.ui true</span><br></pre></td></tr></table></figure>
<p>显示历史记录时，每个提交的信息只显示一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure>
<p>交互式添加文件到暂存区：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>
<h1 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h1><h2 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h2><p><a href="http://gitx.laullon.com/" target="_blank" rel="noopener">GitX (L) (OSX, 开源软件)</a><br><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower (OSX)</a><br><a href="http://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree (OSX, 免费)</a><br><a href="http://mac.github.com/" target="_blank" rel="noopener">GitHub for Mac (OSX, 免费)</a><br><a href="https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12" target="_blank" rel="noopener">GitBox (OSX, App Store)</a>  </p>
<h2 id="指南和手册"><a href="#指南和手册" class="headerlink" title="指南和手册"></a>指南和手册</h2><p><a href="http://book.git-scm.com/" target="_blank" rel="noopener">Git 社区参考书</a><br><a href="http://progit.org/book/" target="_blank" rel="noopener">专业 Git</a><br><a href="http://think-like-a-git.net/" target="_blank" rel="noopener">像 git 那样思考</a><br><a href="http://help.github.com/" target="_blank" rel="noopener">GitHub 帮助</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a>  </p>
<p>git命令大全：<br><img src="https://DaiHuiBlog.github.io/images/posts/Git简明指南/4.jpg" alt="image2"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(2)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2/</url>
    <content><![CDATA[<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ul>
<li>从Windows上传jdk到虚拟机  </li>
</ul>
<blockquote>
<p>你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下</p>
</blockquote>
<a id="more"></a>
<ul>
<li>解压jdk</li>
</ul>
<blockquote>
<p>mkdir /usr/java<br>tar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/</p>
</blockquote>
<ul>
<li>将java添加到环境变量中</li>
</ul>
<blockquote>
<p>vim /etc/profile  </p>
</blockquote>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79  </span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>刷新配置</li>
</ul>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(1)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1/</url>
    <content><![CDATA[<h3 id="配置虚拟机子网网段-hostonly模式时"><a href="#配置虚拟机子网网段-hostonly模式时" class="headerlink" title="配置虚拟机子网网段(hostonly模式时)"></a>配置虚拟机子网网段(hostonly模式时)</h3><ul>
<li>配置网段  </li>
</ul>
<blockquote>
<p>点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;<br>修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok</p>
</blockquote>
<a id="more"></a>
<ul>
<li>设置本地机器IP  </li>
</ul>
<blockquote>
<p>回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;<br>设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定</p>
</blockquote>
<ul>
<li>设置为hostonly模式</li>
</ul>
<blockquote>
<p>在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok   </p>
</blockquote>
<ul>
<li>另:桥接模式</li>
</ul>
<blockquote>
<p>桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;<br>点击确定</p>
</blockquote>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><blockquote>
<p>vim /etc/sysconfig/network</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=dh01 #随便设置一个名字</span><br></pre></td></tr></table></figure>
<h3 id="修改虚拟机IP-这里是centos7"><a href="#修改虚拟机IP-这里是centos7" class="headerlink" title="修改虚拟机IP(这里是centos7)"></a>修改虚拟机IP(这里是centos7)</h3><p>两种方式：  </p>
<ul>
<li>第一种：通过Linux图形界面进行修改（推荐）</li>
</ul>
<blockquote>
<p>进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt; 点击Edit connections -&gt; 选中当前网络System eth0 -&gt; 点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt; 点击add按钮 -&gt;添加IP：192.168.8.88<br>子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply</p>
</blockquote>
<ul>
<li>第二种：修改配置文件方式</li>
</ul>
<blockquote>
<p>vim /etc/sysconfig/network-scripts/ifcfg-eth0` (不一定一定是ifcfg-eth0)</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEVICE="eth0"</span><br><span class="line">BOOTPROTO="static"               #修改</span><br><span class="line">HWADDR="00:0C:29:3C:BF:E7"</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">NM_CONTROLLED="yes"</span><br><span class="line">ONBOOT="yes"</span><br><span class="line">TYPE="Ethernet"</span><br><span class="line">UUID="ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c"</span><br><span class="line">IPADDR="192.168.8.88"               #修改</span><br><span class="line">NETMASK="255.255.255.0"           #修改</span><br><span class="line">GATEWAY="192.168.8.1"               #修改</span><br></pre></td></tr></table></figure>
<h3 id="修改主机名和IP的映射关系"><a href="#修改主机名和IP的映射关系" class="headerlink" title="修改主机名和IP的映射关系"></a>修改主机名和IP的映射关系</h3><p><code>vim /etc/hosts</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.8.88 dh01</span><br></pre></td></tr></table></figure>
<h3 id="关闭防火墙-以下为centos7以前命令-centos7"><a href="#关闭防火墙-以下为centos7以前命令-centos7" class="headerlink" title="关闭防火墙(以下为centos7以前命令,centos7)"></a>关闭防火墙(以下为centos7以前命令,centos7)</h3><blockquote>
<p>#查看防火墙状态<br>service iptables status</p>
<p>#关闭防火墙<br>service iptables stop</p>
<p>#查看防火墙开机启动状态<br>chkconfig iptables –list</p>
<p>#关闭防火墙开机启动<br>chkconfig iptables off</p>
</blockquote>
<p>CentOS 7.0默认使用的是firewall作为防火墙  </p>
<blockquote>
<p>systemctl start firewalld.service    #启动firewall<br>systemctl stop firewalld.service    #停止firewall<br>systemctl disable firewalld.service    #禁止firewall开机启动  </p>
</blockquote>
<p>也可以改成使用iptables：systemctl start iptables.service</p>
<h3 id="重启Linux"><a href="#重启Linux" class="headerlink" title="重启Linux"></a>重启Linux</h3><blockquote>
<p>reboot</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse下JSP中使用UEditor（以富文本编辑器为例）</title>
    <url>/2017/02/20/Eclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)/</url>
    <content><![CDATA[<h3 id="1-下载UEditor"><a href="#1-下载UEditor" class="headerlink" title="1.下载UEditor"></a>1.下载UEditor</h3><p><a href="http://ueditor.baidu.com/website/download.html" target="_blank" rel="noopener">下载UEditor</a></p>
<a id="more"></a>
<p>版本如下：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="1-2023-03-06-10-02-26">/1-2023-03-06-10-02-26.png)</p>
<h3 id="2-解压，简单暴力地将-ueditor1-4-3-utf8-jsp-jsp-lib目录下的文件拷贝到项目的-WEB-INF-lib目录下"><a href="#2-解压，简单暴力地将-ueditor1-4-3-utf8-jsp-jsp-lib目录下的文件拷贝到项目的-WEB-INF-lib目录下" class="headerlink" title="2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下"></a>2.解压，简单暴力地将<code>\ueditor1_4_3-utf8-jsp\jsp\lib</code>目录下的文件拷贝到项目的<code>/WEB-INF/lib</code>目录下</h3><p>如图所示：<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="2-2023-03-06-10-07-50">/2-2023-03-06-10-07-50.png)<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="3-2023-03-06-10-07-59">/3-2023-03-06-10-07-59.png)</p>
<h3 id="3-将除index-html文件外的文件拷贝到项目中，例如"><a href="#3-将除index-html文件外的文件拷贝到项目中，例如" class="headerlink" title="3.将除index.html文件外的文件拷贝到项目中，例如"></a>3.将除index.html文件外的文件拷贝到项目中，例如</h3><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="4-2023-03-06-10-08-26">/4-2023-03-06-10-08-26.png)</p>
<h3 id="4-在要使用富文本编辑器的页面引入脚本"><a href="#4-在要使用富文本编辑器的页面引入脚本" class="headerlink" title="4.在要使用富文本编辑器的页面引入脚本"></a>4.在要使用富文本编辑器的页面引入脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"&lt;%=path%&gt;/js/ueditor/ueditor.config.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js"</span>&gt; &lt;/script&gt;</span><br><span class="line">&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;</span><br><span class="line">&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="5-2023-03-06-10-09-14">/5-2023-03-06-10-09-14.png)</p>
<h3 id="5-在需要用富文本编辑器的区域添加以下脚本"><a href="#5-在需要用富文本编辑器的区域添加以下脚本" class="headerlink" title="5.在需要用富文本编辑器的区域添加以下脚本"></a>5.在需要用富文本编辑器的区域添加以下脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script id=<span class="string">"editor"</span> type=<span class="string">"text/plain"</span> style=<span class="string">"width:486px;height:300px;"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="6-2023-03-06-10-10-36">/6-2023-03-06-10-10-36.png)</p>
<h3 id="6-在页面最下端写以下javascript脚本"><a href="#6-在页面最下端写以下javascript脚本" class="headerlink" title="6.在页面最下端写以下javascript脚本"></a>6.在页面最下端写以下javascript脚本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;   </span><br><span class="line">    <span class="comment">//实例化编辑器    </span></span><br><span class="line">    <span class="comment">//建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor('editor')就能拿到相关的实例</span></span><br><span class="line">    <span class="keyword">var</span> ue = UE.getEditor(<span class="string">'editor'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="7-2023-03-06-10-11-11">/7-2023-03-06-10-11-11.png)</p>
<h3 id="7-添加提交按钮的js脚本，用来提交内容"><a href="#7-添加提交按钮的js脚本，用来提交内容" class="headerlink" title="7.添加提交按钮的js脚本，用来提交内容"></a>7.添加提交按钮的js脚本，用来提交内容</h3><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="8-2023-03-06-10-11-43">/8-2023-03-06-10-11-43.png)</p>
<p>脚本文件：<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="9-2023-03-06-10-11-58">/9-2023-03-06-10-11-58.png)</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="10-2023-03-06-10-12-16">/10-2023-03-06-10-12-16.png)</p>
<p>代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_post_msg_valid</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">          <span class="keyword">if</span>(<span class="literal">false</span>==UE.getEditor(<span class="string">'editor'</span>).hasContents())&#123;      </span><br><span class="line">               alert(<span class="string">'请输入内容！'</span>);       </span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">          &#125;           </span><br><span class="line">     <span class="built_in">document</span>.getElementById(<span class="string">"msg"</span>).value=UE.getEditor(<span class="string">'editor'</span>).getContent();        </span><br><span class="line">     <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Eclipse下JSP中使用UEditor(以富文本编辑器为例" alt="11-2023-03-06-10-12-58">/11-2023-03-06-10-12-58.png)</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(3)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3/</url>
    <content><![CDATA[<p><code>安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）
注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件</code></p>
<a id="more"></a>
<h3 id="上传hadoop并解压到指定目录"><a href="#上传hadoop并解压到指定目录" class="headerlink" title="上传hadoop并解压到指定目录"></a>上传hadoop并解压到指定目录</h3><p>同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录</p>
<h3 id="配置hadoop"><a href="#配置hadoop" class="headerlink" title="配置hadoop"></a>配置hadoop</h3><ol>
<li><p>hadoop-env.sh文件</p>
<blockquote>
<p>vim hadoop-env.sh</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79</span><br></pre></td></tr></table></figure>
</li>
<li><p>core-site.xml文件</p>
<blockquote>
<p>vim core-site.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设定NameNode地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://dh01:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  <span class="comment">&lt;!--或者把dh01换成对应IP--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/dh/hadoop-2.4.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hdfs-site.xml文件</p>
<blockquote>
<p>vim hdfs-site.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS副本的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--因为为伪分布式,所以只有一个副本--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>mapred-site.xml文件</p>
<blockquote>
<p>#重命名<br>mv mapred-site.xml.template mapred-site.xml<br>#打开重命名后的文件<br>vim mapred-site.xml  </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定mapreduce运行在YARN上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yarn-site.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>dh01<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapreduce获取数据的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="将hadoop添加到环境变量"><a href="#将hadoop添加到环境变量" class="headerlink" title="将hadoop添加到环境变量"></a>将hadoop添加到环境变量</h3><blockquote>
<p>vim /etc/proflie</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">export HADOOP_HOME=/dh/hadoop-2.4.1</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib</span><br></pre></td></tr></table></figure>
<p>刷新配置文件  </p>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
<h3 id="格式化namenode（是对namenode进行初始化）"><a href="#格式化namenode（是对namenode进行初始化）" class="headerlink" title="格式化namenode（是对namenode进行初始化）"></a>格式化namenode（是对namenode进行初始化）</h3><blockquote>
<p>hdfs namenode -format (hadoop namenode -format)</p>
</blockquote>
<h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><p>先启动HDFS</p>
<blockquote>
<p>sbin/start-dfs.sh</p>
</blockquote>
<p>再启动YARN</p>
<blockquote>
<p>sbin/start-yarn.sh</p>
</blockquote>
<h3 id="验证是否启动成功"><a href="#验证是否启动成功" class="headerlink" title="验证是否启动成功"></a>验证是否启动成功</h3><p>使用jps命令验证</p>
<blockquote>
<p>jsp</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">27408 NameNode</span><br><span class="line">28218 Jps</span><br><span class="line">27643 SecondaryNameNode</span><br><span class="line">28066 NodeManager</span><br><span class="line">27803 ResourceManager</span><br><span class="line">27512 DataNode</span><br></pre></td></tr></table></figure>
<p><a href="http://192.168.8.88:50070" target="_blank" rel="noopener">http://192.168.8.88:50070</a> （HDFS管理界面）</p>
<p>在这个文件中添加linux主机名和IP的映射关系<br>C:\Windows\System32\drivers\etc\hosts下添加:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">192.168.1.66	dh01</span><br></pre></td></tr></table></figure>
<p>打开：<a href="http://192.168.8.88:8088验证" target="_blank" rel="noopener">http://192.168.8.88:8088验证</a> （mapreduce管理界面）  </p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(4)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4/</url>
    <content><![CDATA[<h3 id="生成ssh免登陆密钥"><a href="#生成ssh免登陆密钥" class="headerlink" title="生成ssh免登陆密钥"></a>生成ssh免登陆密钥</h3><ul>
<li><p>进入到/dh/下的home目录(隐藏)  </p>
<blockquote>
<p>cd ~/.ssh<br>ssh-keygen -t rsa （一直回车）</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<p>执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）</p>
<ul>
<li>将公钥拷贝到要免登陆的机器上<blockquote>
<p>ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)<br>或者<br>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  </p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo下NexT主题添加Gitment评论插件</title>
    <url>/2018/06/20/Hexo%E4%B8%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="最终效果图大概是这个样子"><a href="#最终效果图大概是这个样子" class="headerlink" title="最终效果图大概是这个样子"></a>最终效果图大概是这个样子</h3><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Hexo下NexT主题添加Gitment评论插件/3-2023-03-06-10-29-40.png" alt="3-2023-03-06-10-29-40"></p>
<a id="more"></a>
<p>Gitment 是作者<a href="https://imsun.net/" target="_blank" rel="noopener">imsun</a>实现的一款基于 GitHub Issues 的评论系统。 支持在前端直接引入， 不需要任何后端代码。 可以在页面进行登录， 查看，评论，点赞等操作。 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<p>这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件，并且增加一个点开显示评论的按钮，对于 Gitment 的使用请参考 <a href="https://imsun.net/" target="_blank" rel="noopener">imsun</a> 的博客。</p>
<p>另外，本教程的按钮样式和代码均直接取自 <a href="https://ehlxr.me/" target="_blank" rel="noopener">ehlxr</a> 博主。</p>
<h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><p>因为 Gitment 评论插件是基于Github Issues评论系统，这类评论系统都需要一个OAuth Application，所以咱们没有注册OAuth Application的同学先注册一个。  </p>
<p>博客咱们已经有啦，例如我的：DaiHuiBlog.github.io。没有的同学以自己GitHub用户新建一个仓库就行：<code>你的用户名.github.io</code></p>
<p>接下来创建 <em>OAuth Application</em>，没有的同学可以<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener"><strong>新建一个</strong></a>。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Hexo下NexT主题添加Gitment评论插件/1-2023-03-06-10-32-34.png" alt="1-2023-03-06-10-32-34"></p>
<p>其中:</p>
<ul>
<li><code>Application name</code> 为仓库名，例：daihuiblog.github.io</li>
<li><code>Homepage URL</code> 填你的博客网址，例：blog.daihui888.com</li>
<li><code>Application description</code> 描述，随便写</li>
<li><code>Authorization callback URL</code> 填你的博客网址，例：blog.daihui888.com  </li>
</ul>
<p>完成后会生成相应的 <code>clientID</code> 和 <code>clientSecret</code></p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Hexo下NexT主题添加Gitment评论插件/2-2023-03-06-10-33-24.jpg" alt="2-2023-03-06-10-33-24"></p>
<p>接下来开始配置Gitment</p>
<h3 id="“显示-Gitment-评论”-的按钮样式"><a href="#“显示-Gitment-评论”-的按钮样式" class="headerlink" title="“显示 Gitment 评论” 的按钮样式"></a>“显示 Gitment 评论” 的按钮样式</h3><p>在 <code>next/source/css/_common/components</code> 目录中新建一个 <code>gitment.styl</code> 的 css 样式文件, 复制以下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gitment_title</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: initial;</span><br><span class="line">    <span class="attribute">background-position-x</span>: initial;</span><br><span class="line">    <span class="attribute">background-position-y</span>: initial;</span><br><span class="line">    <span class="attribute">background-size</span>: initial;</span><br><span class="line">    <span class="attribute">background-repeat-x</span>: initial;</span><br><span class="line">    <span class="attribute">background-repeat-y</span>: initial;</span><br><span class="line">    <span class="attribute">background-attachment</span>: initial;</span><br><span class="line">    <span class="attribute">background-origin</span>: initial;</span><br><span class="line">    <span class="attribute">background-clip</span>: initial;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gitment_title</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-top-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-top-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-right-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-right-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-bottom-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-bottom-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-left-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-image-source</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-slice</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-width</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-outset</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-repeat</span>: initial;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gitment_title</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开同目录中的 <code>components.styl</code> 文件, 找个顺眼的位置添加一句</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@import</span> <span class="string">"gitment"</span></span><br></pre></td></tr></table></figure>
<h3 id="添加-Gitment-插件"><a href="#添加-Gitment-插件" class="headerlink" title="添加 Gitment 插件"></a>添加 Gitment 插件</h3><p>打开 <code>/next/layout/_partials/comments.swig</code> 文件, 在最后一个<code>elseif</code>代码块下面添加 Gitment 的内容.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面的略... ...</span></span><br><span class="line">&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125;</span><br><span class="line"> &lt;div id=<span class="string">"SOHUCS"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line"> &lt;div onclick=<span class="string">"showGitment()"</span> id=<span class="string">"gitment_title"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"gitment_title"</span>&gt;显示 Gitment 评论&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> &lt;div id="container" style="display:none"&gt;&lt;/</span>div&gt;</span><br><span class="line"> &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span><br><span class="line"> &lt;script src=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> myTheme = &#123;</span><br><span class="line">   render(state, instance) &#123;</span><br><span class="line">     <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">     container.lang = <span class="string">"en-US"</span>;</span><br><span class="line">     container.className = <span class="string">'gitment-container gitment-root-container'</span>;</span><br><span class="line">     container.appendChild(instance.renderHeader(state, instance));</span><br><span class="line">     container.appendChild(instance.renderEditor(state, instance));</span><br><span class="line">     container.appendChild(instance.renderComments(state, instance));</span><br><span class="line">     container.appendChild(instance.renderFooter(state, instance));</span><br><span class="line">     <span class="keyword">return</span> container;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showGitment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   $(<span class="string">"#gitment_title"</span>).attr(<span class="string">"style"</span>, <span class="string">"display:none"</span>);</span><br><span class="line">   $(<span class="string">"#container"</span>).attr(<span class="string">"style"</span>, <span class="string">""</span>).addClass(<span class="string">"gitment_container"</span>);</span><br><span class="line">   <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">     id: <span class="built_in">decodeURI</span>(<span class="built_in">window</span>.location.pathname),</span><br><span class="line">     theme: myTheme,</span><br><span class="line">     owner: <span class="string">'&#123;&#123; theme.gitment.owner &#125;&#125;'</span>,</span><br><span class="line">     repo: <span class="string">'&#123;&#123; theme.gitment.repo &#125;&#125;'</span>,</span><br><span class="line">     oauth: &#123;</span><br><span class="line">       client_id: <span class="string">'&#123;&#123; theme.gitment.client_id &#125;&#125;'</span>,</span><br><span class="line">       client_secret: <span class="string">'&#123;&#123; theme.gitment.client_secret &#125;&#125;'</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   gitment.render(<span class="string">'container'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后打开 NexT 主题的_config.yml 文件，在评论相关设置的区域添加下面的代码，并根据 Gitment 文档说明来添加相应的值</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitment comments</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">true</span>  <span class="comment">#lazy属性为是否直接显示评论模块，true会显示”显示评论”按钮，false会直接显示</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，Gitment需要自己手动初始化一下来创建一个issues，不喜欢他的同学可以用<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener"><strong>Gitalk</strong></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见异常总结</title>
    <url>/2018/03/18/Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><h5 id="java-lang-NullPointerException-空指针异常"><a href="#java-lang-NullPointerException-空指针异常" class="headerlink" title="java.lang.NullPointerException(空指针异常)"></a>java.lang.NullPointerException(空指针异常)</h5><blockquote>
<p>调用了未经初始化的对象或者是不存在的对象</p>
</blockquote>
<p>经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，<br>即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，<br>依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。</p>
<a id="more"></a>
</li>
<li><h5 id="java-lang-ClassNotFoundException"><a href="#java-lang-ClassNotFoundException" class="headerlink" title="java.lang.ClassNotFoundException　　"></a>java.lang.ClassNotFoundException　　</h5><blockquote>
<p>指定的类不存在</p>
</blockquote>
<p> 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常<br> 比如：调用Class.forName();<br> 或者调用ClassLoad的finaSystemClass();或者LoadClass();</p>
</li>
<li><h5 id="java-lang-NumberFormatException"><a href="#java-lang-NumberFormatException" class="headerlink" title="java.lang.NumberFormatException"></a>java.lang.NumberFormatException</h5><blockquote>
<p>字符串转换为数字异常</p>
</blockquote>
<p>当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。<br>但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理.</p>
</li>
<li><h5 id="java-lang-IndexOutOfBoundsException"><a href="#java-lang-IndexOutOfBoundsException" class="headerlink" title="java.lang.IndexOutOfBoundsException"></a>java.lang.IndexOutOfBoundsException</h5><blockquote>
<p>数组下标越界异常</p>
</blockquote>
<p>查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。</p>
</li>
<li><h5 id="java-lang-IllegalArgumentException"><a href="#java-lang-IllegalArgumentException" class="headerlink" title="java.lang.IllegalArgumentException"></a>java.lang.IllegalArgumentException</h5><blockquote>
<p>方法的参数错误</p>
</blockquote>
<p>比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。</p>
</li>
<li><h5 id="java-lang-IllegalAccessException"><a href="#java-lang-IllegalAccessException" class="headerlink" title="java.lang.IllegalAccessException"></a>java.lang.IllegalAccessException</h5><blockquote>
<p>没有访问权限</p>
</blockquote>
<p>当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常</p>
</li>
<li><h5 id="java-lang-ArithmeticException"><a href="#java-lang-ArithmeticException" class="headerlink" title="java.lang.ArithmeticException"></a>java.lang.ArithmeticException</h5><blockquote>
<p>数学运算异常</p>
</blockquote>
<p>当算术运算中出现了除以零这样的运算就会出这样的异常。</p>
</li>
<li><h5 id="java-lang-ClassCastException"><a href="#java-lang-ClassCastException" class="headerlink" title="java.lang.ClassCastException"></a>java.lang.ClassCastException</h5><blockquote>
<p>数据类型转换异常</p>
</blockquote>
<p>当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">String str = obj;</span><br><span class="line">java.lang.FileNotFoundException</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="java-lang-FileNotFoundException"><a href="#java-lang-FileNotFoundException" class="headerlink" title="java.lang.FileNotFoundException"></a>java.lang.FileNotFoundException</h5><blockquote>
<p>文件未找到异常</p>
</blockquote>
<p>当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出<br>即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常</p>
</li>
<li><h5 id="java-lang-ArrayStoreException"><a href="#java-lang-ArrayStoreException" class="headerlink" title="java.lang.ArrayStoreException"></a>java.lang.ArrayStoreException</h5><blockquote>
<p>数组存储异常</p>
</blockquote>
<p>当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] obj = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">obj[<span class="number">0</span>] = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">java.lang.NoSuchMethodException</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="java-lang-NoSuchMethodException"><a href="#java-lang-NoSuchMethodException" class="headerlink" title="java.lang.NoSuchMethodException"></a>java.lang.NoSuchMethodException</h5><blockquote>
<p>方法不存在异常  </p>
</blockquote>
<p>当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常</p>
</li>
<li><h5 id="java-lang-NoSuchFiledException"><a href="#java-lang-NoSuchFiledException" class="headerlink" title="java.lang.NoSuchFiledException"></a>java.lang.NoSuchFiledException</h5><blockquote>
<p>方法不存在异常</p>
</blockquote>
<p>当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常</p>
</li>
<li><h5 id="java-lang-EOFException"><a href="#java-lang-EOFException" class="headerlink" title="java.lang.EOFException"></a>java.lang.EOFException</h5><blockquote>
<p>文件已结束异常</p>
</blockquote>
<p>当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾</p>
</li>
<li><h5 id="java-lang-InstantiationException"><a href="#java-lang-InstantiationException" class="headerlink" title="java.lang.InstantiationException"></a>java.lang.InstantiationException</h5><blockquote>
<p>实例化异常</p>
</blockquote>
<p>当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发<br>Class对象表示一个抽象类，接口，数组类，基本类型<br>该Class表示的类没有对应的构造器</p>
</li>
<li><h5 id="java-lang-InterruptedException"><a href="#java-lang-InterruptedException" class="headerlink" title="java.lang.InterruptedException"></a>java.lang.InterruptedException</h5><blockquote>
<p>被中止异常</p>
</blockquote>
<p>当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。</p>
</li>
<li><h5 id="java-lang-CloneNotSupportedException"><a href="#java-lang-CloneNotSupportedException" class="headerlink" title="java.lang.CloneNotSupportedException"></a>java.lang.CloneNotSupportedException</h5><blockquote>
<p>不支持克隆异常</p>
</blockquote>
<p>当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。</p>
</li>
<li><h5 id="java-lang-OutOfMemoryException"><a href="#java-lang-OutOfMemoryException" class="headerlink" title="java.lang.OutOfMemoryException"></a>java.lang.OutOfMemoryException</h5><blockquote>
<p>内存不足错误</p>
</blockquote>
<p>当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
</li>
<li><h5 id="java-lang-NoClassDefFoundException"><a href="#java-lang-NoClassDefFoundException" class="headerlink" title="java.lang.NoClassDefFoundException"></a>java.lang.NoClassDefFoundException</h5><blockquote>
<p>未找到类定义错误</p>
</blockquote>
<p>当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。</p>
</li>
<li><h5 id="违背安全原则异常：SecturityException"><a href="#违背安全原则异常：SecturityException" class="headerlink" title="违背安全原则异常：SecturityException"></a>违背安全原则异常：SecturityException</h5></li>
<li><h5 id="操作数据库异常：SQLException"><a href="#操作数据库异常：SQLException" class="headerlink" title="操作数据库异常：SQLException"></a>操作数据库异常：SQLException</h5></li>
<li><h5 id="输入输出异常：IOException"><a href="#输入输出异常：IOException" class="headerlink" title="输入输出异常：IOException"></a>输入输出异常：IOException</h5></li>
<li><h5 id="通信异常：SocketException"><a href="#通信异常：SocketException" class="headerlink" title="通信异常：SocketException"></a>通信异常：SocketException</h5></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上用QuickTimePlayer和Soundflower插件录制完美视频</title>
    <url>/2019/04/10/Mac%E4%B8%8A%E7%94%A8QuickTimePlayer%E5%92%8CSoundflower%E6%8F%92%E4%BB%B6%E5%BD%95%E5%88%B6%E5%AE%8C%E7%BE%8E%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/0-2023-03-06-10-51-48.png" alt="0-2023-03-06-10-51-48"></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MacOS自带的QuickTime Player录制视频的时候默认是不会有内部视频里的音频的，默认情况下除非你开到最大声，然后通过内置的麦克风“听到”，又录进到视频。这是很傻X的。<br>今天整理了一下可以录制到音视频的两个方法：</p>
<blockquote>
<ol>
<li>录制只有屏内音频视频的方法  </li>
<li>录制有屏内音频和屏外声音视频的方法</li>
</ol>
</blockquote>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote>
<p>软件： Soundflower 小插件<br>操作系统：macOS<br>其他：一个聪明的脑袋  </p>
</blockquote>
<h2 id="1-下载Soundflower并安装"><a href="#1-下载Soundflower并安装" class="headerlink" title="1. 下载Soundflower并安装"></a>1. 下载<a href="https://github.com/mattingalls/Soundflower/releases" target="_blank" rel="noopener">Soundflower</a>并安装</h2><p>点击上面这个链接，进入GitHub选择下载<code>Soundflower-2.0b2.dmg</code>(版本可能不一样)</p>
<p>下载完成后，无脑安装，再次期间可能会提示<code>提示来自身份不明的开发者</code>，这个时候不要慌，打开系统偏好设置-&gt;安全性与隐私，选择“仍要打开”（此时我们在“通用”选项卡）</p>
<p>在这里我们顺便检查一下，QuickTime Player的麦克风权限。打开系统偏好设置-&gt;安全性与隐私-&gt;选择“隐私”选项卡，选择左侧的“麦克风”选项，看右侧的“QuickTime Player”有没有勾上对勾，没有的话把它勾上</p>
<p>到这里Soundflower基本就算安装好了，接下来开始设置</p>
<h2 id="2-设置"><a href="#2-设置" class="headerlink" title="2. 设置"></a>2. 设置</h2><p>设置我们需要打开<code>音频 MIDI 设置</code>这个Mac自带的软件：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/1-2023-03-06-10-52-10.png" alt="音频MIDI设置"></p>
<h3 id="2-1-创建多输出设备并设置"><a href="#2-1-创建多输出设备并设置" class="headerlink" title="2.1 创建多输出设备并设置"></a>2.1 创建<code>多输出设备</code>并设置</h3><p>点击左下角“+”，选择“创建多输出设备”，按如图所示设置：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/2-2023-03-06-10-52-30.png" alt="创建多输出设备"></p>
<h3 id="2-2-创建只有屏内音频的配置（创建聚集设备）"><a href="#2-2-创建只有屏内音频的配置（创建聚集设备）" class="headerlink" title="2.2 创建只有屏内音频的配置（创建聚集设备）"></a>2.2 创建<code>只有屏内音频</code>的配置（创建聚集设备）</h3><p>点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/3-2023-03-06-10-52-55.png" alt="只有屏内音频"></p>
<h3 id="2-3-创建屏内音频和屏外声音的配置（创建聚集设备）"><a href="#2-3-创建屏内音频和屏外声音的配置（创建聚集设备）" class="headerlink" title="2.3 创建屏内音频和屏外声音的配置（创建聚集设备）"></a>2.3 创建<code>屏内音频和屏外声音</code>的配置（创建聚集设备）</h3><p>点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/4-2023-03-06-10-53-13.png" alt="屏内音频和屏外声音"></p>
<h2 id="3-录制"><a href="#3-录制" class="headerlink" title="3. 录制"></a>3. 录制</h2><p>录制时因为分为两种不同的方式，所以在录制是设置稍有不同，我大致总结如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.录制只有内部音频</span><br><span class="line">    QuickTime：</span><br><span class="line">        选择对应的设置(录屏专用-内部音频)  ✔️</span><br><span class="line">        音量最小  （调大会有回音，默认最小即可）</span><br><span class="line">    扬声器输出：</span><br><span class="line">        多输出设备   ✔️</span><br><span class="line"></span><br><span class="line">2.录制有内外部音频</span><br><span class="line">    QuickTime：</span><br><span class="line">        选择对应的设置(录屏专用-内外部音频)  ✔️</span><br><span class="line">        音量最小  （调大会有回音，默认最小即可）</span><br><span class="line">    扬声器：</span><br><span class="line">        多输出设备（内外声音结合很好，效果好） ✔️</span><br><span class="line">        内置扬声器（内部音频不明显，人声大，内部声音小，效果不好）  </span><br><span class="line">        刚才建的两个选项（自己听不到声音，但是录完屏后视频内有声音）</span><br></pre></td></tr></table></figure>
<p>看不懂的同学请往下看</p>
<h3 id="3-1-录制只有屏内音频视频的方法"><a href="#3-1-录制只有屏内音频视频的方法" class="headerlink" title="3.1 录制只有屏内音频视频的方法"></a>3.1 录制只有屏内音频视频的方法</h3><p>打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内部音频”，音量选项保持最小(调大会有回音，默认最小即可）</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/5-2023-03-06-10-53-47.png" alt="录屏专用-内部音频"></p>
<p>点击右上角“小喇叭”并选择“多输出设备”：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/6-2023-03-06-10-54-10.png" alt="多输出设备1"></p>
<p>如果没有小喇叭可以打开系统偏好设置-&gt;声音-&gt;选择输出选项卡，选中“多输出设备”。最后把“在菜单栏中显示音量”选中即可，方便以后使用</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/7-2023-03-06-10-54-29.png" alt="多输出设备2"></p>
<p>至此，点击开始，录制你的视频吧</p>
<h3 id="3-2-录制有屏内音频和屏外声音视频的方法"><a href="#3-2-录制有屏内音频和屏外声音视频的方法" class="headerlink" title="3.2 录制有屏内音频和屏外声音视频的方法"></a>3.2 录制有屏内音频和屏外声音视频的方法</h3><p>打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内外部音频”，音量选项保持最小(调大会有回音，默认最小即可）</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/8-2023-03-06-10-54-57.png" alt="录屏专用-内外部音频"></p>
<p>点击右上角“小喇叭”并选择“多输出设备”：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/6-2023-03-06-10-55-31.png" alt="多输出设备3"></p>
<p>剩下的其他选项：</p>
<blockquote>
<p>内置扬声器（内部音频不明显，人声大，内部声音小，效果不好）<br>刚才建的两个选项(录屏专用-内部音频/录屏专用-内外部音频)，自己听不到声音，但是录完屏后视频内有声音（感觉这个适合用来夜深人静的时候录~）</p>
</blockquote>
<p>至此，点击开始，录制你的视频吧</p>
<h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><p>如果同学你机器上装有 <code>homebrew</code> 和 <code>homebrew cask</code>，可以直接用如下命令安装Soundflower：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew cask install soundflower</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>录视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下删除launchpad还有残留图标的应用</title>
    <url>/2018/05/16/Mac%E4%B8%8B%E5%88%A0%E9%99%A4launchpad%E8%BF%98%E6%9C%89%E6%AE%8B%E7%95%99%E5%9B%BE%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>有时候用户在删除自己应用的时候在应用程序里直接右键“移到废纸楼”，有的应用这样删除后在launchpad里还有残留的图标，按住option键也没有删除标记可以删除该图标。这让人很蛋疼，但是可以通过下面这个小技巧将该图标删除，方法如下：<br><a id="more"></a></p>
<h2 id="打开launchpad"><a href="#打开launchpad" class="headerlink" title="打开launchpad"></a>打开launchpad</h2><p>下列三个放都可以打开launchpad  </p>
<ol>
<li>fn + F4（F1-F12是正常使用情况）  </li>
<li>F4（F1-F12使用需要借助fn键使用）  </li>
<li>四个指头抓一下  </li>
</ol>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h4 id="1-长按control-option-command，看到图标抖动"><a href="#1-长按control-option-command，看到图标抖动" class="headerlink" title="1. 长按control+option+command，看到图标抖动"></a>1. 长按control+option+command，看到图标抖动</h4><h4 id="2-单击待删除图标，图标中心出现白色问号"><a href="#2-单击待删除图标，图标中心出现白色问号" class="headerlink" title="2. 单击待删除图标，图标中心出现白色问号"></a>2. 单击待删除图标，图标中心出现白色问号</h4><h4 id="3-松开按住的三个快捷键（control-option-command）"><a href="#3-松开按住的三个快捷键（control-option-command）" class="headerlink" title="3. 松开按住的三个快捷键（control+option+command）"></a>3. 松开按住的三个快捷键（control+option+command）</h4><h4 id="4-再次按下这三个快捷键，图标左上角会出现“✘”，点击删除"><a href="#4-再次按下这三个快捷键，图标左上角会出现“✘”，点击删除" class="headerlink" title="4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除"></a>4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除</h4>]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac删除</tag>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下利用GCP和v2ray搭建无限使用梯子</title>
    <url>/2019/02/18/Mac%E4%B8%8B%E5%88%A9%E7%94%A8GCP%E5%92%8Cv2ray%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>妈妈再也不用为我担心没梯子用了</p>
<a id="more"></a>
<h2 id="新用户申请GCP-Google-Cloud-Platform"><a href="#新用户申请GCP-Google-Cloud-Platform" class="headerlink" title="新用户申请GCP(Google Cloud Platform)"></a><a href="https://cloud.google.com/free/?hl=zh-cn" target="_blank" rel="noopener">新用户申请GCP(Google Cloud Platform)</a></h2><ul>
<li>这一步很蛋疼，需要先fq，所以小伙伴们可以先借同事或朋友的梯子注册一下来搞。总之，先注册上GCP</li>
<li>进去之后按照步骤填写信息。在最后需要小伙伴填写一个信用卡号，用来验证和今后扣取费用（我们这里只需要验证，右边的提示也说不会自动扣费）</li>
<li>关于信用卡，小伙伴们可以上<strong>某宝</strong>买一个，直接搜“<strong>虚拟信用卡</strong>”，大概在25元左右一个。一般来说店小二会给你提供包括：<strong>持卡人</strong>、<strong>卡号</strong>、<strong>卡有效期</strong>、<strong>CVV</strong>和<strong>账单地址</strong>等信息。这些信息在注册GCP时按照店小二给你发的如实填写即可。<em>注：地区最好和店小二发给你的保持一致</em>。</li>
<li>假设到这里没问题的话，点击注册，你就会得到一个为期365天的试用期，里面有300刀。</li>
</ul>
<h2 id="创建MV实例"><a href="#创建MV实例" class="headerlink" title="创建MV实例"></a>创建MV实例</h2><ul>
<li>进入 “导航菜单”-&gt;“Compute Engine”-&gt;”VM 实例”，选择“VM 实例”。首次进来可能需要初始化一下，初始化后点击“创建”来创建我们的VM；如果以前用过的话直接点击创建实例即可。</li>
<li><p>进入到创建实例界面，按照步骤填写即可，这里给个建议：</p>
<ul>
<li><p>区域，最好选一个里你进的地方，比如香港，台湾，东京等地；机器类型</p>
</li>
<li><p>机器类型，选择<strong>微型</strong>即可，够用且便宜</p>
</li>
<li><p>启动磁盘，<strong>默认</strong>即可</p>
</li>
<li><p>防火墙，“<strong>允许HTTP流量</strong>”和“<strong>允许HTTPS流量</strong>”都勾上</p>
</li>
<li><p>展开防火墙管理，选择“网络”，并在“网络标记”处填入防火墙出入站规则名称，分别为“<strong>ruzhan</strong>”和”<strong>chuzhan</strong>“（咱们先填写，后面再创建）</p>
</li>
</ul>
</li>
<li><p>点击创建，完成MV创建</p>
</li>
</ul>
<h2 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h2><ul>
<li><p>点击新创建的实例的连接“<strong>SSH</strong>”，登入远程连接。登入后做一下几个准备操作：<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac下利用GCP和v2ray搭建无限使用梯子/2-2023-03-06-11-01-59.png" alt="SSH"></p>
<ul>
<li><p>切换为管理员，<strong>sudo -i</strong></p>
</li>
<li><p>执行”date -R”查看当前时间和服务器是否一致（一般都不一致）</p>
</li>
<li><p>以服务器在<em>上海</em>的为例，执行一下命令将时间同步一下 “<strong>cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</strong>“，执行后查看当前时间是否一致“<strong>date -R</strong>”，这个时候发现时间已经同步了</p>
</li>
<li><p>接下来开始安装v2ray，咱们直接执行官方提供的脚本命令”<strong>bash &lt;(curl -L -s <a href="https://install.direct/go.sh" target="_blank" rel="noopener">https://install.direct/go.sh</a>)</strong>“</p>
</li>
<li><p>等待安装完毕，配置v2ray的配置文件位置在”/etc/v2ray/config.json”，里面已经有一个官方默认配置好的配置，我们先把内容删除，都是基本vi操作。打开”vi /etc/v2ray/config.json“，按”dd“删除了第一行，后面的可以直接按”.”把剩下的内容删完。</p>
</li>
<li><p>此时咱们打开<a href="https://intmainreturn0.com/v2ray-config-gen/#" target="_blank" rel="noopener">v2ray配置生成器</a>，<strong>设置</strong>填写建议如下：</p>
<ul>
<li>服务种类：默认</li>
<li>用户设置-&gt;用户uuid：多点几下</li>
<li>用户设置-&gt;使用的alterID数量：随意，我填了101</li>
<li>端口设置-&gt;端口号：随意，找一个不太会被占用的</li>
</ul>
</li>
<li><p>点击<strong>服务端配置</strong>的<strong>复制配置</strong>，将该配置粘贴到”/etc/v2ray/config.json“，在删完内容的配置文件里按下”i”，直接command+v粘贴即可</p>
</li>
<li><p>依次按下 ”ESC“+”:wq“+回车，保存退出</p>
</li>
<li><p>重启v2ray服务，”<strong>sudo systemctl restart v2ray</strong>“</p>
</li>
<li><p>查看v2ray运行状态，”<strong>service v2ray status</strong>“，看到此时已经是”Active: active (running)“</p>
</li>
<li><p>到此MV基本配置完成，接下来配置两个出入站规则</p>
</li>
</ul>
</li>
</ul>
<h2 id="出入站防火墙搭建"><a href="#出入站防火墙搭建" class="headerlink" title="出入站防火墙搭建"></a>出入站防火墙搭建</h2><ul>
<li><p>进入 “导航菜单”-&gt;“VPC网络”-&gt;”防火墙规则”，点击”创建防火墙规则“，分别创建出站和入站规则，如下图：</p>
</li>
<li><p>出站规则  </p>
</li>
</ul>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac下利用GCP和v2ray搭建无限使用梯子/3-2023-03-06-11-02-25.png" alt="出站规则"></p>
<ul>
<li>入站规则</li>
</ul>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac下利用GCP和v2ray搭建无限使用梯子/4-2023-03-06-11-02-40.png" alt="入站规则"></p>
<ul>
<li>回到MV实例，单击MV实例的名称，进入到MV实例详情页面，点击”<strong>修改</strong>“，如果在<strong>创建VM实例</strong>步骤没有配置”<strong>网络标记</strong>“选项，在这里把出入站规则名称填入其中，保存即可；因为在<strong>创建VM实例</strong>时已经把出入站名称填好了，这里就不用设置了</li>
</ul>
<h2 id="配置Mac端v2ray客户端配置信息"><a href="#配置Mac端v2ray客户端配置信息" class="headerlink" title="配置Mac端v2ray客户端配置信息"></a>配置Mac端v2ray客户端配置信息</h2><ul>
<li><p>没有客户端的小伙伴可以<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">自行下载</a>，Mac端可以用brew安装”<strong>brew cask install v2rayx</strong>“</p>
</li>
<li><p>安装完毕，打开软件配置。点击”Configure…“，配置可参考我的：</p>
</li>
</ul>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac下利用GCP和v2ray搭建无限使用梯子/5-2023-03-06-11-02-58.png" alt="Configure"></p>
<ul>
<li>配置完成，选择”Global Mode“，再点击”local core“，完成！剩下的你懂的</li>
</ul>
<h2 id="续命"><a href="#续命" class="headerlink" title="续命"></a>续命</h2><ul>
<li>当你试用账号快到期的时候，进入“导航菜单”-&gt;“结算”-&gt;”显示信息面板“，将结算账号管理员删除，过个5、6分钟后再次申请试用账号即可，而且你的VM也还在</li>
</ul>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac下利用GCP和v2ray搭建无限使用梯子/6-2023-03-06-11-03-11.png" alt="Configure"></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>梯子</tag>
        <tag>v2ray</tag>
        <tag>GCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下安装mysql5.7完整步骤及问题整理</title>
    <url>/2018/03/19/Mac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>参考以下这个博客:  </p>
<p><a href="http://www.jb51.net/article/103841.htm" target="_blank" rel="noopener">Mac下安装mysql5.7完整步骤</a></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li><p>“MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：<br><a href="http://blog.csdn.net/jyongchong/article/details/77862819" target="_blank" rel="noopener">MAC 安装MySQL的my.cnf配置文件</a></p>
</li>
<li><p>“Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：<br><a href="http://blog.csdn.net/xeay123/article/details/44127951" target="_blank" rel="noopener">World-writable</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装软件时提示已损坏的解决方法</title>
    <url>/2018/09/27/Mac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>从网上下载的常用软件，安装时总是提示“已损坏，移至废纸篓”这类信息，无法打开。如下图：</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac安装软件时提示已损坏的解决方法/1-2023-03-06-10-50-35.png" alt="已损坏"></p>
<a id="more"></a>
<p>这是新系统（macOS Sierra 10.12.X）惹的祸。新系统加强了安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>打开终端，在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<p>输入密码，回车。搞定<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Mac安装软件时提示已损坏的解决方法/2-2023-03-06-10-51-14.png" alt="2-2023-03-06-10-51-14"></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>文件损坏</tag>
      </tags>
  </entry>
  <entry>
    <title>基于GIS三维可视化仿真技术的虚拟战场地形研究</title>
    <url>/2019/06/20/aa/</url>
    <content><![CDATA[<embeb src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/202312141758133.pdf" width="100%" height="750" type="application/pdf">
</embeb>]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>虚拟战场</tag>
        <tag>仿真</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】</title>
    <url>/2018/03/18/Win10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<ol>
<li><p>首先下载 .Net Framework 3.5.</p>
</li>
<li><p>将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令：</p>
<a id="more"></a>
<blockquote>
<p>dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess</p>
</blockquote>
</li>
</ol>
<p>其他:</p>
<ul>
<li>Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】<br>然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0)  </li>
<li>再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac远程连接谷歌云VM实例</title>
    <url>/2019/02/19/Mac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C%E4%BA%91VM%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>一般在管理远程主机时，都用ssh登录，ssh user@host，但是这样每次会使用密码。 使用ssh-keygen生成的密钥对，然后将公钥添加的目标主机的~/.ssh/authorized_keys文件中，当前主机就成为可信任的主机，下次使用ssh登录时，就不用输入密码了<br>官方网站的教程很详细，但是表达方式不是很好理解，并且有的功能在操作上第一次用GCP的我来说有点陌生，这里就Linux或Mac连接VM实例方式作一个简要记录（全是大白话）</p>
<a id="more"></a>
<h2 id="第一步-生成密钥对"><a href="#第一步-生成密钥对" class="headerlink" title="第一步:生成密钥对"></a>第一步:生成密钥对</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/秘钥名称 -C "邮箱"</span><br></pre></td></tr></table></figure>
<p>这样就在主目录下的.ssh目录中生成了两个文件“秘钥名称”和“秘钥名称.pub”。“秘钥名称”中保存的是私钥，”秘钥名称.pub“中保存的是公钥。</p>
<h2 id="第二步-添加公钥"><a href="#第二步-添加公钥" class="headerlink" title="第二步:添加公钥"></a>第二步:添加公钥</h2><p>拷贝公钥到剪切板:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pbcopy &lt; 秘钥名称.pub</span><br></pre></td></tr></table></figure>
<p>在GPC导航菜单中找到”元数据“连接，选择”SSH秘钥“选项卡-&gt;点击”修改“按钮-&gt;”添加一项“，粘贴公钥，保存，就添加完成了。</p>
<h2 id="第三步-测试"><a href="#第三步-测试" class="headerlink" title="第三步:测试"></a>第三步:测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/秘钥名称 用户名@VM外部IP</span><br></pre></td></tr></table></figure>
<ul>
<li>用户名，在第二部添加公钥时，粘贴之后会在第一列出现你的用户名</li>
</ul>
<p>如果没问题的话你已经进入到VM实例终端了</p>
<p>同样的方式gitlab和GitHub也是支持的</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GCP</tag>
        <tag>谷歌云</tag>
      </tags>
  </entry>
  <entry>
    <title>win2008R2磁盘脱机和写入保护解决办法</title>
    <url>/2018/10/22/win2008R2%E7%A3%81%E7%9B%98%E8%84%B1%E6%9C%BA%E5%92%8C%E5%86%99%E5%85%A5%E4%BF%9D%E6%8A%A4%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/1-2023-03-06-11-04-05.png" alt="磁盘脱机"></p>
<a id="more"></a>
<ol>
<li><p>打开cmd命令行，输入：<code>diskpart</code>，进入diskpart工具</p>
</li>
<li><p>输入：<code>list disk</code>，查看到所有磁盘</p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/2-2023-03-06-11-04-27.png" alt="listdisk1"></p>
</li>
<li><p>找到脱机的磁盘，输入：<code>select disk 1</code></p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/3-2023-03-06-11-04-40.png" alt="selectDisk"></p>
</li>
<li><p>接着输入：<code>online disk*</code></p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/4-2023-03-06-11-05-49.png" alt="onlineDisk"></p>
</li>
<li><p>查看此时磁盘联机状态</p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/5-2023-03-06-11-06-09.png" alt="listdisk2"></p>
</li>
<li><p>清除只读属性，输入：<code>attribute disk clear readonly</code></p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/6-2023-03-06-11-06-25.png" alt="attributeDiskClearReadonly"></p>
</li>
<li><p>查看此时的清盘情况，输入：<code>attribute disk</code></p>
<p> <img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/win2008R2磁盘脱机和写入保护解决办法/7-2023-03-06-11-06-53.png" alt="attributeDisk"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows磁盘脱机</tag>
        <tag>写入保护</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm 2和Oh My Zsh代替自带terminal教程简单整理</title>
    <url>/2018/04/02/iTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="最终效果图大概是这个样子"><a href="#最终效果图大概是这个样子" class="headerlink" title="最终效果图大概是这个样子"></a>最终效果图大概是这个样子</h4><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/iTerm-2和Oh-My-Zsh代替自带terminal教程简单整理/1-2023-03-06-10-36-48.png" alt="1-2023-03-06-10-36-48"></p>
<a id="more"></a>
<p>但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样：<br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/iTerm-2和Oh-My-Zsh代替自带terminal教程简单整理/4-2023-03-06-10-37-19.png" alt="4-2023-03-06-10-37-19"></p>
<h4 id="1-首先下载iterm2"><a href="#1-首先下载iterm2" class="headerlink" title="1. 首先下载iterm2"></a>1. 首先下载<a href="http://www.iterm2.com/" target="_blank" rel="noopener">iterm2</a></h4><h4 id="2-打开iTerm-2"><a href="#2-打开iTerm-2" class="headerlink" title="2. 打开iTerm 2"></a>2. 打开iTerm 2</h4><h4 id="3-输入下面指令安装oh-my-zsh"><a href="#3-输入下面指令安装oh-my-zsh" class="headerlink" title="3. 输入下面指令安装oh-my-zsh"></a>3. 输入下面指令安装<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></h4><p><code>curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</code></p>
<h4 id="4-接下来安装Powerline"><a href="#4-接下来安装Powerline" class="headerlink" title="4. 接下来安装Powerline"></a>4. 接下来安装<a href="http://powerline.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">Powerline</a></h4><p>在官网有教程，我们只需要执行官网第一条安装指令就行</p>
<p>如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装</p>
<p><code>pip install powerline-status</code></p>
<p>如果没有，则先执行安装pip指令</p>
<p><code>sudo easy_install pip</code></p>
<h4 id="5-下载、安装库字体库"><a href="#5-下载、安装库字体库" class="headerlink" title="5. 下载、安装库字体库"></a>5. 下载、安装库<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">字体库</a></h4><p>1）将工程下载下来后<code>cd到install.sh文件所在目录</code></p>
<p>2）执行指令安装字体库</p>
<p>执行<code>./install.sh</code>指令安装所有Powerline字体</p>
<p>安装完成后提示所有字体均已下载到<code>/Users/superdanny/Library/Fonts</code>路径下</p>
<p>All Powerline fonts installed to /Users/superdanny/Library/Fonts</p>
<h4 id="6-设置iTerm-2的Regular-Font-和-Non-ASCII-Font"><a href="#6-设置iTerm-2的Regular-Font-和-Non-ASCII-Font" class="headerlink" title="6. 设置iTerm 2的Regular Font 和 Non-ASCII Font"></a>6. 设置iTerm 2的Regular Font 和 Non-ASCII Font</h4><p>安装完字体库之后，把iTerm 2的设置里的<code>Profile</code>中的<code>Text</code>选项卡中里的<code>Regular Font</code>和<code>Non-ASCII Font</code>的字体都设置成 Powerline 的字体，我这里设置的字体是<code>12pt Meslo LG S DZ Regular for Powerline</code></p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/iTerm-2和Oh-My-Zsh代替自带terminal教程简单整理/2-2023-03-06-10-40-15.jpg" alt="2-2023-03-06-10-40-15"></p>
<p>设置iTerm 2设置iTerm 2</p>
<h4 id="7-配色方案"><a href="#7-配色方案" class="headerlink" title="7. 配色方案"></a>7. <a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">配色方案</a></h4><p>1）安装配色方案</p>
<p>进入刚刚下载的工程的<em>solarized/iterm2-colors-solarized</em>下双击<em>Solarized Dark.itermcolors</em>和<em>Solarized Light.itermcolors</em>两个文件就可以把配置文件导入到 iTerm2 里</p>
<p>2）配置配色方案</p>
<p>通过load presets选择刚刚安装的配色主题即可</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/iTerm-2和Oh-My-Zsh代替自带terminal教程简单整理/3-2023-03-06-10-41-53.jpg" alt="3-2023-03-06-10-41-53"></p>
<p>配色方案配色方案</p>
<h4 id="8-使用agnoster主题"><a href="#8-使用agnoster主题" class="headerlink" title="8. 使用agnoster主题"></a>8. 使用agnoster主题</h4><p>1）下载<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="noopener">agnoster</a>主题</p>
<p>到下载的工程里面运行install文件,主题将安装到<em>~/.oh-my-zsh/themes</em>目录下</p>
<p>2）设置该主题<br>进入<code>~/.zshrc</code>打开<code>.zshrc</code>文件，然后将<code>ZSH_THEME</code>后面的字段改为<code>agnoster</code>: <code>ZSH_THEME=&quot;agnoster&quot;</code>（agnoster即为要设置的主题）</p>
<h4 id="9-增加指令高亮效果——zsh-syntax-highlighting"><a href="#9-增加指令高亮效果——zsh-syntax-highlighting" class="headerlink" title="9. 增加指令高亮效果——zsh-syntax-highlighting"></a>9. 增加指令高亮效果——<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></h4><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮</p>
<p>1）首先在<code>~/.oh-my-zsh/custom/plugins/</code>路径下执行git clone <code>https://github.com/zsh-users/zsh-syntax-highlighting.git</code><br>到了此路径:<code>~/.oh-my-zsh/custom/plugins/</code></p>
<p>2）然后在<em>~/.zshrc</em>最后添加了下面两句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(zsh-syntax-highlighting)</span><br><span class="line">source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure>
<p>3）最后执行 <code>source ~/.zshrc</code></p>
<p>这样就同时配置好了zsh和oh-my-zsh。<br>有两点需要注意(摘自官网):</p>
<p>Note the source command must be at the end of ~/.zshrc.</p>
<p>Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array.</p>
<h4 id="问题解答区"><a href="#问题解答区" class="headerlink" title="问题解答区"></a>问题解答区</h4><ol>
<li><p>启动iTerm 2 默认使用dash改用zsh解决方法：</p>
<blockquote>
<p>chsh -s /bin/zsh  </p>
</blockquote>
</li>
<li><p>如果想切换回原来的dash：</p>
<blockquote>
<p>chsh -s /bin/bash   </p>
</blockquote>
</li>
<li><p>卸载oh my zsh，在命令行输入如下命令，回车即可：</p>
<blockquote>
<p>uninstall_oh_my_zsh  </p>
</blockquote>
</li>
<li><p>执行指令pip install powerline-status出错解决方法：<br>需要下载苹果官方的<a href="https://idmsa.apple.com/IDMSWebAuth/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2Fdownload%2Fmore%2F%3Fname%3Dfor%2520Xcode%2520&amp;rv=1" target="_blank" rel="noopener">Command line</a>。必須官方工具下载最新版 Command Line  </p>
</li>
<li><p>⌘+Q关闭iTerm 2 时每次弹窗提示问题：<br>iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行   </p>
</li>
<li><p>找不到.zshrc文件问题：<br>我这里将原作者的.zshrc文件分享出来。供大家下载<a href="https://pan.baidu.com/s/1sk1LqCt" target="_blank" rel="noopener">网盘</a>   </p>
</li>
<li><p>路径前缀的XX@XX太长，缩短问题：<br>在此感谢评论区的朋友提供的<a href="https://blog.csdn.net/z3512498/article/details/51245853" target="_blank" rel="noopener">解决方案</a>。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。    </p>
</li>
<li><p>执行指令pip install powerline-status出错，下载了Command Line也没有办法,是权限原因造成的,执行:   </p>
<blockquote>
<p>pip install powerline-status –user</p>
</blockquote>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派3B+制作视频监控</title>
    <url>/2019/03/12/%E6%A0%91%E8%8E%93%E6%B4%BE3Bplus%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/树莓派3Bplus制作视频监控/logo-2023-03-06-09-53-34.png" alt="logo-2023-03-06-09-53-34"></p>
<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>本人育有一毛，此猫调皮捣蛋，因此想要做个监控放在家里，在公司上班的时候看看它到底在家里捣什么鬼蛋！</p>
<a id="more"></a>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><blockquote>
<p>环境：树莓派3B+<br>操作系统：树莓派3B+默认系统<br>摄像头：N年前买的一个USB摄像头（比树莓派官方好点）  </p>
</blockquote>
<h1 id="1-更新列表"><a href="#1-更新列表" class="headerlink" title="1.更新列表"></a>1.更新列表</h1><p>这一步可能有点慢，请耐心等待。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新软件列表</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新软件</span></span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h1 id="2-开启摄像头"><a href="#2-开启摄像头" class="headerlink" title="2.开启摄像头"></a>2.开启摄像头</h1><p>执行如下命令，进入配置页面，开启摄像头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/树莓派3Bplus制作视频监控/1-2023-03-06-09-53-56.png" alt="1-2023-03-06-09-53-56"><br><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/树莓派3Bplus制作视频监控/2-2023-03-06-09-54-04.png" alt="2-2023-03-06-09-54-04"><br>选择: “是”  -&gt; “Back” -&gt; “Finish”</p>
<p>重启一下树莓派</p>
<h1 id="3-安装依赖库"><a href="#3-安装依赖库" class="headerlink" title="3.安装依赖库"></a>3.安装依赖库</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JPEG支持库</span></span><br><span class="line">sudo apt-get install libjpeg8-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载编译工具</span></span><br><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h1 id="4-下载mjpg-streamer"><a href="#4-下载mjpg-streamer" class="headerlink" title="4.下载mjpg-streamer"></a>4.下载mjpg-streamer</h1><p>随意找个目录执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jacksonliam/mjpg-streamer.git</span><br></pre></td></tr></table></figure>
<p>以常见的<strong>Downloads</strong>目录为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ cd Downloads/</span><br><span class="line">pi@raspberrypi:~ $ git clone https://github.com/jacksonliam/mjpg-streamer.git</span><br></pre></td></tr></table></figure>
<h1 id="5-编辑源文件（非必须）"><a href="#5-编辑源文件（非必须）" class="headerlink" title="5.编辑源文件（非必须）"></a>5.编辑源文件（非必须）</h1><p>网上有教程基本都编辑<strong>plugins/input_raspicam/input_raspicam.c</strong>源码里的几个参数（fps、width和height）<br>，这个文件是对应官方的摄像头（RaspiCamera）。</p>
<p>我这里用的是自己的普通USB摄像头，所以这个文件可以不用修改。</p>
<p>如果你的摄像头是普通USB摄像头，可以跳过。</p>
<p>如果你的摄像头是官方的摄像头（RaspiCamera）那么请修改之：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:/ $ cd /home/pi/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/</span><br><span class="line">pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/ $ vi input_raspicam.c</span><br></pre></td></tr></table></figure>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/树莓派3Bplus制作视频监控/3-2023-03-06-09-54-21.png" alt="3-2023-03-06-09-54-21"></p>
<h1 id="6-编译mjpg-streamer"><a href="#6-编译mjpg-streamer" class="headerlink" title="6.编译mjpg-streamer"></a>6.编译mjpg-streamer</h1><p>进入工程mjpg-streamer-experimental，进行完全编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental $ make clean all</span><br></pre></td></tr></table></figure>
<h1 id="7-开启mjpg-streamer"><a href="#7-开启mjpg-streamer" class="headerlink" title="7.开启mjpg-streamer"></a>7.开启mjpg-streamer</h1><p>进入mjpg-streamer-experimental目录，使用一下指令启动摄像头。</p>
<ul>
<li><p>启动普通USB摄像头指令：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -i "./input_uvc.so" -o "./output_http.so -w ./www"</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动树莓派专用摄像头RaspiCamera指令：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -i "./input_raspicam.so" -o "./output_http.so -w ./www"</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h1><p>在浏览器里输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 静态图（拍照）</span></span><br><span class="line">http://&lt;IP&gt;：8080/?action=snapshot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 动态图（视频监控）</span></span><br><span class="line">http://&lt;IP&gt;：8080/?action=stream</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个兼容性好点</span></span><br><span class="line">http://&lt;IP&gt;：8080/javascript_stream.html</span><br></pre></td></tr></table></figure>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/树莓派3Bplus制作视频监控/cat-2023-03-06-09-54-35.jpeg" alt="cat-2023-03-06-09-54-35"></p>
<h1 id="9-问题"><a href="#9-问题" class="headerlink" title="9.问题"></a>9.问题</h1><p>有的同学可能在<strong>开启mjpg-streamer</strong>的时候会报错，可能是你USB摄像头用了树莓派专用摄像头RaspiCamera指令的指令启动造成的（我就是这样，哈哈哈）</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机Linux的root或普通用户密码忘记找回</title>
    <url>/2018/07/31/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%9A%84root%E6%88%96%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%89%BE%E5%9B%9E/</url>
    <content><![CDATA[<h1 id="启动VMware的Linux"><a href="#启动VMware的Linux" class="headerlink" title="启动VMware的Linux"></a>启动VMware的Linux</h1><ol>
<li>进入GRUB界面后，有几秒钟时间给你。进入GRUB出现：<br> Red Hat Enterprise Linux Server (2.6.18-8.e15xen) <a id="more"></a></li>
<li>倒计时结束前，键入e出现：<br>root（hd0,0）<br>kernel /xen.gz-2.6.28-8.e15<br>module /vmlinux-2.6.18.e15xen ro root=/dev/VolGroup00/LogVo100 rhgb quiet<br>module /initrd-2.6.18-8.e15xen.img<br>上下键移到quiet那一行，按e进入，加上 linux single或者1即可，回车</li>
<li>按b后进入重启模式，一定注意出现：<br> Starting udev:<br> 在后面输入boot回车</li>
<li>之后出现命令行：<br> sh-3.2#</li>
<li>输入passwd，回车即可修改root密码，输入两次密码</li>
<li>完成之后reboot即可重启。</li>
</ol>
<h1 id="普通用户密码忘记了，比较简单"><a href="#普通用户密码忘记了，比较简单" class="headerlink" title="普通用户密码忘记了，比较简单"></a>普通用户密码忘记了，比较简单</h1><ol>
<li>在root账户下，打开/etc/shadow (不是passwd文件，因为密码实际上经过加密后放在了“影子口令”文件shadow中了。passwd文件每个用户均可见，但是shadow只有root可以见)。</li>
<li>找到普通用户名cicikasa，然后删除第二个域即可，域之间用“:”隔开的，如下：<br>cicikasa:TdkakkkYUukkjkjk:14672:0:99999:7:::<br>上述红色部分就是经过加密的密码，删除即可</li>
<li>在普通用户下，输入passwd即可输入新密码</li>
</ol>
<h1 id="如果想修改VMware的bios"><a href="#如果想修改VMware的bios" class="headerlink" title="如果想修改VMware的bios"></a>如果想修改VMware的bios</h1><p>在VMWare中将BIOS设成光驱启动:<br>启动时(点击启动虚拟机按钮),按F2 ,进入BIOS 设置,找到 BOOT—把CDROM光驱，移动到最上面即可。根据提示进行设置，一般按“-”号进行设置。<br>注意：启动时，点了启动虚拟机按钮后一定要在点一下窗口（或者Ctrl +G），然后快按F2。否则，窗口没激活，F2是不起作用的.</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>密码找回</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机VirtualBox中挂载新硬盘</title>
    <url>/2018/03/18/%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘：</p>
<h5 id="添加新硬盘"><a href="#添加新硬盘" class="headerlink" title="添加新硬盘"></a>添加新硬盘</h5><blockquote>
<p>设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”<br>然后，根据需求创建合适的硬盘<br><a id="more"></a></p>
</blockquote>
<h5 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h5><p>  查看现有系统的磁盘空间</p>
<blockquote>
<p>sudo fdisk -l</p>
</blockquote>
<p>  可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb</p>
<h5 id="给新加的硬盘分区"><a href="#给新加的硬盘分区" class="headerlink" title="给新加的硬盘分区"></a>给新加的硬盘分区</h5><blockquote>
<p>fdisk /dev/sdb  </p>
</blockquote>
<p>  键入m,可看到帮助信息</p>
<blockquote>
<p>command (m for help):m</p>
</blockquote>
<p>  增加新分区</p>
<blockquote>
<p>command (m for help):n  </p>
</blockquote>
<p>  选择基本分区，输入：p 建一个分区</p>
<blockquote>
<p>Partition number(1-4):  </p>
</blockquote>
<p>  回车</p>
<blockquote>
<p>First cylinder (1-15908,default 1):Enter</p>
</blockquote>
<p>  写入并退出</p>
<blockquote>
<p>command (m for help):w</p>
</blockquote>
<h5 id="格式化磁盘分区"><a href="#格式化磁盘分区" class="headerlink" title="格式化磁盘分区"></a>格式化磁盘分区</h5><p>  用ext4格式对/dev/sdb1进入格式化</p>
<blockquote>
<p>sudo mkfs.ext4 /dev/sdb1</p>
</blockquote>
<h5 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h5><p>  创建新的挂载点</p>
<blockquote>
<p>sudo mkdir /work</p>
</blockquote>
<p>  将新磁盘分区挂载到/work目录下</p>
<blockquote>
<p>sudo mount -t ext4 /dev/sdb1 /work</p>
</blockquote>
<p>  查看挂载</p>
<blockquote>
<p>df -h</p>
</blockquote>
<p>  可以看到新加的硬盘：/dev/sdb1</p>
<h5 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h5><p>  修改文件</p>
<blockquote>
<p>sudo vim /etc/fstab</p>
</blockquote>
<p>  在最后一行加入：</p>
<blockquote>
<p>/dev/sdb1 /work ext4 errors=remount-ro 0 1</p>
</blockquote>
<p>  完成!</p>
<hr>
<h4 id="补充：为挂载点扩容"><a href="#补充：为挂载点扩容" class="headerlink" title="补充：为挂载点扩容"></a>补充：为挂载点扩容</h4><p>假设之前我们有一个挂载点为 <em>/mydata</em> ，但该 <em>/mydata</em> 已经写满，但依然想在 <em>/mydata</em> 下添加新的数据，这时可以使用软链接将 <em>/mydata</em> 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。</p>
<p><strong>1. 创建一个目录，以便稍后作为挂载点：</strong></p>
<blockquote>
<p>mkdir /newdata</p>
</blockquote>
<p><strong>2. 将 /dev/sdb1 分区挂载到 /newdata 下：</strong></p>
<blockquote>
<p>mount /dev/sdb1 /newdata</p>
</blockquote>
<p><strong>3. 新建 /mydata 到 /newdata 的软链接：</strong></p>
<blockquote>
<p>ln -s /newdata /mydata</p>
</blockquote>
<p>  此时在 /mydata 目录下会有一个软链接文件 <em>newdata</em> 指向 <em>/newdata/</em> ，即 <em>newdata-&gt; /newdata/</em> 。这样一来，只要我们向 <em>/mydata/newdata</em> 下写文件，实际就写入了 <em>/newdata/</em> 目录下，相当于我们为原 <em>/mydata</em> 挂载点新增加了一部分使用空间。  </p>
<p>  也可以手动指定该软链接文件的名称：</p>
<blockquote>
<p>ln -s /newdata /mydata/customed_name</p>
</blockquote>
<p>  这样就有 /mydata/customed_name -&gt; /newdata  </p>
<p>  <strong>注：</strong> 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。<br>  举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上：  </p>
<blockquote>
<p>touch /newdata/catalina_link.out<br>ln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out</p>
</blockquote>
<p>  <strong><em>这里还需要注意三点：</em></strong></p>
<p>  一是必须先创建一个被链接的文件，否则软链接后失败；<br>  二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空；<br>  三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。  </p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>联合作战仿真引擎分析与设计</title>
    <url>/2018/12/21/%E8%81%94%E5%90%88%E4%BD%9C%E6%88%98%E4%BB%BF%E7%9C%9F%E5%BC%95%E6%93%8E%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="1-概念和需求"><a href="#1-概念和需求" class="headerlink" title="1 概念和需求"></a>1 概念和需求</h2><p>&emsp;&emsp;引擎一词来源于英语的“Egnien”，一般指的是将能量转化为力量或运动的装置，是系统的“心脏”。在仿真系统中，仿真引擎是驱动模型运行的核心组件，它为模型提供输人数据，控制模型运行，推进仿真时间，为各类分析和表现工具提供输出数据和控制信号。仿真引擎按照战争层次划分为不同的级别，如装备级仿真引擎、战术级仿真引擎、战役级仿真引擎和战略级仿真引擎。通常情况下，由于仿真的层次不同，仿真的侧重点也不同，仿真引擎在具体功能上也有不同，特别是其建模框架。按照分布程度可以将仿真引擎分为集中式仿真引擎和分布式仿真引擎，集中式仿真引擎具有单一的运行控制管理模块，而分布式仿真引擎则具有多个可以互相协调的运行控制管理模块。按照内部的处理机制可以将仿真引擎分为串行仿真引擎和并行仿真引擎两种，串行仿真引擎中按顺序调度各实体仿真执行，而并行仿真引擎中则可以支持多个实体同时仿真执行。</p>
<a id="more"></a>
<p>&emsp;&emsp;联合作战仿真引擎是面向联合作战仿真系统的仿真引擎，其主要需求应该包括以下几个方面。</p>
<p>&emsp;&emsp;一是提供联合作战模型的开发框架。模型开发框架采用面向对象的机制组织各类仿真实体，实体类的组织结构要符合联合作战的特点，具有开放性并且易于扩展。模型开发框架支持形式化的作战规则，提供作战规则表述机制和组织管理工具。模型开发框架提供一组设计合理的 AIP，可以对实体的各种属性和行为进行调整，如实体的人员配置参数、武器装备参数、运动方式、通信行为、战役战术行为、毁伤和感知等等。</p>
<p>&emsp;&emsp;二是支持多种仿真推进方式。仿真引擎必须支持两种基本推进方式，即时间步长推进方式和事件步长推进方式，具备从模型组件库中读取模型组件信息，并根据这些信息，采用模型驱动的方式推进仿真。</p>
<p>&emsp;&emsp;三是支持实体的并行式仿真。通过在单一仿真引擎内采用多线程技术，不同的实体可以具有不同的线程，实体可以并行地仿真。</p>
<p>&emsp;&emsp;四是支持仿真引擎之间的分布式部署。仿真引擎之间可以通过特定的接口和某种通信基础设施进行互操作，从而可以将复杂大规模仿真合理部署到网络上，提高单独仿真引擎的执行效率及仿真实体的规模。</p>
<p>&emsp;&emsp;五是提供良好的数据组织方式。仿真引擎应提供结构合理、易于扩展的数据组织机制，方便模型读取各种输人数据（如来自想定中的部队配置和武器装备参数等），为态势表现模块和分析评估模块提供方便的输出数据（如部队的各种损耗）。</p>
<h2 id="2-体系结构"><a href="#2-体系结构" class="headerlink" title="2 体系结构"></a>2 体系结构</h2><p>根据对联合作战仿真引擎的主要需求，联合作战仿真引擎的系统体系结构如下图所示。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/202312141536215.png" alt="图 1 联合作战仿真引擎的概念体系结构"></p>
<p>&emsp;&emsp;联合作战仿真引擎的核心模块包括实体管理模块、时间管理模块、事件管理模块、地形处理模块、数据处理模型、脚本解析模块、日志管理模块、显示控制模块、界面生成模块、分布式服务模块、网络通信模块等。另外，在仿真系统中与仿真引擎密切相关的其他部分包括用户控制界面、模型编辑工具、想定编辑工具、脚本编辑工具、可视化表现工具和分析评估工具等。</p>
<h2 id="3-核心模块"><a href="#3-核心模块" class="headerlink" title="3 核心模块"></a>3 核心模块</h2><h3 id="3-1-实体管理模块"><a href="#3-1-实体管理模块" class="headerlink" title="3.1 实体管理模块"></a>3.1 实体管理模块</h3><p>&emsp;&emsp;实体管理模块包括一系列负责管理各类实体的实体管理类，每一个基本实体类都对应一个实体管理类，它控制着实体的创建、销毁、配置、用户界面和各种相关数据，从而可以简化开发人员的相关工作，简化代码编写。</p>
<h3 id="3-2-时间管理模块"><a href="#3-2-时间管理模块" class="headerlink" title="3.2 时间管理模块"></a>3.2 时间管理模块</h3><p>&emsp;&emsp;时间管理工具能够为仿真运行提供统一的时间服务，协调单机多线程、多机各邦员之间的时间同步，协调分布式仿真运行的仿真推进，以保证联邦成员间收发信息的时间逻辑正确性，协调不同时间管理类型的联邦成员在联邦时间轴上的推进，同时为各联邦成员提供不同传输要求和质量的消息、数据传输。</p>
<h4 id="3-2-1-时间管理机制"><a href="#3-2-1-时间管理机制" class="headerlink" title="3.2.1 时间管理机制"></a>3.2.1 时间管理机制</h4><p>&emsp;&emsp;按照对联邦逻辑时间推进的影响，联邦成员的时间管理策略分为时间受限和时间控制，它们描述联邦成员之间的逻辑时钟推进关系，与时间管理机制的内容密切相关，对联邦成员选择时间管理机制产生影响。在此基础上，HLA的时间管理机制包括两方面的内容:消息传递机制和时间推进机制。消息传递机制包括消息传输方式和消息传递顺序。其中消息传输方式分为“可靠（reliable）”和“快速（best effort）两种，前者保证可靠性，使消息最终能达到目的成员，通常要增加时延;后者以减少传输时延为主要目的，通常要降低可靠性。消息的传递顺序分为两类:接收顺序（Accept Order，RO）、时戳顺序（Timestamp Order，TSO），它们是目前 HLA 支持的两种基本消息传递顺序。时间推进机制可分为两大类:一类为保守时间推进机制，另一类为乐观时间推进机制。HLA 时间管理中保守时间推进机制的基本思想是假设物理系统满足可实现性和可预测性，保证系统发出的 t 时刻的消息 依赖于 t 时刻前收到的消息和状态，且系统能在 t 时刻预测出 t+ε时刻 的消息（ε&gt;0），按照非递减的时戳顺序对时戳消息进行交互，以处理逻辑进程的离散事件实现对系统的正确仿真。在该机制中，“时间前瞻量（Lookahead）”和“时戳下限（LBTS）”是影响时间推进的两个关键变量。尽管保守算法可能会引起死锁，Fujimoto 的研究指出利用“时间前瞻量”可有效解决这个问题。HLA 乐观时间推进机制的基本思想则不遵守保守机制算法，当系统发生逻辑因果错误，利用回滚（retract）机制对系统状态进行恢复，其机制确保事件按 TSO 处理。</p>
<h4 id="3-2-2-时间推进方式"><a href="#3-2-2-时间推进方式" class="headerlink" title="3.2.2 时间推进方式"></a>3.2.2 时间推进方式</h4><p>&emsp;&emsp;时间推进服务管理分布式网络环境下的事件队列，统一维护仿真过程中模型、系统或外部驱动产生的各类型事件，调度请求仿真时间推进。在 HLA 时间管理中，联邦成员的时间推进方式是由时间管理策略和时间推进机制共同决定的，时间推进方式的选择是在时间推进机制的基础上进行的。时间推进方式分为独立时间推进和协商时间推进。通常在独立时间推进方式下，各联邦成员不受约束地推进各自的时间，且 RTI 不参加协调成员间的时间推进。在协商时间推进方式下， RTI 协同各成员间的时间推进，保证联邦执行与物理系统中事件的先后顺序一致，协商时间推进分为:步进的时间推进、基于事件的时间推进和乐观机制下的时间推进。因此，在保守同步机制下，可选择步进的时间推进方式或基于事件的时间推进方式。</p>
<h3 id="3-3-事件管理模块"><a href="#3-3-事件管理模块" class="headerlink" title="3.3 事件管理模块"></a>3.3 事件管理模块</h3><p>&emsp;&emsp;仿真引擎提供高效的并行事件管理能力，通过多线程并行执行的方式可以对整个仿真过程的所有事件进行统一维护和调度，在多个线程内同时管理模型事件的执行，包括平台运动事件、传感器探测事件、通信事件、干扰事件等，多个线程间的事件执行完成后统一提交，由时间管理模块进行整个仿真时间的推进，下图描述了单个线程的时间执行生命周期。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/202312141544639.png" alt="图 2 调度器活动图"></p>
<h3 id="3-4-地理处理模块"><a href="#3-4-地理处理模块" class="headerlink" title="3.4 地理处理模块"></a>3.4 地理处理模块</h3><p>&emsp;&emsp;地形处理模块主要负责管理仿真所需的各类地形数据，对数据进行优化存储，提供便于各类实体调用的接口。</p>
<h3 id="3-5-数据处理模块"><a href="#3-5-数据处理模块" class="headerlink" title="3.5 数据处理模块"></a>3.5 数据处理模块</h3><p>&emsp;&emsp;数据处理模块主要负责管理仿真中的各种数据，对想定数据进行解析，调用实体管理模块初始化各种实体对象，载人各种相关地形数据到地形处理模块。</p>
<h3 id="3-6-脚本解析模块"><a href="#3-6-脚本解析模块" class="headerlink" title="3.6 脚本解析模块"></a>3.6 脚本解析模块</h3><p>&emsp;&emsp;脚本解析模块负责解析和处理所有脚本声明。脚本是一种用于表示非参数输人的文本语言，可以对各实体进行配置，描述隶属关系，描述简单的作战行动过程及各种触发条件，从而提高想定编辑的灵活性。在仿真时，仿真引擎需要利用该模块对脚本进行解释，分析具体的函数内容，调用相应的处理模块。</p>
<h3 id="3-7-日志管理模块"><a href="#3-7-日志管理模块" class="headerlink" title="3.7 日志管理模块"></a>3.7 日志管理模块</h3><p>&emsp;&emsp;日志管理模块主要负责提供日志管理功能，用于记录仿真过程，进而对数据进行分析或回放。</p>
<h3 id="3-8-显示控制模块"><a href="#3-8-显示控制模块" class="headerlink" title="3.8 显示控制模块"></a>3.8 显示控制模块</h3><p>&emsp;&emsp;显示控制模块主要提供与显示相关的控制信息，当实体发生状态变化时向可视化表现工具发出相应控制信息。</p>
<h3 id="3-9-界面生成模块"><a href="#3-9-界面生成模块" class="headerlink" title="3.9 界面生成模块"></a>3.9 界面生成模块</h3><p>&emsp;&emsp;界面生成模块主要用于为仿真过程提供动态界面，如为实体提供特定的属性编辑窗口和行为编辑窗口等。</p>
<h3 id="3-10-网络通信模块"><a href="#3-10-网络通信模块" class="headerlink" title="3.10 网络通信模块"></a>3.10 网络通信模块</h3><p>&emsp;&emsp;网络通信模块主要负责管理仿真引擎与其它同构仿真引擎或是异构仿真系统之间的消息通信，将消息解析成为仿真引擎和仿真实体可以处理的内部格式。</p>
<h3 id="3-11-分布式服务模块"><a href="#3-11-分布式服务模块" class="headerlink" title="3.11 分布式服务模块"></a>3.11 分布式服务模块</h3><p>&emsp;&emsp;分布式服务模型提供分布式时间协调服务、数据传输服务、实时监视监听仿服务，其中分布式时间协调服务主要为分布式仿真提供全局统一的时间，保证分布式仿真各个联邦成员之间的时间一致性，提供“作战时间”和“仿真时间”的管理;数据传输服务能够在分布式仿真运行环境中，为仿真各邦员提供仿真数据同步服务，完成不同邦员之间的数据打包、发送、接收、解析、处理等工作。实时监视监听仿服务能够实时监视监听仿真运行过程中的服务（如:调试服务、分布式事件管理服务、数据分发服务等）关键事件。</p>
<h2 id="4-辅助工具"><a href="#4-辅助工具" class="headerlink" title="4 辅助工具"></a>4 辅助工具</h2><p>&emsp;&emsp;用户控制界面主要负责提供仿真引擎所需要的控制命令，如启动、暂停、步进和结束等。<br>&emsp;&emsp;模型编辑工具处于仿真系统开发的最前端，主要用于模型组件建模，并生成模型组件动态库和描述文件，供想定编辑工具和仿真引擎使用。<br>&emsp;&emsp;想定数据通常按照仿真引擎所需要的格式进行组织，这种格式难以为军事用户所理解和掌握。而想定编辑工具则为想定数据的编辑提供一个可视化和形式化的管理界面，使得用户可以按照通常的军事想定开发习惯设计想定，并且可以使用形象快捷的可视化方法辅助生成该想定。<br>&emsp;&emsp;与想定编辑工具类似，脚本编辑工具也是为了辅助想定制作人员而提供的便捷工具，如提供脚本模板快速生成和在已有脚本上生成新脚本的功能等。可视化表现工具主要用于动态表现仿真过程，它可以接收来自仿真引擎中的实体状态变更消息，从而改变相应的图标位置或状态。<br>&emsp;&emsp;分析评估工具用于为分析人员提供分析和评估界面，如动态统计各方的各种战损，评估未来可能发展趋势等。它可以接收来自仿真引擎的各种实体状态变化，从而对统计数据进行动态更新。</p>
<h2 id="5-关键技术问题"><a href="#5-关键技术问题" class="headerlink" title="5 关键技术问题"></a>5 关键技术问题</h2><p>&emsp;&emsp;构建这样一个仿真引擎需要解决一系列技术问题，其中的关键技术问题包括以下几个方面。</p>
<h3 id="5-1-仿真模型框架"><a href="#5-1-仿真模型框架" class="headerlink" title="5.1 仿真模型框架"></a>5.1 仿真模型框架</h3><p>&emsp;&emsp;联合作战仿真系统重点解决联合作战过程中多种实体在时间和空间上的行动和交互，所以仿真引擎不仅要有开放式的、面向对象的体系结构，同时还应提供可扩充性和可重用性强的仿真模型框架。仿真实体模型的构建是这个模型框架的核心。在系统仿真中，实体功能由其对应的功能模型所决定。采用“单元模型+功能模型”的模型结构，可以灵活、方便地创建各种功能的联合作战实体。单元模型是所有仿真实体的载体，它本身不具有指挥功能或作战功能，就像一个空壳，在仿真中代表着该实体，默认情况下不能执行任何功能。实体的运动、感知、通信、决策等功能由与其相关联的功能模型定义。功能模型包括许多类型的基础模型，有的模型模拟指挥人员的行为和决策，有的模型模拟实体所具有的武器装备或设备的性能及功能，有的模型负责作战环境、作战规则及作战效果等方面的描述。本文提出的联合作战仿真引擎模型框架中，实体之间行为交互通过消息进行传递，如通报态势信息和下达指挥作战信息等。消息模型负责模拟实体之间消息的传递。使用脚本关联不同类型的模型，可以定义飞机、装甲部队、导弹、卫星，或其他聚合类实体，实现仿真实体配载武器平台、拥有不同的行为。</p>
<h3 id="5-2-数据管理"><a href="#5-2-数据管理" class="headerlink" title="5.2 数据管理"></a>5.2 数据管理</h3><p>&emsp;&emsp;数据是模型的基础，也是仿真引擎需要考虑的一个重要内容。仿真引擎中的仿真数据需要具有良好的组织结构和接口，便于实现对仿真实体的快速查找和动态访问。特别需要关注异构数据的组织，通过建立通用的访问接口。可以减少软件开发的复杂度，提高软件质量。为了支持仿真引擎内多线程并行仿真机制，不同线程中的数据需要具有保护机制，维护线程内数据的一致性，如采用关键区或是加锁的线程仿真机制。另外，在分布式的仿真引擎中，还需要解决分布在不同计算机上的动态仿真数据之间的一致性问题分布在不同计算机上的动态仿真数据之间的一致性问题，需要给出特定的一致性维持算法。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>仿真</tag>
        <tag>联合作战</tag>
        <tag>仿真引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios基本使用说明</title>
    <url>/2018/04/11/Axios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p><a href="https://www.npmjs.org/package/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/v/axios.svg?style=flat-square" alt="npm version"></a><a href="https://travis-ci.org/axios/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/axios/axios.svg?style=flat-square" alt="build status"></a><a href="https://coveralls.io/r/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" alt="code coverage"></a><a href="http://npm-stat.com/charts.html?package=axios" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/dm/axios.svg?style=flat-square" alt="npm downloads"></a><a href="https://gitter.im/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square" alt="gitter chat"></a><a href="https://www.codetriage.com/axios/axios" target="_blank" rel="noopener"><img src="https://www.codetriage.com/axios/axios/badges/users.svg" alt="code helpers"></a></p>
<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>从浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequests</a></li>
<li>从 node.js 创建 <a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">XSRF</a></li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><table>
<thead>
<tr>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png" alt="Chrome"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png" alt="Firefox"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png" alt="Safari"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png" alt="Opera"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/edge/edge_48x48.png" alt="Edge"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/archive/internet-explorer_9-11/internet-explorer_9-11_48x48.png" alt="IE"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>8+ ✔</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="https://saucelabs.com/u/axios" target="_blank" rel="noopener"><img src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" alt="Browser Matrix"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<p>使用 bower:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure>
<p>使用 cdn:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>执行 <code>GET</code> 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">'/user?ID=12345'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong> async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。</p>
</blockquote>
<p>执行 <code>POST</code> 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>执行多个并发请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//两个请求均已完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>请求可以通过传递相关配置来完成 <code>axios</code>.</p>
<p><strong>axios(config)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个POST请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET请求远程图像</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">'get'</span>,</span><br><span class="line">  url:<span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType:<span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>axios(url[, config])</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送GET请求（默认方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h2><p>为方便起见，为所有支持的请求方法提供了别名</p>
<p><strong>axios.request(config)</strong><br><strong>axios.get(url[, config])</strong><br><strong>axios.delete(url[, config])</strong><br><strong>axios.head(url[, config])</strong><br><strong>axios.options(url[, config])</strong><br><strong>axios.post(url[, data[, config]])</strong><br><strong>axios.put(url[, data[, config]])</strong><br><strong>axios.patch(url[, data[, config]])</strong></p>
<blockquote>
<p>注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>处理并发请求的助手函数</p>
<p><strong>axios.all(iterable)</strong><br><strong>axios.spread(callback)</strong></p>
<h3 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h3><p>您可以使用自定义配置创建一个新的axios实例。</p>
<p><strong>axios.create([config])</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<p><strong>axios#request(config)</strong><br><strong>axios#get(url[, config])</strong><br><strong>axios#delete(url[, config])</strong><br><strong>axios#head(url[, config])</strong><br><strong>axios#options(url[, config])</strong><br><strong>axios#post(url[, data[, config]])</strong><br><strong>axios#put(url[, data[, config]])</strong><br><strong>axios#patch(url[, data[, config]])</strong></p>
<h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>这些是创建请求时可以用的配置选项。只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>get</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="comment">// 您可以修改headers对象。</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params`  是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个普通对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属： FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node专属: Stream, Buffer</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码</span></span><br><span class="line">  <span class="comment">// 注意：忽略'stream'或客户端请求的`responseType`</span></span><br><span class="line">  responseEncoding: <span class="string">'utf8'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中遵循的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// 例如'/var/run/docker.sock'发送请求到docker守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定`socketPath`或`proxy`。</span></span><br><span class="line">  <span class="comment">// 如果两者都指定，则使用`socketPath`。</span></span><br><span class="line">  socketPath: <span class="literal">null</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy' 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// 使用'false'来禁用代理，忽略环境变量。</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>某个请求的响应包含以下信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` t服务器响应的头</span></span><br><span class="line">  <span class="comment">// 所有的 header 都是小写</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是为请求提供给`axios`的配置</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>then</code> 时，你将接收下面这样的响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在使用 <code>catch</code> 时，或传递<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">rejection callback</a> 作为 <code>then</code> 的第二个参数时, 响应可以通过 <code>error</code> 对象可被使用，正如在<a href="#错误处理">错误处理</a> 这一节所讲.</p>
<h2 id="配置的默认值-defaults"><a href="#配置的默认值-defaults" class="headerlink" title="配置的默认值/defaults"></a>配置的默认值/defaults</h2><p>你可以指定将被用在各个请求的配置默认值</p>
<h3 id="全局axios默认值"><a href="#全局axios默认值" class="headerlink" title="全局axios默认值"></a>全局axios默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例时设置配置的默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例已创建后修改默认值</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>
<h3 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h3><p>配置会以一个优先顺序进行合并。这个顺序是：在 <a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L28" target="_blank" rel="noopener">lib/defaults.js</a>找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。这里是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 `0`</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写库的超时默认值</span></span><br><span class="line"><span class="comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>
<p>可以为自定义 axios 实例添加拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      <span class="comment">// 请求已发出，但服务器响应的状态码不在 2xx 范围内</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// 请求被提出，但没有接收到响应</span></span><br><span class="line">      <span class="comment">// `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置触发错误</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>validateStatus</code> 配置选项定义一个自定义 <code>HTTP</code> 状态码的错误范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">// 仅当状态码大于或等于500时才拒绝</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>使用 <em>cancel token</em> 取消请求</p>
<blockquote>
<p>Axios 的 cancel token API 基于<a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">cancelable promises proposal</a>，它还处于第一阶段。</p>
</blockquote>
<p>可以使用 <code>CancelToken.source</code> 工厂创建取消令牌，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure>
<p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 可以使用同一个 cancel token 取消多个请求</p>
</blockquote>
<h2 id="使用-application-x-www-form-urlencoded-格式"><a href="#使用-application-x-www-form-urlencoded-格式" class="headerlink" title="使用 application/x-www-form-urlencoded 格式"></a>使用 application/x-www-form-urlencoded 格式</h2><p>默认情况下，axios将JavaScript对象序列化为JSON。要以<code>application/x-www-form-urlencoded</code> 格式发送数据，您可以使用以下选项之一。</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>在浏览器中，您可以使用以下<a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener"><code>URLSearchParams</code></a> API:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意， <code>URLSearchParams</code> 并非所有浏览器都支持(请参阅 <a href="http://www.caniuse.com/#feat=urlsearchparams" target="_blank" rel="noopener">caniuse.com</a>), 但可以使用 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener">polyfill</a>(请确保填充全局环境)。<br>或者，您可以使用<a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库对数据进行编码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>或者以另一种方式（ES6），</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123; <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>在node.js中，您可以<a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener"><code>querystring</code></a>按如下方式使用模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>您也可以使用该<a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a>库.</p>
<h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><p>在axios达到<code>1.0</code> 发布之前，将通过新的次要版本发布重大更改。例如 <code>0.5.1</code>, 和 <code>0.5.4</code>将具有相同的API, 但 <code>0.6.0</code> 会有重大更改。</p>
<h2 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h2><p>aaxios依赖于原生ES6 Promise实现的<a href="http://caniuse.com/promises" target="_blank" rel="noopener">支持</a>。如果您的环境不支持ES6 Promise，则可以<a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener">polyfill</a>。</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>axios包括<a href="http://typescriptlang.org" target="_blank" rel="noopener">TypeScript</a>定义。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/axios/axios/blob/master/CHANGELOG.md" target="_blank" rel="noopener">更新日志</a></li>
<li><a href="https://github.com/axios/axios/blob/master/UPGRADE_GUIDE.md" target="_blank" rel="noopener">升级指南</a></li>
<li><a href="https://github.com/axios/axios/blob/master/ECOSYSTEM.md" target="_blank" rel="noopener">生态系统</a></li>
<li><a href="https://github.com/axios/axios/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">C参与指南</a></li>
<li><a href="https://github.com/axios/axios/blob/master/CODE_OF_CONDUCT.md" target="_blank" rel="noopener">行为守则</a></li>
</ul>
]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员工作中常见的英语词汇</title>
    <url>/2019/06/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/程序员工作中常见的英语词汇/1-2023-03-06-09-22-34.jpg" alt="1-2023-03-06-09-22-34"><br><a id="more"></a></p>
<h2 id="程序员工作中常见的英语词汇"><a href="#程序员工作中常见的英语词汇" class="headerlink" title="程序员工作中常见的英语词汇"></a>程序员工作中常见的英语词汇</h2><p>本列表中的单词是英语类计算机书籍、文档、文章中高频常见的技术词汇，最终目的是希望程序员集合自身的英语基础，在掌握列表中的词汇后，可以无障碍阅读英语技术文章和文档。</p>
<blockquote>
<p>本文内容来自Wei-Xia的项目<a href="https://github.com/Wei-Xia/most-frequent-technology-english-words" target="_blank" rel="noopener">most-frequent-technology-english-words</a></p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>accordion</td>
<td>可折叠的，褶叠的</td>
<td>形容词</td>
<td>/əˈkɔːrdiən/</td>
<td>设计中可以通过点击按钮将内容折叠或展开</td>
</tr>
<tr>
<td>agile</td>
<td>敏捷、灵活的</td>
<td>形容词</td>
<td>/ˈædʒl/</td>
</tr>
<tr>
<td>agnostic</td>
<td>不可知论的</td>
<td>形容词</td>
<td>/æɡˈnɑːstɪk/</td>
<td>常用于 language agnostic，即和语言无关。</td>
</tr>
<tr>
<td>arbitrary</td>
<td>任意的</td>
<td>形容词</td>
<td>/ˈɑːrbɪtreri/</td>
</tr>
<tr>
<td>asynchronous</td>
<td>异步的</td>
<td>形容词</td>
<td>/eɪˈsɪŋkrənəs/</td>
</tr>
<tr>
<td>comprehensive</td>
<td>综合的，广泛的</td>
<td>形容词</td>
<td>/ˌkɑːmprɪˈhensɪv/</td>
</tr>
<tr>
<td>concrete</td>
<td>具体的、有形的</td>
<td>形容词</td>
<td>/ˈkɑːnkriːt/</td>
</tr>
<tr>
<td>concurrent</td>
<td>并发的，同时发生的</td>
<td>形容词</td>
<td>/kənˈkɜːrənt/</td>
</tr>
<tr>
<td>consultative</td>
<td>咨询的</td>
<td>形容词</td>
<td>/kənˈsʌltətɪv/</td>
</tr>
<tr>
<td>cost-effective</td>
<td>有成本效益的，合算的</td>
<td>形容词</td>
<td>/ˌkɔːst ɪˈfektɪv/</td>
</tr>
<tr>
<td>cost-efficient</td>
<td>有成本效益的，合算的</td>
<td>形容词</td>
<td>/ˈkɔstiˈfiʃənt/</td>
</tr>
<tr>
<td>critical</td>
<td>关键的，重要的，批评的</td>
<td>形容词</td>
<td>/ˈkrɪtɪkl/</td>
</tr>
<tr>
<td>crucial</td>
<td>重要的，决定性的</td>
<td>形容词</td>
<td>/ˈkruːʃl/</td>
</tr>
<tr>
<td>customized</td>
<td>定制的，个性化的</td>
<td>形容词</td>
<td>/ˈkʌstəmaɪzd/</td>
</tr>
<tr>
<td>declarative</td>
<td>声明式</td>
<td>形容词</td>
<td>/dɪˌkler.ə.t̬ɪv/</td>
</tr>
<tr>
<td>dedicated</td>
<td>专属的</td>
<td>形容词</td>
<td>/ˈdedɪkeɪtɪd/</td>
</tr>
<tr>
<td>deprecated</td>
<td>弃用的</td>
<td>形容词</td>
<td>/ˈdɛprəˌketɪd/</td>
</tr>
<tr>
<td>diversified</td>
<td>多样化的</td>
<td>形容词</td>
<td>/daɪˈvɜrsɪfaɪd/</td>
</tr>
<tr>
<td>elastic</td>
<td>灵活有弹性的</td>
<td>形容词</td>
<td>/ɪˈlæstɪk/</td>
<td>AWS Elastic Compute Cloud (EC2) 有「弹性、伸缩性」的特点</td>
</tr>
<tr>
<td>ephemeral</td>
<td>短暂性的</td>
<td>形容词</td>
<td>/ɪˈfemərəl/</td>
</tr>
<tr>
<td>explicit</td>
<td>明确清楚的</td>
<td>形容词</td>
<td>/ɪkˈsplɪsɪt/</td>
</tr>
<tr>
<td>granular</td>
<td>颗粒的</td>
<td>形容词</td>
<td>/ˈɡrænjələr/</td>
</tr>
<tr>
<td>heterogeneous</td>
<td>由很多种类组成的，混杂的，各种各样的</td>
<td>形容词</td>
<td>/ˌhetərəˈdʒiːniəs/</td>
</tr>
<tr>
<td>hierarchical</td>
<td>分层的</td>
<td>形容词</td>
<td>/ˌhaɪəˈrɑːrkɪkl/</td>
</tr>
<tr>
<td>immutable</td>
<td>不变的</td>
<td>形容词</td>
<td>/ɪˈmjuːtəbl/</td>
</tr>
<tr>
<td>imperative</td>
<td>命令式</td>
<td>形容词</td>
<td>/ɪmˈper.ə.t̬ɪv/</td>
</tr>
<tr>
<td>implicit</td>
<td>含蓄的、含糊不清的</td>
<td>形容词</td>
<td>/ɪmˈplɪs.ɪt/</td>
<td>浅显好过隐晦(Explicit is better than implicit)</td>
</tr>
<tr>
<td>incentive</td>
<td>激励的，刺激的</td>
<td>形容词</td>
<td>/ɪnˈsentɪv/</td>
</tr>
<tr>
<td>indecisive</td>
<td>犹豫不决的</td>
<td>形容词</td>
<td>/ˌindi’saisiv/</td>
</tr>
<tr>
<td>intermittent</td>
<td>间歇的</td>
<td>形容词</td>
<td>/ˌɪntərˈmɪtənt/</td>
</tr>
<tr>
<td>intrusive</td>
<td>侵入式的</td>
<td>形容词</td>
<td>/ɪnˈtruːsɪv/</td>
</tr>
<tr>
<td>intuitive</td>
<td>直觉的</td>
<td>形容词</td>
<td>/ɪnˈtuːɪtɪv/</td>
</tr>
<tr>
<td>mature</td>
<td>成熟的</td>
<td>形容词</td>
<td>/məˈtʃʊr/</td>
</tr>
<tr>
<td>mediocre</td>
<td>普通的，平凡的</td>
<td>形容词</td>
<td>/ˌmiːdiˈoʊkər/</td>
</tr>
<tr>
<td>miscellaneous</td>
<td>混杂、各式各样的</td>
<td>形容词</td>
<td>/ˌmɪsəˈleɪniəs/</td>
</tr>
<tr>
<td>mutable</td>
<td>可变的</td>
<td>形容词</td>
<td>/ˈmjuːtəbl/</td>
</tr>
<tr>
<td>on-premise</td>
<td>预置的</td>
<td>形容词</td>
<td>/ɑːnˈpremɪs/</td>
</tr>
<tr>
<td>permanent</td>
<td>永久的</td>
<td>形容词</td>
<td>/ˈpɜːrmənənt/</td>
</tr>
<tr>
<td>permissive</td>
<td>宽容的</td>
<td>形容词</td>
<td>/pərˈmɪsɪv/</td>
</tr>
<tr>
<td>rapid</td>
<td>迅速的、飞快的</td>
<td>形容词</td>
<td>/ˈræpɪd/</td>
</tr>
<tr>
<td>redacted</td>
<td>经过编辑的</td>
<td>形容词</td>
<td>/rəˈdakt/</td>
</tr>
<tr>
<td>resilient</td>
<td>有弹力的、能恢复的</td>
<td>形容词</td>
<td>/rɪˈzɪliənt/</td>
</tr>
<tr>
<td>respective</td>
<td>分别的，各自的</td>
<td>形容词</td>
<td>/rɪˈspektɪv/</td>
</tr>
<tr>
<td>retrospective</td>
<td>追溯的、回顾的、复盘的</td>
<td>形容词</td>
<td>/ˌretrəˈspektɪv/</td>
</tr>
<tr>
<td>robust</td>
<td>强健的，顽健的</td>
<td>形容词</td>
<td>/roʊˈbʌst/</td>
</tr>
<tr>
<td>seamless</td>
<td>无缝的</td>
<td>形容词</td>
<td>/ˈsiːmləs/</td>
</tr>
<tr>
<td>semantic</td>
<td>语义的</td>
<td>形容词</td>
<td>/sɪˈm</td>
</tr>
<tr>
<td>semantic</td>
<td>语义的</td>
<td>形容词</td>
<td>/sɪˈmæntɪk/</td>
</tr>
<tr>
<td>significant</td>
<td>重大的，有意义的</td>
<td>形容词</td>
<td>/sɪɡˈnɪfɪkənt/</td>
</tr>
<tr>
<td>sophisticated</td>
<td>复杂的、富有经验的</td>
<td>形容词</td>
<td>/səˈfɪstɪkeɪtɪd/</td>
</tr>
<tr>
<td>standalone</td>
<td>单独的</td>
<td>形容词</td>
<td>/ˈstændəˌləun/</td>
</tr>
<tr>
<td>subsequent</td>
<td>随后的、之后的</td>
<td>形容词</td>
<td>/ˈsʌbsɪkwənt/</td>
</tr>
<tr>
<td>substantial</td>
<td>实质的</td>
<td>形容词</td>
<td>/səbˈstænʃl/</td>
</tr>
<tr>
<td>subtle</td>
<td>微小（但重要）的，微妙的</td>
<td>形容词</td>
<td>/ˈsʌt̬.əl/</td>
</tr>
<tr>
<td>sustainable</td>
<td>可持续的</td>
<td>形容词</td>
<td>/səˈsteɪnəbl/</td>
</tr>
<tr>
<td>symmetric</td>
<td>对称的</td>
<td>形容词</td>
<td>/sɪ’mɛtrɪk/</td>
</tr>
<tr>
<td>synchronous</td>
<td>同步的</td>
<td>形容词</td>
<td>/ˈsɪŋkrənəs/</td>
</tr>
<tr>
<td>thrilled</td>
<td>非常兴奋的</td>
<td>形容词</td>
<td>/θrɪld/</td>
</tr>
<tr>
<td>underlying</td>
<td>在下面的，潜在的，深层的</td>
<td>形容词</td>
<td>/ˌʌndərˈlaɪɪŋ/</td>
</tr>
</tbody>
</table>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>aggregate</td>
<td>聚合，整合</td>
<td>动词</td>
<td>/ˈæɡrɪɡət/</td>
<td>将多条信息聚合到一起，比如聚合类的新闻客户端</td>
</tr>
<tr>
<td>allocate</td>
<td>分配</td>
<td>动词</td>
<td>/ˈæləkeɪt/</td>
</tr>
<tr>
<td>analyze</td>
<td>分析</td>
<td>动词</td>
<td>/ˈænəlaɪz/</td>
</tr>
<tr>
<td>capture</td>
<td>捕捉、抓取</td>
<td>动词</td>
<td>/ˈkæptʃər/</td>
</tr>
<tr>
<td>concatenate</td>
<td>连接</td>
<td>动词</td>
<td>/kɑnˈkætəˌnet/</td>
</tr>
<tr>
<td>decouple</td>
<td>解耦，使分离</td>
<td>动词</td>
<td>/diːˈkʌpl/</td>
</tr>
<tr>
<td>differentiate</td>
<td>区分</td>
<td>动词</td>
<td>/ˌdɪfəˈrenʃieɪt/</td>
</tr>
<tr>
<td>embrace</td>
<td>拥抱、接受</td>
<td>动词</td>
<td>/ɪmˈbreɪs/</td>
<td>拥抱某种技术</td>
</tr>
<tr>
<td>encapsulate</td>
<td>压缩、封装</td>
<td>动词</td>
<td>/ɪnˈkæpsjuleɪt/</td>
</tr>
<tr>
<td>escalate</td>
<td>升级</td>
<td>动词</td>
<td>/ˈeskəleɪt/</td>
</tr>
<tr>
<td>impersonate</td>
<td>扮演，模仿</td>
<td>动词</td>
<td>/ɪmˈpɜːrsəneɪt/</td>
</tr>
<tr>
<td>introspect</td>
<td>自解析，自省</td>
<td>动词</td>
<td>/ˌɪntrə’spɛkt/</td>
<td>常用于身份认证过程中，对token 进行自解析。</td>
</tr>
<tr>
<td>leverage</td>
<td>借用、利用</td>
<td>动词</td>
<td>/ˈlevərɪdʒ/</td>
</tr>
<tr>
<td>marry</td>
<td>结合、联合</td>
<td>动词</td>
<td>/ˈmæri/</td>
</tr>
<tr>
<td>mitigate</td>
<td>减轻，缓和</td>
<td>动词</td>
<td>/ˈmɪtɪɡeɪt/</td>
</tr>
<tr>
<td>monetize</td>
<td>货币化</td>
<td>动词</td>
<td>/ˈmɑːnɪtaɪz/</td>
<td>将产品货币化，通过产品赚钱</td>
</tr>
<tr>
<td>optimize</td>
<td>优化</td>
<td>动词</td>
<td>/ˈɑːptɪmaɪz/</td>
</tr>
<tr>
<td>populate</td>
<td>输入数据</td>
<td>动词</td>
<td>/ˈpɑːpjuleɪt/</td>
</tr>
<tr>
<td>ratify</td>
<td>批准，认可</td>
<td>动词</td>
<td>/ˈrætɪfaɪ/</td>
</tr>
<tr>
<td>reconcile</td>
<td>调停，调解，顺从</td>
<td>动词</td>
<td>/ˈrekənsaɪl/</td>
</tr>
<tr>
<td>rectify</td>
<td>改正，修正，纠正</td>
<td>动词</td>
<td>/ˈrektɪfaɪ/</td>
</tr>
<tr>
<td>retain</td>
<td>保持</td>
<td>动词</td>
<td>/rɪˈteɪn/</td>
</tr>
<tr>
<td>revisit</td>
<td>再访，再议</td>
<td>动词</td>
<td>/ˌriːˈvɪzɪt/</td>
</tr>
<tr>
<td>streamline</td>
<td>使现代化、流线，使合理化</td>
<td>动词</td>
<td>/ˈstriːmlaɪn/</td>
</tr>
<tr>
<td>undertake</td>
<td>承担</td>
<td>动词</td>
<td>/ˌʌndərˈteɪk/</td>
</tr>
<tr>
<td>debug</td>
<td>调试</td>
<td>动词</td>
<td>/ˈdiːbʌɡ/</td>
</tr>
<tr>
<td>implement</td>
<td>实现，执行</td>
<td>动词</td>
<td>/ˈɪmplɪment/</td>
<td>一个类对一个接口的实现</td>
</tr>
<tr>
<td>inherit</td>
<td>继承</td>
<td>动词</td>
<td>/ɪnˈherɪt/</td>
</tr>
</tbody>
</table>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>aggregation</td>
<td>聚合</td>
<td>名词</td>
<td>/ˌæɡrɪˈɡeɪʃn/</td>
</tr>
<tr>
<td>agility</td>
<td>敏捷，灵活</td>
<td>名词</td>
<td>/əˈdʒɪləti/</td>
</tr>
<tr>
<td>amortization</td>
<td>摊销</td>
<td>名词</td>
<td>/ˌæmərtəˈzeɪʃn/</td>
</tr>
<tr>
<td>analogy</td>
<td>类比，比喻</td>
<td>名词</td>
<td>/əˈnælədʒi/</td>
</tr>
<tr>
<td>anomaly</td>
<td>异常，反常事物</td>
<td>名词</td>
<td>/əˈnɑːməli/</td>
</tr>
<tr>
<td>architecture</td>
<td>架构</td>
<td>名词</td>
<td>/ˈɑːrkɪtektʃər/</td>
</tr>
<tr>
<td>ascent</td>
<td>上升，升序</td>
<td>名词</td>
<td>/əˈsent/</td>
</tr>
<tr>
<td>aspect</td>
<td>方面，方向</td>
<td>名词</td>
<td>/ˈæspekt/</td>
</tr>
<tr>
<td>authentication</td>
<td>身份验证</td>
<td>名词</td>
<td>/ɔːˌθentɪˈkeɪʃn/</td>
</tr>
<tr>
<td>authorization</td>
<td>授权，认可</td>
<td>名词</td>
<td>/ˌɔːθərəˈzeɪʃn/</td>
</tr>
<tr>
<td>automation</td>
<td>自动化</td>
<td>名词</td>
<td>/ˌɔːtəˈmeɪʃn/</td>
</tr>
<tr>
<td>bandwidth</td>
<td>带宽，多余时间（人力）</td>
<td>名词</td>
<td>/ˈbændwɪdθ/</td>
<td>后者意思是咨询有没有足够的资源或时间来完成某件事情</td>
</tr>
<tr>
<td>bogus</td>
<td>假的，伪造</td>
<td>名词</td>
<td>/ˈboʊɡəs/</td>
</tr>
<tr>
<td>bottleneck</td>
<td>瓶颈</td>
<td>名词</td>
<td>/ˈbɑːtlnek/</td>
</tr>
<tr>
<td>capacity</td>
<td>能力、容量</td>
<td>名词</td>
<td>/kəˈpæsəti/</td>
</tr>
<tr>
<td>caveats</td>
<td>注意事项</td>
<td>名词</td>
<td>/ˈkæviæt/</td>
</tr>
<tr>
<td>characteristic</td>
<td>特征，特性</td>
<td>名词</td>
<td>/ˌkærəktəˈrɪstɪk/</td>
</tr>
<tr>
<td>cluster</td>
<td>集群</td>
<td>名词</td>
<td>/ˈklʌstər/</td>
</tr>
<tr>
<td>complexity</td>
<td>复杂性</td>
<td>名词</td>
<td>/kəmˈpleksəti/</td>
</tr>
<tr>
<td>compliance</td>
<td>合规</td>
<td>名词</td>
<td>/kəmˈplaɪəns/</td>
</tr>
<tr>
<td>compromise</td>
<td>泄漏，破解</td>
<td>名词</td>
<td>/ˈkɑːmprəmaɪz/</td>
</tr>
<tr>
<td>confidentiality</td>
<td>保密性</td>
<td>名词</td>
<td>/ˌkɑːnfɪˌdenʃiˈæləti/</td>
</tr>
<tr>
<td>constant</td>
<td>常数，恒量</td>
<td>名词</td>
<td>/ˈkɑːnstənt/</td>
</tr>
<tr>
<td>constraint</td>
<td>约束</td>
<td>名词</td>
<td>/kənˈstreɪnt/</td>
</tr>
<tr>
<td>consumption</td>
<td>消耗</td>
<td>名词</td>
<td>/kənˈsʌmpʃn/</td>
</tr>
<tr>
<td>contrast</td>
<td>对比</td>
<td>名词</td>
<td>/ˈkɑːntræst/</td>
</tr>
<tr>
<td>degradation</td>
<td>降级</td>
<td>名词</td>
<td>/ˌdeɡrəˈdeɪʃn/</td>
</tr>
<tr>
<td>delivery</td>
<td>交付</td>
<td>名词</td>
<td>/dɪˈlɪvəri/</td>
</tr>
<tr>
<td>depreciation</td>
<td>折旧，贬值</td>
<td>名词</td>
<td>/dɪˌpriːʃiˈeɪʃn/</td>
</tr>
<tr>
<td>descent</td>
<td>下降，降序</td>
<td>名词</td>
<td>/dɪˈsent/</td>
</tr>
<tr>
<td>disclaimer</td>
<td>免责声明</td>
<td>名词</td>
<td>/dɪˈskleɪ.mɚ/</td>
</tr>
<tr>
<td>distinction</td>
<td>区别、差别</td>
<td>名词</td>
<td>/dɪˈstɪŋkʃn/</td>
</tr>
<tr>
<td>durability</td>
<td>持久性，耐用性</td>
<td>名词</td>
<td>/ˌdʊrəˈbɪləti/</td>
</tr>
<tr>
<td>efficiency</td>
<td>效率</td>
<td>名词</td>
<td>/ɪˈfɪʃnsi/</td>
</tr>
<tr>
<td>elasticity</td>
<td>弹性，灵活性</td>
<td>名词</td>
<td>/ˌiːlæˈstɪsəti/</td>
</tr>
<tr>
<td>encryption</td>
<td>加密</td>
<td>名词</td>
<td>/ɪnˈkrɪpʃn/</td>
</tr>
<tr>
<td>equivalent</td>
<td>对等的人（或事物）；</td>
<td>名词</td>
<td>/ɪˈkwɪvələnt/</td>
</tr>
<tr>
<td>evaluation</td>
<td>评价，计算</td>
<td>名词</td>
<td>/ɪˌvæljuˈeɪʃn/</td>
</tr>
<tr>
<td>evolution</td>
<td>进化、演变</td>
<td>名词</td>
<td>/ˌevəˈluːʃn/</td>
</tr>
<tr>
<td>expenditure</td>
<td>支出，经费</td>
<td>名词</td>
<td>/ɪkˈspendɪtʃər/</td>
</tr>
<tr>
<td>failback</td>
<td>自动恢复</td>
<td>名词</td>
<td>/null/</td>
<td>在簇（Data Cluster）网络系统中，由于某台服务器要进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复</td>
</tr>
<tr>
<td>failover</td>
<td>失效转移</td>
<td>名词</td>
<td>/feilˈəuvər/</td>
<td>即当 A 无法为客户服务时，系统能够自动地切换，使 B 能够及时地顶上继续为客户提供服务，且客户感觉不到这个为他提供服务的对象已经更换</td>
</tr>
<tr>
<td>federation</td>
<td>联合授权</td>
<td>名词</td>
<td>/ˌfedəˈreɪʃn/</td>
</tr>
<tr>
<td>glossary</td>
<td>术语</td>
<td>名词</td>
<td>/ˈɡlɑːsəri/</td>
</tr>
<tr>
<td>homebrew</td>
<td>自制程序</td>
<td>名词</td>
<td>/ˌhoʊmˈbruː/</td>
<td>开源的软件包管理系统，<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></td>
</tr>
<tr>
<td>hypervisor</td>
<td>虚拟机器监视器（VMM）</td>
<td>名词</td>
<td>/ˌhaipəˈvaizə/</td>
</tr>
<tr>
<td>hypothesis</td>
<td>假设</td>
<td>名词</td>
<td>/haɪˈpɑːθəsɪs/</td>
</tr>
<tr>
<td>impact</td>
<td>绩效，影响</td>
<td>名词</td>
<td>/ˈɪmpækt/</td>
</tr>
<tr>
<td>impression</td>
<td>曝光</td>
<td>名词</td>
<td>/ɪmˈpreʃn/</td>
</tr>
<tr>
<td>inception</td>
<td>起始，创立</td>
<td>名词</td>
<td>/ɪnˈsepʃn/</td>
</tr>
<tr>
<td>incident</td>
<td>事故</td>
<td>名词</td>
<td>/ˈɪnsɪdənt/</td>
</tr>
<tr>
<td>infrastructure</td>
<td>基础设施</td>
<td>名词</td>
<td>/ˈɪnfrəstrʌktʃər/</td>
</tr>
<tr>
<td>initiative</td>
<td>方案、倡议</td>
<td>名词</td>
<td>/ɪˈnɪʃətɪv/</td>
</tr>
<tr>
<td>integration</td>
<td>集成，整合</td>
<td>名词</td>
<td>/ˌɪntɪˈɡreɪʃn/</td>
</tr>
<tr>
<td>integrity</td>
<td>完整性</td>
<td>名词</td>
<td>/ɪnˈteɡrəti/</td>
</tr>
<tr>
<td>interaction</td>
<td>交互、相互影响、干涉</td>
<td>名词</td>
<td>/ˌɪntərˈækʃn/</td>
</tr>
<tr>
<td>intervention</td>
<td>介入、干涉</td>
<td>名词</td>
<td>/ˌɪntərˈvenʃn/</td>
</tr>
<tr>
<td>latency</td>
<td>延迟</td>
<td>名词</td>
<td>/ˈleɪtənsi/</td>
</tr>
<tr>
<td>malware</td>
<td>恶意软件</td>
<td>名词</td>
<td>/ˈmælwer/</td>
</tr>
<tr>
<td>mechanism</td>
<td>机制，原理</td>
<td>名词</td>
<td>/ˈmekənɪzəm/</td>
</tr>
<tr>
<td>metrics</td>
<td>数据指标</td>
<td>名词</td>
<td>/ˈmetrɪks/</td>
</tr>
<tr>
<td>model</td>
<td>模型</td>
<td>名词</td>
<td>/ˈmɑːdl/</td>
</tr>
<tr>
<td>module</td>
<td>模块</td>
<td>名词</td>
<td>/ˈmɑːdʒuːl/</td>
</tr>
<tr>
<td>notation</td>
<td>注释、标注</td>
<td>名词</td>
<td>/noʊˈteɪʃn/</td>
</tr>
<tr>
<td>occasion</td>
<td>场合、机会</td>
<td>名词</td>
<td>/əˈkeɪʒn/</td>
</tr>
<tr>
<td>optimization</td>
<td>优化</td>
<td>名词</td>
<td>/ˌɑptəmɪˈzeʃən/</td>
</tr>
<tr>
<td>overhead</td>
<td>额外开销，虚耗</td>
<td>名词</td>
<td>/ˌovɚˈhɛd/</td>
<td>In  computer  science, overhead  is any combination of excess or indirect computation time, memory, bandwidth, or other resources that are required to perform a  specific task.</td>
</tr>
<tr>
<td>oversight</td>
<td>疏忽、失察</td>
<td>名词</td>
<td>/ˈoʊvərsaɪt/</td>
</tr>
<tr>
<td>permutation</td>
<td>排序</td>
<td>名词</td>
<td>/ˌpɜːrmjuˈteɪʃn/</td>
</tr>
<tr>
<td>polyfill</td>
<td>填充物</td>
<td>名词</td>
<td>/ˈpəʊliːfɪl/</td>
<td>常指代 JavaScript 的特性，<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Polyfill" target="_blank" rel="noopener">MDN 说明</a></td>
</tr>
<tr>
<td>post-mortem</td>
<td>尸体解剖，事后反思（或剖析）</td>
<td>名词</td>
<td>/ˌpoʊst ˈmɔːrtəm/</td>
</tr>
<tr>
<td>priority</td>
<td>优先次序</td>
<td>名词</td>
<td>/praɪˈɔːrəti/</td>
</tr>
<tr>
<td>privilege</td>
<td>特权，优待</td>
<td>名词</td>
<td>/ˈprɪvəlɪdʒ/</td>
</tr>
<tr>
<td>protocol</td>
<td>协议</td>
<td>名词</td>
<td>/ˈproʊtəkɑːl/</td>
</tr>
<tr>
<td>provision</td>
<td>规定；预备；准备</td>
<td>名词</td>
<td>/prəˈvɪʒn/</td>
<td>例如对UFS设备进行provision，分区、划分LUN等操作</td>
</tr>
<tr>
<td>recursion</td>
<td>递归</td>
<td>名词</td>
<td>/rɪˈkɜːrʒn/</td>
</tr>
<tr>
<td>redundancy</td>
<td>冗余，多余</td>
<td>名词</td>
<td>/rɪˈdʌndənsi/</td>
</tr>
<tr>
<td>reliability</td>
<td>可靠性</td>
<td>名词</td>
<td>/rɪˌlaɪəˈbɪləti/</td>
</tr>
<tr>
<td>remediation</td>
<td>补救，矫正</td>
<td>名词</td>
<td>/rɪˌmiːdiˈeɪʃn/</td>
</tr>
<tr>
<td>replica</td>
<td>复制物</td>
<td>名词</td>
<td>/ˈreplikə/</td>
</tr>
<tr>
<td>resilience</td>
<td>回弹性</td>
<td>名词</td>
<td>/rɪˈzɪliəns/</td>
</tr>
<tr>
<td>restriction</td>
<td>限制，约束</td>
<td>名词</td>
<td>/ri’strikʃən/</td>
</tr>
<tr>
<td>scalability</td>
<td>可扩展性</td>
<td>名词</td>
<td>/ˌskeɪləˈbɪləti/</td>
</tr>
<tr>
<td>scenario</td>
<td>场景</td>
<td>名词</td>
<td>/sɪˈnɛrɪˌo/</td>
</tr>
<tr>
<td>scheduler</td>
<td>时间调度程序</td>
<td>名词</td>
<td>/ˈskedʒuːlər/</td>
</tr>
<tr>
<td>schema</td>
<td>提要，纲要，架构</td>
<td>名词</td>
<td>/ˈskiːmə/</td>
<td>多用于 database schema</td>
</tr>
<tr>
<td>scope</td>
<td>范围，作用域</td>
<td>名词</td>
<td>/skoʊp/</td>
</tr>
<tr>
<td>severity</td>
<td>严重性</td>
<td>名词</td>
<td>/sɪˈverəti/</td>
<td>用于表达事故的严重程度</td>
</tr>
<tr>
<td>strength</td>
<td>优势</td>
<td>名词</td>
<td>/streŋkθ/</td>
</tr>
<tr>
<td>stroke</td>
<td>笔画</td>
<td>名词</td>
<td>/stroʊk/</td>
</tr>
<tr>
<td>subsidiary</td>
<td>子公司</td>
<td>名词</td>
<td>/ˈsəbsɪdieri/</td>
</tr>
<tr>
<td>takeaway</td>
<td>收获、学到什么</td>
<td>名词</td>
<td>/ˈteɪkəweɪ/</td>
</tr>
<tr>
<td>taxonomy</td>
<td>分类</td>
<td>名词</td>
<td>/tækˈsɑːnəmi/</td>
</tr>
<tr>
<td>tenancy</td>
<td>租期</td>
<td>名词</td>
<td>/ˈtenənsi/</td>
</tr>
<tr>
<td>tentative</td>
<td>假设，试验</td>
<td>名词</td>
<td>/ˈtentətɪv/</td>
</tr>
<tr>
<td>threshold</td>
<td>阈值</td>
<td>名词</td>
<td>/ˈθreʃhoʊld/</td>
</tr>
<tr>
<td>throughput</td>
<td>吞吐量</td>
<td>名词</td>
<td>/ˈθruːpʊt/</td>
</tr>
<tr>
<td>tolerance</td>
<td>容忍</td>
<td>名词</td>
<td>/ˈtɑːlərəns/</td>
</tr>
<tr>
<td>traceability</td>
<td>可追溯性</td>
<td>名词</td>
<td>/ˌtresəˈbɪləti/</td>
</tr>
<tr>
<td>trajectory</td>
<td>轨道，轨迹</td>
<td>名词</td>
<td>/trəˈdʒektəri/</td>
</tr>
<tr>
<td>traversal</td>
<td>遍历</td>
<td>名词</td>
<td>/trəˈvərsəl/</td>
</tr>
<tr>
<td>tweak</td>
<td>扭，调整</td>
<td>名词</td>
<td>/twiːk/</td>
</tr>
<tr>
<td>utilization</td>
<td>利用，使用</td>
<td>名词</td>
<td>/ˌjuːtələˈzeɪʃn/</td>
</tr>
<tr>
<td>vulnerability</td>
<td>易损性，弱点</td>
<td>名词</td>
<td>/ˌvʌlnərəˈbɪləti/</td>
</tr>
<tr>
<td>workaround</td>
<td>变通方案</td>
<td>名词</td>
<td>/ˈwə:kə,raund/</td>
<td>特指方案具有迂回性质</td>
</tr>
<tr>
<td>database</td>
<td>数据库</td>
<td>名词</td>
<td>/ˈdɑːtəbeɪs/</td>
</tr>
<tr>
<td>expression</td>
<td>表达式</td>
<td>名词</td>
<td>/ɪkˈspreʃn/</td>
</tr>
<tr>
<td>permission</td>
<td>权限</td>
<td>名词</td>
<td>/pəˈmɪʃn/</td>
</tr>
</tbody>
</table>
<h3 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>alphabetically</td>
<td>按字母顺序排列地</td>
<td>副词</td>
<td>/ˌælfəˈbetɪkli/</td>
</tr>
<tr>
<td>discretely</td>
<td>离散地，分离地</td>
<td>副词</td>
<td>/dɪˈskriːtli/</td>
</tr>
<tr>
<td>furthermore</td>
<td>此外，而且</td>
<td>副词</td>
<td>/ˌfɜːrðərˈmɔːr/</td>
</tr>
<tr>
<td>manually</td>
<td>手动地</td>
<td>副词</td>
<td>/ˈmænjuəli/</td>
</tr>
<tr>
<td>periodically</td>
<td>定期地，周期性地</td>
<td>副词</td>
<td>/ˌpɪriˈɑːdɪkli/</td>
</tr>
<tr>
<td>simultaneously</td>
<td>同时地</td>
<td>副词</td>
<td>/ˌsaɪmlˈteɪniəsli/</td>
</tr>
</tbody>
</table>
<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ampersand</td>
<td>和</td>
<td>符号</td>
<td>/ˈæmpərsænd/</td>
<td>&amp;</td>
</tr>
<tr>
<td>angle brackets</td>
<td>尖括号</td>
<td>符号</td>
<td>/null/</td>
<td>&lt; &gt;</td>
</tr>
<tr>
<td>asterisk</td>
<td>星号</td>
<td>符号</td>
<td>/ˈæstərɪsk/</td>
<td>*</td>
</tr>
<tr>
<td>at</td>
<td>邮件符号</td>
<td>符号</td>
<td>/æt/</td>
<td>@</td>
</tr>
<tr>
<td>backslash</td>
<td>反斜线符号</td>
<td>/ˈbækslæʃ/</td>
<td>\</td>
</tr>
<tr>
<td>caret</td>
<td>折音号</td>
<td>符号</td>
<td>/ˈkærət/</td>
<td>^</td>
</tr>
<tr>
<td>colon</td>
<td>冒号</td>
<td>符号</td>
<td>/ˈkoʊlən/</td>
<td>:</td>
</tr>
<tr>
<td>comma</td>
<td>逗号</td>
<td>符号</td>
<td>/ˈkɑːmə/</td>
<td>,</td>
</tr>
<tr>
<td>curly brackets</td>
<td>花括号</td>
<td>符号</td>
<td>/null/</td>
<td>{ }</td>
</tr>
<tr>
<td>dash</td>
<td>破折号</td>
<td>符号</td>
<td>/dæʃ/</td>
<td>—</td>
</tr>
<tr>
<td>dollar sign</td>
<td>美元符号</td>
<td>符号</td>
<td>/null/</td>
<td>$</td>
</tr>
<tr>
<td>double quotation mark</td>
<td>双引号</td>
<td>符号</td>
<td>/null/</td>
<td>“</td>
</tr>
<tr>
<td>downwards arrow</td>
<td>向下箭头</td>
<td>符号</td>
<td>/null/</td>
<td>↓</td>
</tr>
<tr>
<td>ellipsis</td>
<td>省略号</td>
<td>符号</td>
<td>/ɪˈlɪpsɪs/</td>
<td>…</td>
</tr>
<tr>
<td>equal</td>
<td>等于号</td>
<td>符号</td>
<td>/ˈiːkwəl/</td>
<td>=</td>
</tr>
<tr>
<td>exclamation mark</td>
<td>惊叹号，感叹号</td>
<td>符号</td>
<td>/ˌekskləˈmeɪʃn/</td>
<td>!</td>
</tr>
<tr>
<td>greater than</td>
<td>大于号</td>
<td>符号</td>
<td>/null/</td>
<td>&gt;</td>
</tr>
<tr>
<td>hash</td>
<td>井号</td>
<td>符号</td>
<td>/hæʃ/</td>
<td>#</td>
</tr>
<tr>
<td>hyphen</td>
<td>连字符</td>
<td>符号</td>
<td>/ˈhaɪfn/</td>
<td>-</td>
</tr>
<tr>
<td>left arrow</td>
<td>向左箭头</td>
<td>符号</td>
<td>/null/</td>
<td>←</td>
</tr>
<tr>
<td>less than</td>
<td>小于号</td>
<td>符号</td>
<td>/null/</td>
<td>&lt;</td>
</tr>
<tr>
<td>minus</td>
<td>减号</td>
<td>符号</td>
<td>/ˈmaɪnəs/</td>
<td>-</td>
</tr>
<tr>
<td>parenthesis</td>
<td>圆括号</td>
<td>符号</td>
<td>/pəˈrenθəsɪs/</td>
<td>( )</td>
</tr>
<tr>
<td>percent</td>
<td>百分号</td>
<td>符号</td>
<td>/pərˈsent/</td>
<td>%</td>
</tr>
<tr>
<td>period</td>
<td>句号</td>
<td>符号</td>
<td>/ˈpɪriəd/</td>
<td>.</td>
</tr>
<tr>
<td>plus</td>
<td>加号</td>
<td>符号</td>
<td>/plʌs/</td>
<td>+</td>
</tr>
<tr>
<td>question mark</td>
<td>问号</td>
<td>符号</td>
<td>/ˈkwestʃən/</td>
<td>?</td>
</tr>
<tr>
<td>right arrow</td>
<td>向右箭头</td>
<td>符号</td>
<td>/null/</td>
<td>→</td>
</tr>
<tr>
<td>section</td>
<td>分节号</td>
<td>符号</td>
<td>/ˈsekʃn/</td>
<td>§</td>
</tr>
<tr>
<td>semicolon</td>
<td>分号</td>
<td>符号</td>
<td>/ˈsemikoʊlən/</td>
<td>;</td>
</tr>
<tr>
<td>single quotation mark</td>
<td>单引号</td>
<td>符号</td>
<td>/null/</td>
<td>‘</td>
</tr>
<tr>
<td>slash</td>
<td>斜线号</td>
<td>符号</td>
<td>/slæʃ/</td>
<td>／</td>
</tr>
<tr>
<td>square brackets</td>
<td>方括号</td>
<td>符号</td>
<td>/null/</td>
<td>[ ]</td>
</tr>
<tr>
<td>tilde</td>
<td>波浪号</td>
<td>符号</td>
<td>/ˈtɪldə/</td>
<td>～</td>
</tr>
<tr>
<td>underscore</td>
<td>下划线</td>
<td>符号</td>
<td>/ˌʌndərˈskɔːr/</td>
<td>_</td>
</tr>
<tr>
<td>upwards arrow</td>
<td>向上箭头</td>
<td>符号</td>
<td>/null/</td>
<td>↑</td>
</tr>
</tbody>
</table>
<h3 id="词组"><a href="#词组" class="headerlink" title="词组"></a>词组</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>catastrophic failover</td>
<td>灾难性故障转移</td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>data sovereignty</td>
<td>数据主权</td>
<td>词组</td>
<td>/null/</td>
<td>数据主权指的是在该国或地区采集的数据应当归属于当地政府且需服从当地法律法规</td>
</tr>
<tr>
<td>dead letter queue</td>
<td>死信队列</td>
<td>词组</td>
<td>/null/</td>
<td>在队列服务中，那些无法发送的信息将被送至死信队列</td>
</tr>
<tr>
<td>faceted search</td>
<td>分面搜索</td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>false positive</td>
<td>假阳性</td>
<td>词组</td>
<td>/null/</td>
<td>当你真的没有的时候，别人却说你有。</td>
</tr>
<tr>
<td>fault tolerance</td>
<td></td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>magnetic storage</td>
<td>磁储存</td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>roll off</td>
<td>TBD</td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>roll out</td>
<td>TBD</td>
<td>词组</td>
<td>/null/</td>
</tr>
<tr>
<td>strangler pattern</td>
<td>绞杀者模式</td>
<td>词组</td>
<td>/null/</td>
<td>通过将特定的功能片断逐渐取代为新的应用程序和服务，逐步迁移旧系统。 随着旧系统的功能被替换，新系统最终将取代旧系 统的所有功能，抑制旧系统并使其停用。</td>
</tr>
<tr>
<td>under the hood</td>
<td>引擎罩下，比喻内幕、原理</td>
<td>词组</td>
<td>/null/</td>
<td>Beneath the surface; in its internal workings</td>
</tr>
<tr>
<td>vice versa</td>
<td>反之亦然</td>
<td>词组</td>
<td>/ˌvaisi’və:sə/</td>
</tr>
</tbody>
</table>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><table>
<thead>
<tr>
<th>单词</th>
<th>翻译</th>
<th>词性</th>
<th>美式发音</th>
<th>实例应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLI</td>
<td>命令行界面</td>
<td>缩写</td>
<td>/null/</td>
<td>Command Line Interface</td>
</tr>
<tr>
<td>GUI</td>
<td>图形用户界面</td>
<td>缩写</td>
<td>/null/</td>
<td>Graphical User Interface</td>
</tr>
<tr>
<td>UUID / GUID</td>
<td>全局唯一标识符</td>
<td>缩写</td>
<td>/null/</td>
<td>Globally Unique Identifier</td>
</tr>
<tr>
<td>SIT</td>
<td>系统整合测试</td>
<td>缩写</td>
<td>/null/</td>
<td>System Integration Testing</td>
</tr>
<tr>
<td>UAT</td>
<td>用户验收测试</td>
<td>缩写</td>
<td>/null/</td>
<td>User Acceptance Testing</td>
</tr>
<tr>
<td>BIOS</td>
<td>基本输入输出系统</td>
<td>缩写</td>
<td>/null/</td>
<td>Basic Input Output System</td>
</tr>
<tr>
<td>DOM</td>
<td>文档对象模型</td>
<td>缩写</td>
<td>/null/</td>
<td>Document Object Model</td>
</tr>
<tr>
<td>HTML</td>
<td>超文本标记语言</td>
<td>缩写</td>
<td>/null/</td>
<td>HyperText Markup Language</td>
</tr>
</tbody>
</table>
<h3 id="其他网站"><a href="#其他网站" class="headerlink" title="其他网站"></a>其他网站</h3><p><a href="https://www.51test.net/show/9115284.html" target="_blank" rel="noopener">程序员常用英语词汇</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>英语词汇</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>如何超过大多数人</title>
    <url>/2019/07/22/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/如何超过大多数人/1-2023-03-06-09-50-46.png" alt="1-2023-03-06-09-50-46"><br><a id="more"></a></p>
<p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的5兴趣，因为你的潜意识在告诉你，这是一本人生的 “武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径…… 然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力…… 然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍” 用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个 “人生导师” 可以写得好。毕竟，我的生命过到了十六进制 2B 的年纪，踏入这个社会已超过 20 年，舍我其谁呢？！</p>
<p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html" target="_blank" rel="noopener">如何写出无法维护的代码</a>》一文的风格…… 嘿嘿</p>
<blockquote>
<h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4></blockquote>
<p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些 “技巧” 你要多多了解一下。</p>
<p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p>
<ul>
<li><p>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识…… 要做到这一步，你就需要把 “百度一下” 挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种 “如何看待……” 这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</p>
</li>
<li><p>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向…… 是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</p>
</li>
<li><p>把今日头条和抖音这样的 APP 推荐给大家…… 你只需要让你有朋友成功地安装这两个 APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</p>
</li>
<li><p>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，…… 这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些 SB 或是很极端的观点，造成大家的一睦讨论后，就早早离场……</p>
</li>
<li><p>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了…… 这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</p>
</li>
</ul>
<p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p>
<ul>
<li><p>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</p>
</li>
<li><p>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</p>
</li>
<li><p>不断地给他们各种各样 “有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书 “收藏家”……</p>
</li>
<li><p>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用 “死记硬背” 的方式来学习，甚至直接让他们失去信心，直接放弃……</p>
</li>
<li><p>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</p>
</li>
<li><p>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</p>
</li>
<li><p>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</p>
</li>
<li><p>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</p>
</li>
<li><p>让他们觉得 “读完书”、“读过书” 就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</p>
</li>
</ul>
<p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p>
<ul>
<li><p>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</p>
</li>
<li><p>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入 “赌博类” 或是 “传销类” 的地方，比如：股市、数字货币…… 要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</p>
</li>
<li><p>告诉他们，一些看上去很难的事都是有捷径的，比如：21 天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</p>
</li>
<li><p>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</p>
</li>
<li><p>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</p>
</li>
<li><p>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</p>
</li>
<li><p>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</p>
</li>
<li><p>告诉他们你的行业太累太辛苦，干不到 30 岁。让他们早点转行，不要耽误人生和青春……</p>
</li>
<li><p>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</p>
</li>
<li><p>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的…… 这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</p>
</li>
<li><p>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</p>
</li>
</ul>
<p><strong>最后友情提示一下，上述的这些 “最佳实践” 你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是 “欲练神功，必先自宫” 的道理。</strong></p>
<blockquote>
<h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4></blockquote>
<p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p>
<p>一般来说，超过别人一般来说就是两个维度：</p>
<ul>
<li><p><strong>在认知、知识和技能上。</strong> 这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html" target="_blank" rel="noopener">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21 天教你学会 C++</a>》）</p>
</li>
<li><p><strong>在领导力上。</strong> 所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">技术人员发展之路</a>》）</p>
</li>
</ul>
<p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把 “零碎的认知” 转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90% 的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p>
<blockquote>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4></blockquote>
<p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p>
<p>1）<strong>信息渠道。</strong> 试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人 hack 其中的信息（也就是 “中间人攻击”），而这些找不出信息源的人，只能 “被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习 C 语言，放着原作者 K&amp;R 的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p>
<p>2）<strong>信息质量。</strong> 信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p>
<p>3）<strong>信息密度。</strong> 优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践…… 一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix 编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像 Netflix 的官方 blog 和 AWS CTO 的 blog 等等地方也会经常有一些这样的文章。</p>
<blockquote>
<h4 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h4></blockquote>
<p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p>
<p>1）<strong>知识树（图）。</strong> 任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基” 是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p>
<p>2）<strong>知识缘由。</strong> 任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p>
<p>3）<strong>方法套路。</strong> 学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。</p>
<blockquote>
<h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4></blockquote>
<p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p>
<p>1）<strong>精益求精。</strong> 如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p>
<p>2）<strong>让自己犯错。</strong> 犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p>
<p>3）<strong>找高手切磋。</strong> 下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p>
<blockquote>
<h4 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h4></blockquote>
<p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p>
<p>1）<strong>识别自己的特长和天赋。</strong> 首先，每个人 DNA 都可能或多或少都会有一些比大多数人 NB 的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p>
<p>2）<strong>识别自己的兴趣和事业。</strong> 没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus 就是在学校里对 minx 着迷了，于是整出个 Linux 来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫 “真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心” 和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p>
<p>3）<strong>建立高级的习惯和方法。</strong> 没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来…… 自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p>
<p>4）<strong>勤奋努力执着坚持。</strong> 如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的 “一万小时定律” 了（参看《21 天教你学会 C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要 1 年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p>
<p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p>
<p>（全文完）</p>
<blockquote>
<p>本文转自：<a href="https://coolshell.cn/" target="_blank" rel="noopener">CoolShell</a> 的<a href="https://coolshell.cn/articles/19464.html/comment-page-1#comments" target="_blank" rel="noopener">《如何超过大多数人》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>超过</tag>
      </tags>
  </entry>
  <entry>
    <title>设置mac自带的vim语法高亮</title>
    <url>/2018/06/15/%E8%AE%BE%E7%BD%AEmac%E8%87%AA%E5%B8%A6%E7%9A%84vim%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<h4 id="最终效果图大概是这个样子"><a href="#最终效果图大概是这个样子" class="headerlink" title="最终效果图大概是这个样子"></a>最终效果图大概是这个样子</h4><p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/设置mac自带的vim语法高亮/15-2023-03-06-09-42-13.png" alt="15-2023-03-06-09-42-13"></p>
<a id="more"></a>
<h4 id="设置vimrc"><a href="#设置vimrc" class="headerlink" title="设置vimrc"></a>设置vimrc</h4><p>vimrc文件是vim的环境设置文件。</p>
<p>整体的vim的设置是在 <strong>/etc/vimrc</strong> 文件中。</p>
<p>不建议修改/etc/vimrc 文件，每个用户可以在用户根目录中设置vim，新建<strong>~/.vimrc</strong></p>
<blockquote>
<p>touch .vimrc</p>
</blockquote>
<h5 id="在-vimrc中添加以下内容"><a href="#在-vimrc中添加以下内容" class="headerlink" title="在.vimrc中添加以下内容"></a>在.vimrc中添加以下内容</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">"=========================================================================</span><br><span class="line">" DesCRiption: 适合自己使用的vimrc文件，for Mac/Linux/Windows, GUI/Console</span><br><span class="line">"</span><br><span class="line">" Last Change: 2017年09月11日  </span><br><span class="line">"</span><br><span class="line">" Version: 1.80</span><br><span class="line">"</span><br><span class="line">"=========================================================================</span><br><span class="line"></span><br><span class="line">set nocompatible " 关闭 vi 兼容模式</span><br><span class="line">syntax on " 自动语法高亮</span><br><span class="line">colorscheme molokai " 设定配色方案</span><br><span class="line">set number " 显示行号</span><br><span class="line">set cursorline " 突出显示当前行</span><br><span class="line">set ruler " 打开状态栏标尺</span><br><span class="line">set shiftwidth=4 " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</span><br><span class="line">set softtabstop=4 " 使得按退格键时可以一次删掉 4 个空格</span><br><span class="line">set tabstop=4 " 设定 tab 长度为 4</span><br><span class="line">set nobackup " 覆盖文件时不备份</span><br><span class="line">set autochdir " 自动切换当前目录为当前文件所在的目录</span><br><span class="line">filetype plugin indent on " 开启插件</span><br><span class="line">set backupcopy=yes " 设置备份时的行为为覆盖</span><br><span class="line">set ignorecase smartcase " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感</span><br><span class="line">set nowrapscan " 禁止在搜索到文件两端时重新搜索</span><br><span class="line">set incsearch " 输入搜索内容时就显示搜索结果</span><br><span class="line">set hlsearch " 搜索时高亮显示被找到的文本</span><br><span class="line">set noerrorbells " 关闭错误信息响铃</span><br><span class="line">set novisualbell " 关闭使用可视响铃代替呼叫</span><br><span class="line">set t_vb= " 置空错误铃声的终端代码</span><br><span class="line">" set showmatch " 插入括号时，短暂地跳转到匹配的对应括号</span><br><span class="line">" set matchtime=2 " 短暂跳转到匹配括号的时间</span><br><span class="line">set magic " 设置魔术</span><br><span class="line">set hidden " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存</span><br><span class="line">set guioptions-=T " 隐藏工具栏</span><br><span class="line">set guioptions-=m " 隐藏菜单栏</span><br><span class="line">set smartindent " 开启新行时使用智能自动缩进</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">" 不设定在插入状态无法用退格键和 Delete 键删除回车符</span><br><span class="line">set cmdheight=1 " 设定命令行的行数为 1</span><br><span class="line">set laststatus=2 " 显示状态栏 (默认值为 1, 无法显示状态栏)</span><br><span class="line">set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span><br><span class="line">" 设置在状态行显示的信息</span><br><span class="line">set foldenable " 开始折叠</span><br><span class="line">set foldmethod=syntax " 设置语法折叠</span><br><span class="line">set foldcolumn=0 " 设置折叠区域的宽度</span><br><span class="line">setlocal foldlevel=1 " 设置折叠层数为</span><br><span class="line">" set foldclose=all " 设置为自动关闭折叠</span><br><span class="line">" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;</span><br><span class="line">" 用空格键来开关折叠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" return OS type, eg: windows, or linux, mac, et.st..</span><br><span class="line">function! MySys()</span><br><span class="line">if has("win16") || has("win32") || has("win64") || has("win95")</span><br><span class="line">return "windows"</span><br><span class="line">elseif has("unix")</span><br><span class="line">return "linux"</span><br><span class="line">endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">" 用户目录变量$VIMFILES</span><br><span class="line">if MySys() == "windows"</span><br><span class="line">let $VIMFILES = $VIM.'/vimfiles'</span><br><span class="line">elseif MySys() == "linux"</span><br><span class="line">let $VIMFILES = $HOME.'/.vim'</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" 设定doc文档目录</span><br><span class="line">let helptags=$VIMFILES.'/doc'</span><br><span class="line"></span><br><span class="line">" 设置字体 以及中文支持</span><br><span class="line">if has("win32")</span><br><span class="line">set guifont=Inconsolata:h12:cANSI</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" 配置多语言环境</span><br><span class="line">if has("multi_byte")</span><br><span class="line">" UTF-8 编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set formatoptions+=mM</span><br><span class="line">set fencs=utf-8,gbk</span><br><span class="line"></span><br><span class="line">if v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'</span><br><span class="line">set ambiwidth=double</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">if has("win32")</span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line">language messages zh_CN.utf-8</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" Buffers操作快捷方式!</span><br><span class="line">nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;</span><br><span class="line">nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" Tab操作快捷方式!</span><br><span class="line">nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;</span><br><span class="line">nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">"关于tab的快捷键</span><br><span class="line">" map tn :tabnext&lt;cr&gt;</span><br><span class="line">" map tp :tabprevious&lt;cr&gt;</span><br><span class="line">" map td :tabnew .&lt;cr&gt;</span><br><span class="line">" map te :tabedit</span><br><span class="line">" map tc :tabclose&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动</span><br><span class="line">"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的</span><br><span class="line">"时候会变得非常方便.</span><br><span class="line">nnoremap &lt;C-h&gt; &lt;C-w&gt;h</span><br><span class="line">nnoremap &lt;C-j&gt; &lt;C-w&gt;j</span><br><span class="line">nnoremap &lt;C-k&gt; &lt;C-w&gt;k</span><br><span class="line">nnoremap &lt;C-l&gt; &lt;C-w&gt;l</span><br><span class="line"></span><br><span class="line">"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）</span><br><span class="line">nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" set fileformats=unix,dos,mac</span><br><span class="line">" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;</span><br><span class="line">" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result</span><br><span class="line">" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 让 Tohtml 产生有 CSS 语法的 html</span><br><span class="line">" syntax/2html.vim，可以用:runtime! syntax/2html.vim</span><br><span class="line">let html_use_css=1</span><br><span class="line"></span><br><span class="line">" Python 文件的一般设置，比如不要 tab 等</span><br><span class="line">autocmd FileType python set tabstop=4 shiftwidth=4 expandtab</span><br><span class="line">autocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" 选中状态下 Ctrl+c 复制</span><br><span class="line">vmap &lt;C-c&gt; "+y</span><br><span class="line"></span><br><span class="line">" 打开javascript折叠</span><br><span class="line">let b:javascript_fold=1</span><br><span class="line">" 打开javascript对dom、html和css的支持</span><br><span class="line">let javascript_enable_domhtmlcss=1</span><br><span class="line">" 设置字典 ~/.vim/dict/文件的路径</span><br><span class="line">autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dict</span><br><span class="line">autocmd filetype css set dictionary=$VIMFILES/dict/css.dict</span><br><span class="line">autocmd filetype php set dictionary=$VIMFILES/dict/php.dict</span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - bufexplorer.vim Buffers切换</span><br><span class="line">" \be 全屏方式查看全部打开的文件列表</span><br><span class="line">" \bv 左右方式查看 \bs 上下方式查看</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - taglist.vim 查看函数列表，需要ctags程序</span><br><span class="line">" F4 打开隐藏taglist窗口</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">if MySys() == "windows" " 设定windows系统中ctags程序的位置</span><br><span class="line">let Tlist_Ctags_Cmd = '"'.$VIMRUNTIME.'/ctags.exe"'</span><br><span class="line">elseif MySys() == "linux" " 设定windows系统中ctags程序的位置</span><br><span class="line">let Tlist_Ctags_Cmd = '/usr/bin/ctags'</span><br><span class="line">endif</span><br><span class="line">nnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;</span><br><span class="line">let Tlist_Show_One_File = 1 " 不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1 " 如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_Use_Right_Window = 1 " 在右侧窗口中显示taglist窗口</span><br><span class="line">let Tlist_File_Fold_Auto_Close=1 " 自动折叠当前非编辑文件的方法列表</span><br><span class="line">let Tlist_Auto_Open = 0</span><br><span class="line">let Tlist_Auto_Update = 1</span><br><span class="line">let Tlist_Hightlight_Tag_On_BufEnter = 1</span><br><span class="line">let Tlist_Enable_Fold_Column = 0</span><br><span class="line">let Tlist_Process_File_Always = 1</span><br><span class="line">let Tlist_Display_Prototype = 0</span><br><span class="line">let Tlist_Compact_Format = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。</span><br><span class="line">" \m mark or unmark the word under (or before) the cursor</span><br><span class="line">" \r manually input a regular expression. 用于搜索.</span><br><span class="line">" \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .</span><br><span class="line">" \* 当前MarkWord的下一个 \# 当前MarkWord的上一个</span><br><span class="line">" \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录</span><br><span class="line">" :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree</span><br><span class="line">" o 打开关闭文件或者目录 t 在标签页中打开</span><br><span class="line">" T 在后台标签页中打开 ! 执行此文件</span><br><span class="line">" p 到上层目录 P 到根目录</span><br><span class="line">" K 到第一个节点 J 到最后一个节点</span><br><span class="line">" u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）</span><br><span class="line">" r 递归刷新当前目录 R 递归刷新当前根目录</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" F3 NERDTree 切换</span><br><span class="line">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NERD_commenter.vim 注释代码用的，</span><br><span class="line">" [count],cc 光标以下count行逐行添加注释(7,cc)</span><br><span class="line">" [count],cu 光标以下count行逐行取消注释(7,cu)</span><br><span class="line">" [count],cm 光标以下count行尝试添加块注释(7,cm)</span><br><span class="line">" ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。</span><br><span class="line">" 注：count参数可选，无则默认为选中行或当前行</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let NERDSpaceDelims=1 " 让注释符与语句之间留一个空格</span><br><span class="line">let NERDCompactSexyComs=1 " 多行注释时样子更好看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"</span><br><span class="line">let g:DoxygenToolkit_briefTag_funcName="yes"</span><br><span class="line">map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;df :Dox&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;db :DoxBlock&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;dc a &lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – ZenCoding.vim 很酷的插件，HTML代码生成</span><br><span class="line">" 插件最新版：http://github.com/mattn/zencoding-vim</span><br><span class="line">" 常用命令可看：http://nootn.com/blog/Tool/23/</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – checksyntax.vim JavaScript常见语法错误检查</span><br><span class="line">" 默认快捷方式为 F5</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:checksyntax_auto = 0 " 不自动检查</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NeoComplCache.vim 自动补全插件</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:AutoComplPop_NotEnableAtStartup = 1</span><br><span class="line">let g:NeoComplCache_EnableAtStartup = 1</span><br><span class="line">let g:NeoComplCache_SmartCase = 1</span><br><span class="line">let g:NeoComplCache_TagsAutoUpdate = 1</span><br><span class="line">let g:NeoComplCache_EnableInfo = 1</span><br><span class="line">let g:NeoComplCache_EnableCamelCaseCompletion = 1</span><br><span class="line">let g:NeoComplCache_MinSyntaxLength = 3</span><br><span class="line">let g:NeoComplCache_EnableSkipCompletion = 1</span><br><span class="line">let g:NeoComplCache_SkipInputTime = '0.5'</span><br><span class="line">let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'</span><br><span class="line">" &lt;TAB&gt; completion.</span><br><span class="line">inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"</span><br><span class="line">" snippets expand key</span><br><span class="line">imap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span><br><span class="line">smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span><br><span class="line">" % 正向匹配 g% 反向匹配</span><br><span class="line">" [% 定位块首 ]% 定位块尾</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span><br><span class="line">" SVN/git管理工具</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – a.vim</span><br><span class="line">"-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h5 id="设置颜色主题"><a href="#设置颜色主题" class="headerlink" title="设置颜色主题"></a>设置颜色主题</h5><p>进入对应目录准备颜色文件，没有就创建对应目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">daihui@daihuideMBP ~ cd .vim/colors</span><br><span class="line">daihui@daihuideMBP ~/.vim/colors pwd</span><br><span class="line">/Users/daihui/.vim/colors</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在~/.vim/colors目录下新建一个颜色文件</span></span><br><span class="line">daihui@daihuideMBP ~/.vim/colors touch molokai.vim</span><br></pre></td></tr></table></figure>
<p>molokai.vim 文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">" Vim color file</span><br><span class="line">"</span><br><span class="line">" Author: Tomas Restrepo &lt;tomas@winterdom.com&gt;</span><br><span class="line">"</span><br><span class="line">" Note: Based on the monokai theme for textmate</span><br><span class="line">" by Wimer Hazenberg and its darker variant</span><br><span class="line">" by Hamish Stuart Macpherson</span><br><span class="line">"</span><br><span class="line"></span><br><span class="line">hi clear</span><br><span class="line"></span><br><span class="line">set background=dark</span><br><span class="line">if version &gt; 580</span><br><span class="line">    " no guarantees for version 5.8 and below, but this makes it stop</span><br><span class="line">    " complaining</span><br><span class="line">    hi clear</span><br><span class="line">    if exists("syntax_on")</span><br><span class="line">        syntax reset</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line">let g:colors_name="molokai"</span><br><span class="line"></span><br><span class="line">if exists("g:molokai_original")</span><br><span class="line">    let s:molokai_original = g:molokai_original</span><br><span class="line">else</span><br><span class="line">    let s:molokai_original = 0</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hi Boolean         guifg=#AE81FF</span><br><span class="line">hi Character       guifg=#E6DB74</span><br><span class="line">hi Number          guifg=#AE81FF</span><br><span class="line">hi String          guifg=#E6DB74</span><br><span class="line">hi Conditional     guifg=#F92672               gui=bold</span><br><span class="line">hi Constant        guifg=#AE81FF               gui=bold</span><br><span class="line">hi Cursor          guifg=#000000 guibg=#F8F8F0</span><br><span class="line">hi Debug           guifg=#BCA3A3               gui=bold</span><br><span class="line">hi Define          guifg=#66D9EF</span><br><span class="line">hi Delimiter       guifg=#8F8F8F</span><br><span class="line">hi DiffAdd                       guibg=#13354A</span><br><span class="line">hi DiffChange      guifg=#89807D guibg=#4C4745</span><br><span class="line">hi DiffDelete      guifg=#960050 guibg=#1E0010</span><br><span class="line">hi DiffText                      guibg=#4C4745 gui=italic,bold</span><br><span class="line"></span><br><span class="line">hi Directory       guifg=#A6E22E               gui=bold</span><br><span class="line">hi Error           guifg=#960050 guibg=#1E0010</span><br><span class="line">hi ErrorMsg        guifg=#F92672 guibg=#232526 gui=bold</span><br><span class="line">hi Exception       guifg=#A6E22E               gui=bold</span><br><span class="line">hi Float           guifg=#AE81FF</span><br><span class="line">hi FoldColumn      guifg=#465457 guibg=#000000</span><br><span class="line">hi Folded          guifg=#465457 guibg=#000000</span><br><span class="line">hi Function        guifg=#A6E22E</span><br><span class="line">hi Identifier      guifg=#FD971F</span><br><span class="line">hi Ignore          guifg=#808080 guibg=bg</span><br><span class="line">hi IncSearch       guifg=#C4BE89 guibg=#000000</span><br><span class="line"></span><br><span class="line">hi Keyword         guifg=#F92672               gui=bold</span><br><span class="line">hi Label           guifg=#E6DB74               gui=none</span><br><span class="line">hi Macro           guifg=#C4BE89               gui=italic</span><br><span class="line">hi SpecialKey      guifg=#66D9EF               gui=italic</span><br><span class="line"></span><br><span class="line">hi MatchParen      guifg=#000000 guibg=#FD971F gui=bold</span><br><span class="line">hi ModeMsg         guifg=#E6DB74</span><br><span class="line">hi MoreMsg         guifg=#E6DB74</span><br><span class="line">hi Operator        guifg=#F92672</span><br><span class="line"></span><br><span class="line">" complete menu</span><br><span class="line">hi Pmenu           guifg=#66D9EF guibg=#000000</span><br><span class="line">hi PmenuSel                      guibg=#808080</span><br><span class="line">hi PmenuSbar                     guibg=#080808</span><br><span class="line">hi PmenuThumb      guifg=#66D9EF</span><br><span class="line"></span><br><span class="line">hi PreCondit       guifg=#A6E22E               gui=bold</span><br><span class="line">hi PreProc         guifg=#A6E22E</span><br><span class="line">hi Question        guifg=#66D9EF</span><br><span class="line">hi Repeat          guifg=#F92672               gui=bold</span><br><span class="line">hi Search          guifg=#FFFFFF guibg=#455354</span><br><span class="line">" marks column</span><br><span class="line">hi SignColumn      guifg=#A6E22E guibg=#232526</span><br><span class="line">hi SpecialChar     guifg=#F92672               gui=bold</span><br><span class="line">hi SpecialComment  guifg=#465457               gui=bold</span><br><span class="line">hi Special         guifg=#66D9EF guibg=bg      gui=italic</span><br><span class="line">hi SpecialKey      guifg=#888A85               gui=italic</span><br><span class="line">if has("spell")</span><br><span class="line">    hi SpellBad    guisp=#FF0000 gui=undercurl</span><br><span class="line">    hi SpellCap    guisp=#7070F0 gui=undercurl</span><br><span class="line">    hi SpellLocal  guisp=#70F0F0 gui=undercurl</span><br><span class="line">    hi SpellRare   guisp=#FFFFFF gui=undercurl</span><br><span class="line">endif</span><br><span class="line">hi Statement       guifg=#F92672               gui=bold</span><br><span class="line">hi StatusLine      guifg=#455354 guibg=fg</span><br><span class="line">hi StatusLineNC    guifg=#808080 guibg=#080808</span><br><span class="line">hi StorageClass    guifg=#FD971F               gui=italic</span><br><span class="line">hi Structure       guifg=#66D9EF</span><br><span class="line">hi Tag             guifg=#F92672               gui=italic</span><br><span class="line">hi Title           guifg=#ef5939</span><br><span class="line">hi Todo            guifg=#FFFFFF guibg=bg      gui=bold</span><br><span class="line"></span><br><span class="line">hi Typedef         guifg=#66D9EF</span><br><span class="line">hi Type            guifg=#66D9EF               gui=none</span><br><span class="line">hi Underlined      guifg=#808080               gui=underline</span><br><span class="line"></span><br><span class="line">hi VertSplit       guifg=#808080 guibg=#080808 gui=bold</span><br><span class="line">hi VisualNOS                     guibg=#403D3D</span><br><span class="line">hi Visual                        guibg=#403D3D</span><br><span class="line">hi WarningMsg      guifg=#FFFFFF guibg=#333333 gui=bold</span><br><span class="line">hi WildMenu        guifg=#66D9EF guibg=#000000</span><br><span class="line"></span><br><span class="line">if s:molokai_original == 1</span><br><span class="line">   hi Normal          guifg=#F8F8F2 guibg=#272822</span><br><span class="line">   hi Comment         guifg=#75715E</span><br><span class="line">   hi CursorLine                    guibg=#3E3D32</span><br><span class="line">   hi CursorColumn                  guibg=#3E3D32</span><br><span class="line">   hi LineNr          guifg=#BCBCBC guibg=#3B3A32</span><br><span class="line">   hi NonText         guifg=#BCBCBC guibg=#3B3A32</span><br><span class="line">else</span><br><span class="line">   hi Normal          guifg=#F8F8F2 guibg=#1B1D1E</span><br><span class="line">   hi Comment         guifg=#465457</span><br><span class="line">   hi CursorLine                    guibg=#293739</span><br><span class="line">   hi CursorColumn                  guibg=#293739</span><br><span class="line">   hi LineNr          guifg=#BCBCBC guibg=#232526</span><br><span class="line">   hi NonText         guifg=#BCBCBC guibg=#232526</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">"</span><br><span class="line">" Support for 256-color terminal</span><br><span class="line">"</span><br><span class="line">if &amp;t_Co &gt; 255</span><br><span class="line">   hi Boolean         ctermfg=135</span><br><span class="line">   hi Character       ctermfg=144</span><br><span class="line">   hi Number          ctermfg=135</span><br><span class="line">   hi String          ctermfg=144</span><br><span class="line">   hi Conditional     ctermfg=161               cterm=bold</span><br><span class="line">   hi Constant        ctermfg=135               cterm=bold</span><br><span class="line">   hi Cursor          ctermfg=16  ctermbg=253</span><br><span class="line">   hi Debug           ctermfg=225               cterm=bold</span><br><span class="line">   hi Define          ctermfg=81</span><br><span class="line">   hi Delimiter       ctermfg=241</span><br><span class="line"></span><br><span class="line">   hi DiffAdd                     ctermbg=24</span><br><span class="line">   hi DiffChange      ctermfg=181 ctermbg=239</span><br><span class="line">   hi DiffDelete      ctermfg=162 ctermbg=53</span><br><span class="line">   hi DiffText                    ctermbg=102 cterm=bold</span><br><span class="line"></span><br><span class="line">   hi Directory       ctermfg=118               cterm=bold</span><br><span class="line">   hi Error           ctermfg=219 ctermbg=89</span><br><span class="line">   hi ErrorMsg        ctermfg=199 ctermbg=16    cterm=bold</span><br><span class="line">   hi Exception       ctermfg=118               cterm=bold</span><br><span class="line">   hi Float           ctermfg=135</span><br><span class="line">   hi FoldColumn      ctermfg=67  ctermbg=16</span><br><span class="line">   hi Folded          ctermfg=67  ctermbg=16</span><br><span class="line">   hi Function        ctermfg=118</span><br><span class="line">   hi Identifier      ctermfg=208</span><br><span class="line">   hi Ignore          ctermfg=244 ctermbg=232</span><br><span class="line">   hi IncSearch       ctermfg=193 ctermbg=16</span><br><span class="line"></span><br><span class="line">   hi Keyword         ctermfg=161               cterm=bold</span><br><span class="line">   hi Label           ctermfg=229               cterm=none</span><br><span class="line">   hi Macro           ctermfg=193</span><br><span class="line">   hi SpecialKey      ctermfg=81</span><br><span class="line"></span><br><span class="line">   hi MatchParen      ctermfg=16  ctermbg=208 cterm=bold</span><br><span class="line">   hi ModeMsg         ctermfg=229</span><br><span class="line">   hi MoreMsg         ctermfg=229</span><br><span class="line">   hi Operator        ctermfg=161</span><br><span class="line"></span><br><span class="line">   " complete menu</span><br><span class="line">   hi Pmenu           ctermfg=81  ctermbg=16</span><br><span class="line">   hi PmenuSel                    ctermbg=244</span><br><span class="line">   hi PmenuSbar                   ctermbg=232</span><br><span class="line">   hi PmenuThumb      ctermfg=81</span><br><span class="line"></span><br><span class="line">   hi PreCondit       ctermfg=118               cterm=bold</span><br><span class="line">   hi PreProc         ctermfg=118</span><br><span class="line">   hi Question        ctermfg=81</span><br><span class="line">   hi Repeat          ctermfg=161               cterm=bold</span><br><span class="line">   hi Search          ctermfg=253 ctermbg=66</span><br><span class="line"></span><br><span class="line">   " marks column</span><br><span class="line">   hi SignColumn      ctermfg=118 ctermbg=235</span><br><span class="line">   hi SpecialChar     ctermfg=161               cterm=bold</span><br><span class="line">   hi SpecialComment  ctermfg=245               cterm=bold</span><br><span class="line">   hi Special         ctermfg=81  ctermbg=232</span><br><span class="line">   hi SpecialKey      ctermfg=245</span><br><span class="line"></span><br><span class="line">   hi Statement       ctermfg=161               cterm=bold</span><br><span class="line">   hi StatusLine      ctermfg=238 ctermbg=253</span><br><span class="line">   hi StatusLineNC    ctermfg=244 ctermbg=232</span><br><span class="line">   hi StorageClass    ctermfg=208</span><br><span class="line">   hi Structure       ctermfg=81</span><br><span class="line">   hi Tag             ctermfg=161</span><br><span class="line">   hi Title           ctermfg=166</span><br><span class="line">   hi Todo            ctermfg=231 ctermbg=232   cterm=bold</span><br><span class="line"></span><br><span class="line">   hi Typedef         ctermfg=81</span><br><span class="line">   hi Type            ctermfg=81                cterm=none</span><br><span class="line">   hi Underlined      ctermfg=244               cterm=underline</span><br><span class="line"></span><br><span class="line">   hi VertSplit       ctermfg=244 ctermbg=232   cterm=bold</span><br><span class="line">   hi VisualNOS                   ctermbg=238</span><br><span class="line">   hi Visual                      ctermbg=235</span><br><span class="line">   hi WarningMsg      ctermfg=231 ctermbg=238   cterm=bold</span><br><span class="line">   hi WildMenu        ctermfg=81  ctermbg=16</span><br><span class="line"></span><br><span class="line">   hi Normal          ctermfg=252 ctermbg=233</span><br><span class="line">   hi Comment         ctermfg=59</span><br><span class="line">   hi CursorLine                  ctermbg=234   cterm=none</span><br><span class="line">   hi CursorColumn                ctermbg=234</span><br><span class="line">   hi LineNr          ctermfg=250 ctermbg=234</span><br><span class="line">   hi NonText         ctermfg=250 ctermbg=234</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="重启vim再进来看看"><a href="#重启vim再进来看看" class="headerlink" title="重启vim再进来看看"></a>重启vim再进来看看</h5><p><a href="https://blog.csdn.net/ccorg/article/details/77940023" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker命令大全整理</title>
    <url>/2019/04/24/Docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Docker命令大全整理/1-2023-03-06-10-00-30.jpg" alt="1-2023-03-06-10-00-30"></p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong><a href="#rqsmzqgl">容器生命周期管理</a></strong></p>
<ul>
<li><a href="#run">run</a></li>
<li><a href="#ssr">start/stop/restart</a></li>
<li><a href="#kill">kill</a>∏</li>
<li><a href="#rm">rm</a></li>
<li><a href="#pu">pause/unpause</a></li>
<li><a href="#create">create</a></li>
<li><a href="#exec">exec</a></li>
</ul>
<p><strong><a href="#rqcz">容器操作</a></strong></p>
<ul>
<li><a href="#ps">ps</a></li>
<li><a href="#inspect">inspect</a></li>
<li><a href="#top">top</a></li>
<li><a href="#attach">attach</a></li>
<li><a href="#events">events</a></li>
<li><a href="#logs">logs</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#export">export</a></li>
<li><a href="#port">port</a></li>
</ul>
<p><strong><a href="#rqrootfsml">容器rootfs命令</a></strong></p>
<ul>
<li><a href="#commit">commit</a></li>
<li><a href="#cp">cp</a></li>
<li><a href="#diff">diff</a></li>
</ul>
<p><strong><a href="#jxck">镜像仓库</a></strong></p>
<ul>
<li><a href="#login">login</a></li>
<li><a href="#pull">pull</a></li>
<li><a href="#push">push</a></li>
<li><a href="#search">search</a></li>
</ul>
<p><strong><a href="#bdjxgl">本地镜像管理</a></strong></p>
<ul>
<li><a href="#images">images</a></li>
<li><a href="#rmi">rmi</a></li>
<li><a href="#tag">tag</a></li>
<li><a href="#build">build</a></li>
<li><a href="#history">history</a></li>
<li><a href="#save">save</a></li>
<li><a href="#import">import</a></li>
</ul>
<p><strong><a href="#infoversion">info|version</a></strong></p>
<ul>
<li><a href="#info">info</a></li>
<li><a href="#version">version</a></li>
</ul>
<hr>
<h2 id="rqsmzqgl">容器生命周期管理</h2>

<h3 id="run">Docker run 命令</h3>

<p><strong>docker run :</strong> 创建一个新的容器并运行一个命令</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p>
</li>
<li><p>-d: 后台运行容器，并返回容器ID；</p>
</li>
<li><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p>
</li>
<li><p>-p: 端口映射，格式为：主机(宿主)端口:容器端口 </p>
</li>
<li><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
</li>
<li><p>–name=”nginx-lb”: 为容器指定一个名称；</p>
</li>
<li><p>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</p>
</li>
<li><p>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</p>
</li>
<li><p>-h “mars”: 指定容器的hostname；</p>
</li>
<li><p>-e username=”ritchie”: 设置环境变量；</p>
</li>
<li><p>–env-file=[]: 从指定文件读入环境变量；</p>
</li>
<li><p>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</p>
</li>
<li><p>-m :设置容器使用内存最大值；</p>
</li>
<li><p>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p>
</li>
<li><p>–link=[]: 添加链接到另一个容器；</p>
</li>
<li><p>–expose=[]: 开放一个端口或一组端口；</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/#</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ssr">Docker start/stop/restart 命令</h3>

<p><strong>docker start :</strong> 启动一个或多个已经被停止的容器</p>
<p><strong>docker stop :</strong> 停止一个运行中的容器</p>
<p><strong>docker restart :</strong> 重启容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker start [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<blockquote>
<p>docker stop [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<blockquote>
<p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>启动已被停止的容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start myrunoob</span><br></pre></td></tr></table></figure>
<p>停止运行中的容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop myrunoob</span><br></pre></td></tr></table></figure>
<p>重启容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="kill">Docker kill 命令</h3>

<p><strong>docker kill</strong> :杀掉一个运行中的容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-s :向容器发送一个信号</li>
</ul>
<p><strong>实例</strong></p>
<p>杀掉运行中的容器nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daihui@daihuideMBP:~$ docker kill -s KILL nginx</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="rm">Docker rm 命令</h3>

<p><strong>docker rm ：</strong> 删除一个或多少容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-f :通过SIGKILL信号强制删除一个运行中的容器</p>
</li>
<li><p>-l :移除容器间的网络连接，而非容器本身</p>
</li>
<li><p>-v :-v 删除与容器关联的卷</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>强制删除容器db01、db02</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure>
<p>移除容器nginx01对容器db01的连接，连接名db</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure>
<p>删除容器nginx01,并删除容器挂载的数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pu">Docker pause/unpause 命令</h3>

<p><strong>docker pause :</strong> 暂停容器中所有的进程</p>
<p><strong>docker unpause :</strong> 恢复容器中所有的进程</p>
<p><strong>语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>暂停数据库容器db01提供服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pause db01</span><br></pre></td></tr></table></figure>
<p>恢复数据库容器db01提供服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="create">Docker create 命令</h3>

<p><strong>docker create ：</strong> 创建一个新的容器但不启动它</p>
<p>用法同 <a href="#run">docker run</a></p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker create [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
</blockquote>
<p>语法同 <a href="#run">docker run</a></p>
<p><strong>实例</strong></p>
<p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      </span><br><span class="line">09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961e</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="exec">Docker exec 命令</h3>

<p><strong>docker exec ：</strong> 在运行的容器中执行命令</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-d :分离模式: 在后台运行</p>
</li>
<li><p>-i :即使没有附加也保持STDIN 打开</p>
</li>
<li><p>-t :分配一个伪终端</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">http://www.runoob.com/</span><br></pre></td></tr></table></figure>
<p>在容器 mynginx 中开启一个交互模式的终端:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash</span><br><span class="line">root@b1a0703e41e7:/#</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>docker ps -a</code> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p>
<p>查看已经在运行的容器 ID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps -a </span></span><br><span class="line">...</span><br><span class="line">9df70f9a0714     openjdk        "/usercode/script.sh…" </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第一列的 9df70f9a0714 就是容器 ID</p>
<p>通过 exec 命令对指定的容器执行 bash:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it 9df70f9a0714 /bin/bash</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rqcz">容器操作</h2>

<h3 id="ps">Docker ps 命令</h3>

<p><strong>docker ps :</strong> 列出容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker ps [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<p><strong>实例</strong></p>
<p>列出所有在运行的容器信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   "nginx -g 'daemon off" ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line">96f7f14e99ab   mysql:5.6      "docker-entrypoint.sh" ...  0.0.0.0:3306-&amp;gt;3306/tcp   mymysql</span><br></pre></td></tr></table></figure>
<p>列出最近创建的5个容器信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        "nginx -g 'daemon off"    2 days ago   ...     </span><br><span class="line">b8573233d675        nginx:latest        "/bin/bash"               2 days ago   ...     </span><br><span class="line">b1a0703e41e7        nginx:latest        "nginx -g 'daemon off"    2 days ago   ...    </span><br><span class="line">f46fb1dec520        5c6e1090e771        "/bin/sh -c 'set -x \t"   2 days ago   ...   </span><br><span class="line">a63b4a5597de        860c279d2fec        "bash"                    2 days ago   ...</span><br></pre></td></tr></table></figure>
<p>列出所有创建的容器ID。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -a -q</span><br><span class="line">09b93464c2f7</span><br><span class="line">b8573233d675</span><br><span class="line">b1a0703e41e7</span><br><span class="line">f46fb1dec520</span><br><span class="line">a63b4a5597de</span><br><span class="line">6a4aa42e947b</span><br><span class="line">de7bb36e7968</span><br><span class="line">43a432b73776</span><br><span class="line">664a8ab1a585</span><br><span class="line">ba52eb632bbd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="inspect">Docker inspect 命令</h3>


<p><strong>docker inspect :</strong> 获取容器/镜像的元数据</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker inspect [OPTIONS] NAME|ID [NAME|ID…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件</li>
<li>-s :显示总的文件大小</li>
<li>–type :为指定类型返回JSON</li>
</ul>
<p><strong>实例</strong></p>
<p>获取镜像mysql:5.6的元信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec",</span><br><span class="line">        "RepoTags": [</span><br><span class="line">            "mysql:5.6"</span><br><span class="line">        ],</span><br><span class="line">        "RepoDigests": [],</span><br><span class="line">        "Parent": "",</span><br><span class="line">        "Comment": "",</span><br><span class="line">        "Created": "2016-05-24T04:01:41.168371815Z",</span><br><span class="line">        "Container": "e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54",</span><br><span class="line">        "ContainerConfig": &#123;</span><br><span class="line">            "Hostname": "b0cf605c7757",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "ExposedPorts": &#123;</span><br><span class="line">                "3306/tcp": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>获取正在运行的容器mymysql的 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="top">Docker top 命令</h3>

<p><strong>docker top :</strong> 查看容器中运行的进程信息，支持 ps 命令参数</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker top [OPTIONS] CONTAINER [ps OPTIONS]</p>
</blockquote>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p>
<p><strong>实例</strong></p>
<p>查看容器mymysql的进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker top mymysql</span><br><span class="line">UID    PID    PPID    C      STIME   TTY  TIME       CMD</span><br><span class="line">999    40347  40331   18     00:58   ?    00:00:02   mysqld</span><br></pre></td></tr></table></figure>
<p>查看所有运行容器的进程信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in  `docker ps |grep Up|awk '&#123;print $1&#125;'`;do echo \ &amp;amp;&amp;amp;docker top $i; done</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="attach">Docker attach 命令</h3>

<p><strong>docker attach :</strong> 连接到正在运行中的容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker attach [OPTIONS] CONTAINER</p>
</blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p>
<p><strong>实例</strong></p>
<p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker attach --sig-proxy=false mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="events">Docker events 命令</h3>

<p>docker events : 从服务器获取实时事件</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker events [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件；</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p><strong>实例</strong></p>
<p>显示docker 2016年7月1日后的所有事件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker events  --since="1467302400"</span><br><span class="line">2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)</span><br><span class="line">2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)</span><br><span class="line">2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)</span><br><span class="line">2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker events -f "image"="mysql:5.6" --since="1467302400" </span><br><span class="line">2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)</span><br><span class="line">2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br></pre></td></tr></table></figure>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2017-07-01”</p>
<hr>
<h3 id="logs">Docker logs 命令</h3>

<p><strong>docker logs :</strong> 获取容器的日志</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker logs [OPTIONS] CONTAINER</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<p><strong>实例</strong></p>
<p>跟踪查看容器mynginx的日志输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">2016/07/10 16:53:33 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET /favicon.ico HTTP/1.1" 404 571 "http://192.168.239.130/" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看容器mynginx从2016年7月1日后的最新10条日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs --since="2016-07-01" --tail=10 mynginx</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="wait">Docker wait 命令</h3>


<p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker wait [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="export">Docker export 命令</h3>

<p><strong>docker export :</strong> 将文件系统作为一个tar归档文件导出到STDOUT</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker export [OPTIONS] CONTAINER</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-o :将输入内容写到文件。</li>
</ul>
<p><strong>实例</strong></p>
<p>将id为a404c6c174a2的容器按日期保存为tar文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="port">Docker port 命令</h3>

<p><strong>docker port :</strong> 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看容器mynginx的端口映射情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rqrootfsml">容器rootfs命令</h2>

<h3 id="commit">Docker commit 命令</h3>

<p><strong>docker commit :</strong> 从容器创建一个新的镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a :提交的镜像作者；</p>
</li>
<li><p>-c :使用Dockerfile指令来创建镜像；</p>
</li>
<li><p>-m :提交时的说明文字；</p>
</li>
<li><p>-p :在commit时，将容器暂停</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cp">Docker cp 命令</h3>

<p><strong>docker cp :</strong> 用于容器与主机之间的数据拷贝</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</p>
</blockquote>
<blockquote>
<p>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-L :保持源目标中的链接</li>
</ul>
<p><strong>实例</strong></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br></pre></td></tr></table></figure>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="diff">Docker diff 命令</h3>

<p><strong>docker diff :</strong> 检查容器里文件结构的更改</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker diff [OPTIONS] CONTAINER</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看容器mymysql的文件结构更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="jxck">镜像仓库</h2>

<h3 id="login">Docker login 命令</h3>

<p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>
<p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker login [OPTIONS] [SERVER]</p>
</blockquote>
<blockquote>
<p>docker logout [OPTIONS] [SERVER]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-u :登陆的用户名</p>
</li>
<li><p>-p :登陆的密码</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>登陆到Docker Hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码</span><br></pre></td></tr></table></figure>
<p>登出Docker Hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pull">Docker pull 命令</h3>

<p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a :拉取所有 tagged 镜像</p>
</li>
<li><p>–disable-content-trust :忽略镜像的校验,默认开启</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>从Docker Hub下载java最新版镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure>
<p>从Docker Hub下载REPOSITORY为java的所有镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="push">Docker push 命令</h3>

<p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker push [OPTIONS] NAME[:TAG]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p><strong>实例</strong></p>
<p>上传本地镜像myapache:v1到镜像仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="search">Docker search 命令</h3>

<p><strong>docker search :</strong> 从Docker Hub查找镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker search [OPTIONS] TERM</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>–automated :只列出 automated build类型的镜像；</p>
</li>
<li><p>–no-trunc :显示完整的镜像描述；</p>
</li>
<li><p>-s :列出收藏数不小于指定值的镜像。</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker search -s 10 java</span><br><span class="line">NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED</span><br><span class="line">java                  Java is a concurrent, class-based...   1037    [OK]       </span><br><span class="line">anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]</span><br><span class="line">develar/java                                                 46                 [OK]</span><br><span class="line">isuper/java-oracle    This repository contains all java...   38                 [OK]</span><br><span class="line">lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]</span><br><span class="line">nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="bdjxgl">本地镜像管理</h2>

<h3 id="images">Docker images 命令</h3>

<p><strong>docker images :</strong> 列出本地镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker images [OPTIONS] [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>–digests :显示镜像的摘要信息；</li>
<li>-f :显示满足条件的镜像；</li>
<li>–format :指定返回值的模板文件；</li>
<li>–no-trunc :显示完整的镜像信息；</li>
<li>-q :只显示镜像ID。</li>
</ul>
<p><strong>实例</strong></p>
<p>查看本地镜像列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql                 v1                  37af1236adef        5 minutes ago       329 MB</span><br><span class="line">runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB</span><br><span class="line">&amp;lt;none&amp;gt;                  &amp;lt;none&amp;gt;              5c6e1090e771        2 days ago          165.9 MB</span><br><span class="line">httpd                   latest              ed38aaffef30        11 days ago         195.1 MB</span><br><span class="line">alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB</span><br><span class="line">mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB</span><br><span class="line">redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB</span><br><span class="line">php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB</span><br><span class="line">python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>列出本地镜像中REPOSITORY为ubuntu的镜像列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="rmi">Docker rmi 命令</h3>

<p><strong>docker rmi :</strong> 删除本地一个或多少镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker rmi [OPTIONS] IMAGE [IMAGE…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-f :强制删除；</p>
</li>
<li><p>–no-prune :不移除该镜像的过程镜像，默认移除；</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>强制删除本地镜像runoob/ubuntu:v4。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tag">Docker tag 命令</h3>

<p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="build">Docker build 命令</h3>

<p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker build [OPTIONS] PATH | URL | -</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
<li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>
<li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p><strong>实例</strong></p>
<p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure>
<p>也可以通过 -f Dockerfile 文件的位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -f /path/to/a/Dockerfile .</span></span><br></pre></td></tr></table></figure>
<p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker build -t <span class="built_in">test</span>/myapp .</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="history">Docker history 命令</h3>

<p><strong>docker history :</strong> 查看指定镜像的创建历史</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker history [OPTIONS] IMAGE</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-H :以可读的格式打印镜像大小和日期，默认为true；</li>
<li>–no-trunc :显示完整的提交记录；</li>
<li>-q :仅列出提交记录ID。</li>
</ul>
<p><strong>实例</strong></p>
<p>查看本地镜像runoob/ubuntu:v3的创建历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B                 </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c set -xe   &amp;amp;&amp;amp; echo '#!/bin/sh' &amp;gt; /u   701 B               </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="save">Docker save 命令</h3>

<p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker save [OPTIONS] IMAGE [IMAGE…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-o :输出到的文件</li>
</ul>
<p><strong>实例</strong></p>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="import">Docker import 命令</h3>

<p><strong>docker import :</strong> 从归档文件中创建镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-c :应用docker 指令创建镜像；</li>
<li>-m :提交时的说明文字；</li>
</ul>
<p><strong>实例</strong></p>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="infoversion">info|version</h2>

<h3 id="info">Docker info 命令</h3>

<p><strong>docker info :</strong> 显示 Docker 系统信息，包括镜像和容器数</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker info [OPTIONS]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看docker系统信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker info</span></span><br><span class="line">Containers: 12</span><br><span class="line">Images: 41</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 66</span><br><span class="line"> Dirperm1 Supported: false</span><br><span class="line">Execution Driver: native-0.2</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Kernel Version: 3.13.0-32-generic</span><br><span class="line">Operating System: Ubuntu 14.04.1 LTS</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 1.954 GiB</span><br><span class="line">Name: iZ23mtq8bs1Z</span><br><span class="line">ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="version">Docker version 命令</h3>

<p><strong>docker version :</strong> 显示 Docker 版本信息</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker version [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件</li>
</ul>
<p><strong>实例</strong></p>
<p>显示 Docker 版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br><span class="line">Client:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的StreamsAPI详解</title>
    <url>/2018/09/30/Java8%E4%B8%AD%E7%9A%84StreamsAPI%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java-8-中的-Streams-API-详解"><a href="#Java-8-中的-Streams-API-详解" class="headerlink" title="Java 8 中的 Streams API 详解"></a>Java 8 中的 Streams API 详解</h1><h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data     operation)。</p>
<a id="more"></a>
<p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p>
<p>所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>
<h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：  </p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐  </li>
</ul>
<p>这类的操作。</p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API     中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为     grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p>
<p>清单 1. Java 7 的排序、取值实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Transaction&gt; groceryTransactions = <span class="keyword">new</span> Arraylist&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: transactions)&#123;</span><br><span class="line"> <span class="keyword">if</span>(t.getType() == Transaction.GROCERY)&#123;</span><br><span class="line"> groceryTransactions.add(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(groceryTransactions, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Transaction t1, Transaction t2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;Integer&gt; transactionIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: groceryTransactions)&#123;</span><br><span class="line"> transactionsIds.add(t.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p>
<p>清单 2. Java 8 的排序、取值实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class="line"> filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class="line"> sorted(comparing(Transaction::getValue).reversed()).</span><br><span class="line"> map(Transaction::getId).</span><br><span class="line"> collect(toList());</span><br></pre></td></tr></table></figure>
<h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的     Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10     的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个     item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join     框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<p>1 1.0-1.4 中的 java.lang.Thread</p>
<p>2 5.0 中的 java.util.concurrent</p>
<p>3 6.0 中的 Phasers 等</p>
<p>4 7.0 中的 Fork/Join 框架</p>
<p>5 8.0 中的 Lambda</p>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream     对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>
<p>图 1. 流管道 (Stream Pipeline) 的构成</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/Java8中的StreamsAPI详解/1-2023-03-06-10-49-12.png" alt="1-2023-03-06-10-49-12"></p>
<p>有多种方式生成 Stream Source：</p>
<ul>
<li>从 Collection 和数组<ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()</li>
</ul>
</li>
<li>从 BufferedReader<ul>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂<ul>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
</ul>
</li>
<li>自己构建<ul>
<li>java.util.Spliterator</li>
</ul>
</li>
<li>其它<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种：</p>
<ul>
<li><p><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate      操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
</li>
<li><p><strong>Terminal</strong>：一个流只能有一个 terminal      操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p>
<ul>
<li><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p>
</li>
<li><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p>
</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>
<p>清单 3. 一个流操作的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">.filter(w -&gt; w.getColor() == RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure>
<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal     操作，对符合条件的全部小物件作重量求和。</p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>
<h3 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h3><p>下面提供最常见的几种构造 Stream 的样例。</p>
<p>清单 4. 构造流的几种常见方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Individual values</span></span><br><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 2. Arrays</span></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">// 3. Collections</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure>
<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream&lt;Integer>、Stream&lt;Long>、Stream&lt;Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>
<p>清单 5. 数值流的构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>清单 6. 流转换为其它数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Array</span></span><br><span class="line">String[] strArray1 = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 2. Collection</span></span><br><span class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">Set set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 3. String</span></span><br><span class="line">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>
<ul>
<li>Intermediate：</li>
</ul>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、     sequential、 unordered</p>
<ul>
<li>Terminal：</li>
</ul>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、     allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
<ul>
<li>Short-circuiting：</li>
</ul>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
<p>我们下面看一下 Stream 的比较典型用法。</p>
<p><strong>map/flatMap</strong>  </p>
<p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>
<p>清单 7. 转换大写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = wordList.stream().</span><br><span class="line">map(String::toUpperCase).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码把所有的单词转换为大写。</p>
<p>清单 8. 平方数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class="line">map(n -&gt; n * n).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<p>清单 9. 一对多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>
<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>
<p><strong>filter</strong>  </p>
<p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<p>清单 10. 留下偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>
<p>清单 11. 把单词挑出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>
<p><strong>forEach</strong>  </p>
<p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>
<p>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class="line"><span class="comment">// Pre-Java 8</span></span><br><span class="line"><span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line"> <span class="keyword">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class="line"> System.out.println(p.getName());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda     表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>
<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>
<p>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>
<p><strong>findFirst</strong>  </p>
<p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免     NullPointerException。</p>
<p>清单 14. Optional 的两个用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strA = <span class="string">" abcd "</span>, strB = <span class="keyword">null</span>;</span><br><span class="line">print(strA);</span><br><span class="line">print(<span class="string">""</span>);</span><br><span class="line">print(strB);</span><br><span class="line">getLength(strA);</span><br><span class="line">getLength(<span class="string">""</span>);</span><br><span class="line">getLength(strB);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Java 8</span></span><br><span class="line"> Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line"> <span class="comment">// Pre-Java 8</span></span><br><span class="line"> <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line"> System.out.println(text);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// Pre-Java 8</span></span><br><span class="line"><span class="comment">// return if (text != null) ? text.length() : -1;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>
<p><strong>reduce</strong>  </p>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n     个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p>
<p>Integer sum = integers.reduce(0, Integer::sum);</p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<p>清单 15. reduce 的用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure>
<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce()     都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>
<p><strong>limit/skip</strong>  </p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<p>清单 16. limit 和 skip 对运行次数的影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimitAndSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;String&gt; personList2 = persons.stream().</span><br><span class="line">map(Person::getName).limit(<span class="number">10</span>).skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"> System.out.println(personList2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.no = no;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(name);</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name1</span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">name4</span><br><span class="line">name5</span><br><span class="line">name6</span><br><span class="line">name7</span><br><span class="line">name8</span><br><span class="line">name9</span><br><span class="line">name10</span><br><span class="line">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure>
<p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName()     方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate     操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>
<p>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; </span><br><span class="line">p1.getName().compareTo(p2.getName())).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>
<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">name3</span><br><span class="line">name2</span><br><span class="line">name4</span><br><span class="line">name3</span><br><span class="line">name5</span><br><span class="line">name4</span><br><span class="line">[stream.StreamDW$Person@<span class="number">816f</span>27d, stream.StreamDW$Person@<span class="number">87</span>aac27]</span><br></pre></td></tr></table></figure>
<p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>
<p><strong>sorted</strong></p>
<p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct     来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>
<p>清单 18. 优化：排序前进行 limit 和 skip</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().limit(<span class="number">2</span>).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>
<p>结果会简单很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">[stream.StreamDW$Person@<span class="number">6</span>ce253f1, stream.StreamDW$Person@<span class="number">53</span>d8d10a]</span><br></pre></td></tr></table></figure>
<p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>
<p><strong>min/max/distinct</strong></p>
<p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>
<p>清单 19. 找出最长一行的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\SUService.log"</span>));</span><br><span class="line"><span class="keyword">int</span> longest = br.lines().</span><br><span class="line"> mapToInt(String::length).</span><br><span class="line"> max().</span><br><span class="line"> getAsInt();</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(longest);</span><br></pre></td></tr></table></figure>
<p>下面的例子则使用 distinct 来找出不重复的单词。</p>
<p>清单 20. 找出全文的单词，转小写，并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = br.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(<span class="string">" "</span>))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> map(String::toLowerCase).</span><br><span class="line"> distinct().</span><br><span class="line"> sorted().</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>
<p><strong>Match</strong></p>
<p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p>
<p>清单 21. 使用 Match</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p>
<p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier     实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用     limit 之类的操作限制 Stream 大小。</p>
<p>清单 22. 生成 10 个随机整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random seed = <span class="keyword">new</span> Random();</span><br><span class="line">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class="line">Stream.generate(random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//Another way</span></span><br><span class="line">IntStream.generate(() -&gt; (<span class="keyword">int</span>) (System.nanoTime() % <span class="number">100</span>)).</span><br><span class="line">limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream     的每个元素值。这些都是维持状态信息的情形。</p>
<p>清单 23. 自实现 Supplier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line">limit(<span class="number">10</span>).</span><br><span class="line">forEach(p -&gt; System.out.println(p.getName() + <span class="string">", "</span> + p.getAge()));</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Person <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Person(index++, <span class="string">"StormTestUser"</span> + index, random.nextInt(<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StormTestUser1, <span class="number">9</span></span><br><span class="line">StormTestUser2, <span class="number">12</span></span><br><span class="line">StormTestUser3, <span class="number">88</span></span><br><span class="line">StormTestUser4, <span class="number">51</span></span><br><span class="line">StormTestUser5, <span class="number">22</span></span><br><span class="line">StormTestUser6, <span class="number">28</span></span><br><span class="line">StormTestUser7, <span class="number">81</span></span><br><span class="line">StormTestUser8, <span class="number">51</span></span><br><span class="line">StormTestUser9, <span class="number">4</span></span><br><span class="line">StormTestUser10, <span class="number">76</span></span><br></pre></td></tr></table></figure>
<p><strong>Stream.iterate</strong></p>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed)     为第二个，f(f(seed)) 第三个，以此类推。</p>
<p>清单 24. 生成一个等差数列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">3</span>).limit(<span class="number">10</span>). forEach(x -&gt; System.out.print(x + <span class="string">" "</span>));.</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">12</span> <span class="number">15</span> <span class="number">18</span> <span class="number">21</span> <span class="number">24</span> <span class="number">27</span></span><br></pre></td></tr></table></figure>
<p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>
<h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p>
<p>清单 25. 按照年龄归组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line"> limit(<span class="number">100</span>).</span><br><span class="line"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">Iterator it = personGroups.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class="line"> System.out.println(<span class="string">"Age "</span> + persons.getKey() + <span class="string">" = "</span> + persons.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Age <span class="number">0</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">5</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">8</span> = <span class="number">1</span></span><br><span class="line">Age <span class="number">9</span> = <span class="number">1</span></span><br><span class="line">Age <span class="number">11</span> = <span class="number">2</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>清单 26. 按照未成年人和成年人归组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line">limit(<span class="number">100</span>).</span><br><span class="line"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; <span class="number">18</span>));</span><br><span class="line">System.out.println(<span class="string">"Children number: "</span> + children.get(<span class="keyword">true</span>).size());</span><br><span class="line">System.out.println(<span class="string">"Adult number: "</span> + children.get(<span class="keyword">false</span>).size());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Children number: <span class="number">23</span> </span><br><span class="line">Adult number: <span class="number">77</span></span><br></pre></td></tr></table></figure>
<p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的     groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的</li>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream        进行运算并很快完成。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams API</tag>
      </tags>
  </entry>
  <entry>
    <title>学不会的华为 IPD，其实是这样！</title>
    <url>/2022/12/21/%E4%BD%A0%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%8D%8E%E4%B8%BA%20IPD%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E8%BF%99%E6%A0%B7%EF%BC%81/</url>
    <content><![CDATA[<p>美国著名作家弗格森说了一句话 “谁也无法说服他人改变，因为我们每个人都守着一扇只能从内心开启的改变之门，不论动之以情或晓之以理，我们都不能替别人开门”。</p>
<p>改变真的是由内而外的？不是！改变是由外而内，再由内而外的过程。只有当我们有信息输入，在新的信息下触发自身，只有触发自身的信息才能引发一场由内而外的改变。我们将用以下的文章内容来提供触发信息。</p>
<a id="more"></a>
<h4 id="一、让你的企业成为资产的思维"><a href="#一、让你的企业成为资产的思维" class="headerlink" title="一、让你的企业成为资产的思维"></a><strong>一、让你的企业成为资产的思维</strong></h4><p>企业经营的目标是要创造价值、利润，那么如何创造客户、并且持续不断的为客户创造价值、留住客户，是企业经营的法宝。产品无疑在企业与客户之间建立了一座桥梁。企业通过产品为客户创造价值。持续不断的高品质的产品输出，是一个企业持续立于不败之地的法宝。</p>
<p>然而，一个企业要成长，就要未雨绸缪、不断变革，以保持持续的生命力。华为公司就是一家保持持续变革的伟大公司，持续管理变革的目标就是实现高效的流程化运作，确保端到端的自动优质交付，从而实现企业的自动化管道系统。</p>
<p>今天我们向华为学习企业的变革之下的研发流程体系，其实是一个研发管道系统，在华为，这条管道叫做——IPD 体系。华为公司认为，研发不仅是研发部门的事，更是关系公司市场到产品变现的全流程。IPD 是企业实现产品商业化的管道系统，IPD 体系构建了产品从 idea 到产品变现的全流程。</p>
<p>经营企业需要具备系统性的全局思维，将企业看做资产的思维，企业是不断创造价值的资产，需要融入经营者的经营思维、战略思维、管理思维、并赋予工具、流程和方法，让其实现自动化运行的系统。当然不是所有企业都可以看成资产，只有创造价值，创造利润的企业才能称为资产。</p>
<p>作为经营者、管理者需要以经营资产的思维来经营企业。</p>
<h4 id="二、IPD-的起源和发展"><a href="#二、IPD-的起源和发展" class="headerlink" title="二、IPD 的起源和发展"></a><strong>二、IPD 的起源和发展</strong></h4><p><strong>1、跨界的 IBM 领导者为何要建 IPD</strong></p>
<p>IPD 起源于这家公司——IBM，一个世界级的巨无霸，全球最大的信息技术和业务解决方案公司，拥有 30 多万员工，业务遍及 160 多个国家和地区。2018 年《财富》世界 500 强排行榜发布，IBM 位列 92 位。</p>
<p>那么就是这样一家世界级的公司，在 1991～1993 年间累计面临巨大的财务困境，三年间累计亏损达 162 亿美元，几乎是每天亏损掉 1480 万美元。93 年的 4 月 1 日，54 岁，路易斯 · 郭士纳临危受命，担任 IBM 的执行总裁。</p>
<p>郭士纳的上任当时并不被人们看好，包含美国的媒体，人们不相信一个曾经以食品和烟草起家的公司老板，能够扭转 IBM 的困局。</p>
<p>郭士纳就任后，做了三件事：</p>
<p>第一件事：让 IBM 停止流血；郭士纳裁剪了 IBM 流血的部门和人员，半年内果断裁人 4.5 万。</p>
<p>第二件事：重振大型机业务，拓展服务业范围，并带领 IBM 重新向 PC 市场发动攻击。</p>
<p>第三件事：梳理公司流程体制，进行流程重构和再造工程。</p>
<p>这第三件事情是与新班子花了近一年时间，研究如何对 IBM 进行 “再造工程”。IBM 组织团队进行分析，经过分析后，他们发现公司三个方面上远远落后于业界最佳——研发费用、研发浪费和产品上市时间。</p>
<p>分析的结果：IBM 研发费用为销售收入的 12%，而业界最佳为 6%；　　研发损失费用为整个研发费用的 25%，而业界最佳仅为 3.3%；而在上市时间（指产品从概念产生到投放市场所需的时间）方面，36.5% 项目的上市时间是业界最佳的 1.25 倍，其余项目的上市时间多于业界最佳的 1.5-2 倍。</p>
<p>为了重新获得市场竞争优势，IBM 提出了两个 50% 的目标，一是，将产品上市时间减少 50%，二是，在不影响产品开发结果的情况下，将研发费用减少 50% 的目标。</p>
<p>为达成这个目标，IBM 公司应用了 PACE 的方法（Product And Cycle-time Excellence，产品及周期优化法）从流程重整和产品重整两个方面来达到缩短产品上市时间、提高产品利润的目标。</p>
<p>时隔三年，1995 年，IBM 营收突破了 700 亿美元大关，IBM 的大型机业务也复活了。利润 60 亿美元。不得不说，IBM 公司流程重构在提升自身竞争力上发挥了巨大的作用。</p>
<p>IBM 成为了全球率先应用 IPD 方法并取得成功实践的企业，这就是 IPD 的起源。</p>
<p>美国著名的 PTRM 公司总结实施 IPD 后带来的好处是：</p>
<p><img src="https://pic3.zhimg.com/v2-cbb22c372c41b100de7a85da06ff48f6_r.jpg" alt=""></p>
<p>IPD 是集成产品开发的英文单词首字母，经过 IBM 公司实践的一套先进的、成熟的研发管理思想、模式和方法。</p>
<p><strong>2、华为搭上 IPD 的快车</strong></p>
<p>1997 年西方圣诞节前一周，任总重点考察了 IBM。圣诞节前夕美国各大企业都已经放假了，但 IBM 包括 CEO 郭士纳在内的高层领导均照常上班，并真诚而系统地向任正非介绍了他们的管理内涵。</p>
<p>这次调研中整整一天时间，IBM 从产品预研到项目管理、从生产流程到项目寿命终结的投资评审做了详尽的介绍。为了强化任正非对 IPD 的认识，IBM 副总裁送给他一本哈佛大学出版的关于研发管理的著作，后来他发现朗讯、惠普等美国著名企业也都实施这样的研发模式。</p>
<p>这次考察更加坚定了任正非对华为实施变革的坚定决心，华为要像 IBM 一样强大，不仅自己要以郭士纳为榜样，而且华为必须虔诚地拜 IBM 为师，不惜一切代价将其管理精髓移植到华为身上。</p>
<p>1998 年 8 月初，华为与 IBM 中国区总裁周伟焜签订了金额 20 亿人民币的变革项目合作协议，当时 20 亿是华为当年全年的利润，可见任总的魄力非常人所能及也。</p>
<p>这个项目包含了 IPD（集成产品开发）、ISC（集成供应链）、IT 系统重整、财务四统一等 8 个管理变革项目。这成为是华为历史上最重要的转折点，这个项目将华为带进了高速赛道。</p>
<p>华为公司第一家引进和实施 IPD，也是受益最大的国内企业。从 98 年的 IPD1.0 到 2014 年的 IPD7.0, 华为不断升级优化。</p>
<p>华为公司 1998 年启动 IPD 项目，分为关注、发明、推广 3 个阶段。根据 1998 年的计划，用两年多的时间就可以实现全面推广。</p>
<p>华为在 2001 年华为颁布了《华为基本法》，基本法一个重要的方面是统一了公司变革的思想。</p>
<p>经过了四年的梳理建设，IPD 在 2002 年在全公司推广使用。华为公司走上了与世界领先企业并肩同行的管理道路。</p>
<h4 id="三、IPD-的核心思想"><a href="#三、IPD-的核心思想" class="headerlink" title="三、IPD 的核心思想"></a><strong>三、IPD 的核心思想</strong></h4><p><strong>1. 研发本质是研发是企业的一项投资</strong></p>
<p>首先，IPD 认为研发是一项投资；因为这是一项投资决策，所以，需要对它进行有效的投资组合分析，在开发过程中，设置检查点，通过阶段性评审来决定项目是继续、暂停、终止还是改变方向。</p>
<p><strong>IPD(Integrated product development 集成产品开发)，IPD 是一套先进的、成熟的研发管理思想、模式和方法。</strong></p>
<p><strong>2. 基于市场的研发才是有效投资</strong></p>
<p>IPD 强调，产品创新一定要是基于市场需求和竞争分析的创新，要准确地做正确的事情，要将正确定义产品概念、充分理解市场需求作为流程的第一步。</p>
<p>在 IT 圈有个现象，一天公司其中一个人有个创意，然后召集人员参与讨论，之后，就规划出一个产品创意来，然后互相鼓励，觉得我们这个创意就是最牛逼的，我们是世界第一，没有人想到，只有我们想到。并且互相叮嘱，我们要保密哦，要充分注重信息安全，不能透露给外人。这样的产品规划，我们通常叫做意向创业；貌似具有非常强的执行力，立即组建团队，就卷起袖子加油干！立项、设计、开发、出样机、投生产。节奏很快，也很有魄力。恨不得 3 个月就能出产品，然后做营销、做销售。经历了千辛万苦，产品出来后，面向市场发布，结果无人问津。</p>
<p>这里我们强调产品一定是基于市场需求的开发，一定要解决市场的问题和痛点，痒点都不行，必须是痛点。</p>
<p>所以说，这种方式就不满足 IPD 的核心思想。我们说市场的端到端，是需求来源于市场，最终产品回归于市场。你都没有做充分的市场调研，怎么能够被市场所接受。</p>
<p><strong>3. 如何穿越部门墙建立研发快车道</strong></p>
<p>一个产品，尤其是以硬件为主的产品，设计产品的方方面面、结构、硬件、软件、工程、制造、采购、包装、市场推广等，是需要全部门协同配合的一个事情。所以必须要有跨部门的团队协作。</p>
<p>采用跨部门的产品开发团队 (Product Development Team, 简称 PDT)，通过有效的沟通、协调以及决策，到达尽快将产品推向市场的目的。</p>
<p>有的创业者，把这个事情想得太简单，完全没有搞清楚状况，拖几个人就开始干，在他们的理念中，出产品就是出样机，觉得样机出来了，产品就出来了，殊不知一个产品样机出来，仅仅只等效于产品开发过程只完成 40%，还有大量的工作要做。</p>
<p>并且，在这种思想下，产品的是不完善的，是不具备量产化的，以样机为产品终结的思想，完全不会考虑到产品的后端需求。比如可测试性、可制造性、可服务性等 DFX 的需求。</p>
<p>跨部门的团队，强调无缝沟通，强调把专业的团队串起来，为了一个共同的目标而努力。</p>
<p>老罗有这么一句对自己的总结 “只有等到你掉到坑里的时候，你才刻骨铭心地意识到前辈们的忠告是如此的正确”。</p>
<p>创业初期，老罗一直认为，除了乔布斯，锤子拥有世界上一流的工业设计团队。于是呢，我们看到，老罗开始打造工艺品，追求完美的产品设计。在产品转生产试制的时候，多次亲自在富士康的生产线跟线。在追求产品完美外观和软件体验细节的上面，忽略了产品的可实现性。后来老罗在一次产品发布会上深刻总结了做产品不是做艺术品，需要充分考虑产品的可制造性。其实老罗在 2012 年摩托罗拉大裁员的时候吸收了一大批摩托罗拉的技术专家。如果当时，他充分利用各类部门技术专家的优势，锤子 T1 手机就不会遭遇 “噩梦一般的三个月”。</p>
<p><strong>4. 给新产品开发造一个发动机</strong></p>
<p>IPD 同样也关注平台，平台化的开发带来了两大好处，铁打的银盘流水的兵，即使关键岗位的人员流动也不会对企业带来影响，平台让我们的开发成果得到积累和沉淀；另一方面，平台化的开发，支撑了我们新产品开发的速度。</p>
<p><strong>5. 每个人都应该知道该干什么的方法</strong></p>
<p>结构化的流程，所谓结构化，是指相互关联的工作要有一个框架结构，并要有一定的组织原则来支持它；每项工作都应清清楚楚地明确规定出来。所有与产品开发有关的人应该清楚他们所参与的是什么工作，用什么方法去完成。</p>
<p>同时，有了结构化的流程，我们就不在受关键岗位、关键人才的限制。</p>
<p>几年前，我就职过的一家公司，一个项目经理总览了一个产品系列的所有软硬件的全套技术和技术文件，以此为由，要求公司 CEO 给他加薪，CEO 最后不得不接受。当然，我们不希望这样的事情发生，同时我们也期望给公司员工带来更多的福利。可是这种情况在公司发展，对公司的发展，对员工的发展都是非常不利的。</p>
<p><strong>6. 海陆空模式远比顺序模式强大</strong></p>
<p><strong>异步开发模式</strong>，也称并行工程。通过严谨的计划、系统的设计、严格的流程控制，节点评审，把原来的许多后续活动提前进行，缩短产品上市时间。</p>
<p>产品立项之后，总体方案评审通过，进入详细设计阶段，我们的动作就可以开始做了。</p>
<p>产品的宣传资料可以出了，产品样机还没有出来，产品的市场预热推广已经开始了。这就是并行工程。那么我们通常情况下，我们敢不敢在样机还没有出来的时候有已经开始了产品的市场动作？敢不敢？</p>
<p>我想很多企业是不敢的，产品没有出来就大量的投入营销，那么如果产品出不来怎么办呢？</p>
<p>而在 IPD 的流程体系中，产品不会不出来，而且计划是产品不会不按照原定计划出来。</p>
<p>一方面，IPD 强调的 “一次性把事情做好”；</p>
<p>另外一方面，IPD 有系统的流程控制方法来保证产品开发如期完成。</p>
<p><strong>重用性</strong> 尽量采用公共构建模块 (Common Building Block, 简称 CBB)，提高产品开发效率。</p>
<p><strong>CBB</strong>，称为公共构建模块，这些模块，可以是软件的、可以是硬件的、可以是测试的、可以是生产的。有了这些模块，我们开发过程就聚焦在模块之外的其他需求进行，一方面减少了工作量。</p>
<p>我在做手机的时候，我们曾做了一个 1.5 个月研发出一款手机并成功转量产的记录，就是充分应用了 CBB 的重用思想。</p>
<p><strong>7. 中小企业也可以插上 IPD 的翅膀</strong></p>
<p>第七个核心思想，阐述了 IPD 的灵活的，随着业务和技术的发展而变化的，可以全面应用，要可裁剪应用。因地制宜，随机应变。</p>
<p>至今，华为的 IPD 还在不断的优化和升级，并且运用在了终端、无线、存储等各个产品线。</p>
<p>而 IPD 最小的业务模式也同样适用于中小型企业。</p>
<p>以上这七个横向的内容就是 IPD 的核心思想，IPD 的核心思想是 IPD 最重要管理精髓。</p>
<p>当然除了横向的核心思想，IPD 还包含了纵向的核心内容：</p>
<p>第一个内容，IPD 包含了 MM 市场管理流程，核心思想中强调了新产品开发是基于市场需求的开发，所以从市场到产品开发，一定需要一个市场管理流程来支撑。市场管理流程通过对市场的收集、分析、做出业务规划，输出产品开发任务书，作为产品开发的输入，是市场到开发的转化过程；</p>
<p>第二个内容是 IPD 集成产品开发流程，这是我们实现产品开发落地的流程，怎样做出产品来，就是在这个流程中体现。后边的章节里我们会更详细的介绍。</p>
<p>第三个内容技术开发流程，这个流程是实现企业的技术积累，核心竞争力的沉淀；</p>
<p>第四个内容是项目管理流程，IPD 核心管理是基于项目管理来进行的，而项目管理是在管什么呢，是在管资源。</p>
<p>第五个内容矩阵型组织结构，这是团队形式，核心思想中包含了跨部门团队，这个跨部门团队需要一个矩阵式的管理。</p>
<p>第六个内容是：绩效与激励，从业务上来看着是一个支撑内容，为我们业务目标服务的。从管理上来看，这条非常重要，包含了企业文化、HR 的思想等。一句话，门朝哪里开，人就会从哪里走，就在这里来操作。我们的门要向着目标的方向打开。</p>
<p>第七个内容 是管理优化与变革，这里强调了随着业务的发展，我们前面的这六点基于管理的内容要不断的优化升级，以更好的适配公司业务的发展。在华为公司，专门成立了管理优化部门，每年投入销售额的 3-5% 进行管理的优化变革。同时公司内部也有一个管理优化报，面向全公司发布。</p>
<p>七横七纵，从概念上介绍了 IPD 的全貌，是 IPD 的精华所在，希望大家能够理解和运用它。</p>
<h4 id="四、八个特征掌握-IPD"><a href="#四、八个特征掌握-IPD" class="headerlink" title="四、八个特征掌握 IPD"></a><strong>四、八个特征掌握 IPD</strong></h4><p><strong>1. IPD 的一套框架</strong></p>
<p><img src="https://pic3.zhimg.com/v2-557be7394adda907102507443972ce8a_r.jpg" alt=""></p>
<p>从公司战略出发、收集市场信息、客户反馈、竞争信息、技术趋势、产品组合进入市场管理流程。通过市场管理流程的对信息的分析、转化为业务计划，输出产品规划的 charter（产品业务计划书）</p>
<p>输入到产品开发流程，一部分输送给技术开发流程。通过产品开发流程和技术开发流程，实现对产品和技术的输出。</p>
<p><strong>2. IPD 的两种评审模式 DCP 和 TR</strong></p>
<p><img src="https://pic1.zhimg.com/v2-1b93002f94e2aded7cb220d1241c15b8_r.jpg" alt=""></p>
<p>产品开发流程使用两种评审机制，一种是基于业务决策线的评审；另一种是基于技术线的决策评审。</p>
<p>业务决策评审是集成产品开发管理团队（IPMT）管理产品投资的重要手段，在决策评审中，IPMT 始终站在投资商的角度来进行评审。</p>
<p>业务决策评审包含了 charter 决策评审、概念决策评审、计划决策评审、验证决策评审、生命周期决策评审</p>
<p>另外一种是技术决策评审，通过技术评审，帮助产品开发团队尽早发现产品开发中存在的问题和风险，及时采取相应的解决方案和行动计划，保证产品开发质量，减少浪费。</p>
<p><strong>3. IPD 的三大业务流程</strong></p>
<p><img src="https://pic4.zhimg.com/v2-22db8a6eb8546a2cd01a4ebfafc16737_r.jpg" alt=""></p>
<p><strong>4. IPD 的四大组织</strong>  </p>
<p><img src="https://pic4.zhimg.com/v2-e9ee51a0800a6e6ddfac5209208838a7_r.jpg" alt=""></p>
<p>（1）集成组合管理团队（IPMT）：产品投资决策和评审机构，负责制定公司总的使命愿景和战略方向，并对新产品线的产生进行决策。通常是一个高层跨部门团队，成员包括各个部门最高主管。</p>
<p>（2）产品开发团队（PDT）：一个虚拟的组织，其成员在产品开发期间一起工作，由产品经理 / 项目经理组织，一般是产品经理 / 项目经理负责的矩阵组织结构。</p>
<p>（3）产品生命周期管理团队（LMT）：在产品生命周期中，联合研发、制造、销售、使用、安全部门等各方面的资源，从根本上保证了产品在全生命周期中的管理能够高效、有序，并使产品保持低故障率。</p>
<p>（4）技术开发团队（TMT）：利用从研究和试验获得的知识或技术，为产品开发提供新的工艺和系统而进行实质性的改进。</p>
<p> <strong>5. IPD 的五个业务决策评审点</strong></p>
<p><img src="https://pic2.zhimg.com/v2-dea016a73693563cde089ff9463e4259_r.jpg" alt=""></p>
<p>（1）Charter：立项评审</p>
<p>（2）CDCP(Concept?DCP)：概念决策评审</p>
<p>（3）PDCP(Plan?DCP)：计划决策评审</p>
<p>（4）ADCP(Availability?DCP)：可获得性决策评审</p>
<p>（5）EDCP(EOL?DCP)：生命周期终止决策评审</p>
<p><strong>6. IPD 的六个开发阶段</strong></p>
<p><img src="https://pic3.zhimg.com/v2-a9c7db1b072a48d9a4bde310d25b0252_r.jpg" alt=""></p>
<p><strong>7. IPD 的七个技术评审点</strong></p>
<p><img src="https://pic3.zhimg.com/v2-cfb4bd36c41890aeb65d95f6ec329b9e_r.jpg" alt=""></p>
<p>当然，IPD 流程中设置了很多机制来对这类问题的解决。比如说我们的研发质量规范、我们的代码规范、代码检视、单元测试、系统测试等等。</p>
<p>IPD 的流程中为了最大限度的节省缺陷或问题流入后端造成了损失。就体现在前面介绍的两种评审机制，不论是基于业务的还会基于技术的评审，只要上一个评审点没有通过，就无法进入下一个评审点。这种机制有效的解决和平衡的我们新产品开发过程中的遇到的问题。</p>
<p>每一个环节都有自己的客户，我们一定要清楚自己的客户是谁，我们是为谁在服务。IPD 强调下一道工序就是你的客户！</p>
<h4 id="五、实施-IPD，你也可以"><a href="#五、实施-IPD，你也可以" class="headerlink" title="五、实施 IPD，你也可以"></a><strong>五、实施 IPD，你也可以</strong></h4><p><strong>1. 小组织也可以 IPD</strong></p>
<p>重量级团队削弱了功能部门的影响力。事实：功能部门在 IPD 的执行与决策中都占据着关键的地位。但是角色发生了变化。就像在乐队的演奏中，每个人都有自己的角色。如果鼓手演奏的声音比其他人大，如果鼓手想控制整个音乐（即使鼓手的技能不够），虽然鼓手自己可能感觉很强大，但是整个音乐已经不和谐了，已经被破坏了。扪心自问，实事求是地考虑一下自己真正的权力来自哪里。功能部门在 IPD 中扮演着非常重要的角色，不过在 IPD 流程中以团队的形式进行运作很重要。如果没有本身优秀的强大功能部门，IPD 也无法发挥自己的作用。功能部门在许多方面都发挥着重要的作用，如对本部门员工技能的培养进行管理，制定功能部门策略，向 PDT 和 IPMT 做出并履行承诺，将本功能部门与其他部门及公司联合起来，加强本功能部门对承诺的执行。同样，IRB 和 EMT 已经签发了政策和指导来更好地支撑华为的重量级团队建设环境，包括激励，PBC 和资源池。可是每个团队成员仍然有责任充分参与团队工作，积极帮助团队实现目标。</p>
<p>IPD 组织结构通常可以看成一个小公司。这就是为什么华为 18.8 万人的企业中，研发能够快速响应的一个重要原因。  </p>
<p>误区一：<strong>IPD 是大公司的事情，我们是小公司，没有实施 IPD 的必要</strong></p>
<p>IPD 本身是一种产品研发的最佳实践，强调研发要做正确的事情，体现市场驱动，把研发资源投入到最有价值的项目中，这些理念对中小企业同样有非常大的指导意义；尤其中小企业面临资源匮乏，一个项目的失败可能会导致整个公司的倒闭，这种状态下，更应该践行 IPD 的研发方法，确保项目的成功率，甚至要追求 120% 的成功率。 <strong>我们是项目化公司，IPD 是产品开发，所以不适合我们</strong></p>
<p>IPD 本身是从商业角度分析产品和项目是否值得投资，即使项目化的公司，也需要追求项目的投入产出率，也需要时刻关注客户需求，尤其是国内项目化公司普遍面临缺乏平台、跨项目共享差、交付成本高的问题，IPD 的市场驱动、异步开发模式、项目决策分析都可以非常好地解决这些问题。所以项目化公司同样需要 IPD。<br><strong>IPD 实施推行需要非常高的成本，实施周期很长，我们目前没有能力搞。</strong></p>
<p>大家有这种认识纯粹是 IBM、IPD 实施顾问忽悠的结果，把 IPD 忽悠的多么神圣、多么高档、如此之难，进而从客户手里多搂钱，把实施费用搞的奇贵，从而让客户感觉 IPD 是非常贵族化的东西，身份的象征。其实街边小餐馆都是按照 IPD 的思路运作的，在哪里开？市场客户决定 —（IPD 之市场驱动）；费用多少？竞争对比分析而定 — （IPD 之竞争分析）；每天早上要准备多少材料？历史销售情况 + 今天的销售预期决定 — （IPD 之预算管理）；提供哪些种类？制作周期太长的不做，因为客户没有时间等 — （IPD 之产品交付）；丰盛大餐的不做，因为厨师水平要求高，费用高 — （IPD 之项目研发费用）；每天晚上核算今天盈利、与历史对比 — （IPD 之衡量指标与对比分析）；客户喜欢的、利润高的种类放在菜单最上面 — （IPD 之投资组合分析）；所以 IPD 在中小企业同样适用，并且可以分步实施，实施难度、成本都是在可控范围之内。 <strong>还有诸多疑虑……</strong></p>
<p>误区二：<strong>IPD 是要在速度与质量之间做出取舍？</strong></p>
<p>误区三：<strong>IPD 影响决策的速度？</strong></p>
<p>误区四：<strong>重量级团队削弱了功能部门的影响力？</strong></p>
<p><strong>……</strong></p>
<p><strong>2. 貌似缺失的质量控制缺是最有效的控制</strong></p>
<p>IPD 是速度与质量相结合。技术评审点即使技术评审又是质量评审，质量管理被融入在 IPD 的流程和体系当中，潜移默化的，自然的服务于产品和控制产品质量。IPD 的目的是保证速度，但同时也要保证产品的高质量。IPD 不仅要使产品开发速度更快，而且还提供了一种规范，保证能够生产出高质量的产品。</p>
<p><strong>3. 环环相扣，齿齿相连，一次性把事情做好</strong></p>
<p><strong>环环相扣，齿齿相连</strong></p>
<p>每个角色都处于 IPD 的一个环节，只有当上一个环节完成了，并且是按照产品质量要求完成了，才会流向下一个环节，正如流水生产线一样，只有上一个工序的工作完成了，且被检验为合格了才能流到下一个工序。也只有上一个工序完成时，下一个工序才能开始，一切都在项目计划的控制之中。每个工序都会对下一个工序产生影响。</p>
<p><strong>一次性把事情做好！慢即是快。</strong></p>
<p>从整个 IPD 的核心思想方面来说，所有的流程和关键的评审点都是围绕这个 “一次性把事情做好” 这句话来的，因为在研发当中，一次性把事情做好，效率才是最高的。比如原本计划下个月的进行新产品的试制，原材料已经准备好，生产计划已经按照出生产线为我们的试制产品做准备。如果产品试制不能如期进行，生产线的计划将被打乱。相关的人员安排可能临时不能调度，原计划的试制期间的生产资源就会造成浪费。</p>
<p><strong>【结尾】</strong></p>
<p>公司的战略是选择方向，就是解决做正确的事情，做与公司目标相匹配的事情。</p>
<p>IPD(Integrated product development 集成产品开发) 是针对公司已经选择确定战略规划之下，正确的做公司规划的产品开发的事情，即使通常我们讲的正确的做事。</p>
<p>只有做正确的事情和正确的做事，才能保障经营的不败。</p>
<p>我想把一个复杂的系统，还原成一个常识的理解。只要我们理解和认识了 IPD，我们也同样可以穿上 IPD 之鞋，谁说灰姑娘就不能穿上漂亮的舞鞋跳舞呢？</p>
<blockquote>
<p>原文地址 <a href="https://zhuanlan.zhihu.com/p/392385187" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>IPD</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>艾默生的战略规划创新及其启示</title>
    <url>/2023/03/03/%E8%89%BE%E9%BB%98%E7%94%9F%E7%9A%84%E6%88%98%E7%95%A5%E8%A7%84%E5%88%92%E5%88%9B%E6%96%B0%E5%8F%8A%E5%85%B6%E5%90%AF%E7%A4%BA/</url>
    <content><![CDATA[<blockquote>
<p>&emsp;&emsp;本文对世界制造业取得卓越绩效的艾默生集团公司上世纪60年代以来的战略规划体系发展及其创新进行了案例研究。在对艾默生公司战略规划的发展过程、核心内容、组织流程和时间周期描述的基础上，分析了公司规划体系的“两栖型”内容创新、“一体化”组织创新和“独特性”的规划工具创新等特征，指出艾默生的战略规划体系的“三重创新”使企业战略在增长与赢利、前瞻与学习、制定与执行、普遍与独特等方面达到协调和统一，从而驱动了公司赢利的长期持续增长。最后对战略规划创新与竞争优势的关系、大中型企业的战略决策模式进行了讨论，并探讨了艾默生经验对中国大中型制造企业战略规划与战略管理体系建设的启示。</p>
</blockquote>
<a id="more"></a>
<p>&emsp;&emsp;作为世界制造业强势企业集团，艾默生近50年来的股东回报以年均16％的复合增长率持续增长，2008年的利润总额和股东权益回报率都居电气行业前列。在此期间，公司的战略规划体系的发展与创新对企业保持良好的赢利性和持续成长产生了重大的影响。本文希望通过对艾默生近50多年来的战略规划体系创新的深入分析，探讨其影响公司赢利持续增长的内在机制，进而对中国制造业的企业战略规划体系创新和战略管理体系建设以有益启示。</p>
<h2 id="一、艾默生公司的战略规划体系：一个素描"><a href="#一、艾默生公司的战略规划体系：一个素描" class="headerlink" title="一、艾默生公司的战略规划体系：一个素描"></a>一、艾默生公司的战略规划体系：一个素描</h2><h3 id="1、子公司利润评估"><a href="#1、子公司利润评估" class="headerlink" title="1、子公司利润评估"></a>1、子公司利润评估</h3><p>&emsp;&emsp;一直以来，艾默生很强调利润计划。在20世纪90年代初，艾默生意识到增长的重要性。同时，由于国际制造业所处的高度竞争的环境，公司又需要可靠的利润预测。因此，艾默生决定为利润计划和增长计划分别举行会议。在每年春天开始作利润评估时，子公司管理层—子公司总裁及其高级管理人员将与总公司的“利润沙皇”举行会议，“利润沙皇”通常是是艾默生最高管理团队中的一位，主要职责是确保各个子公司和总公司作为一个整体实现年度目标利润。有关业务集团的高层管理人员也会列席会议，但是主角是子公司管理者。利润评估将审查前5年的历史、当前年份的现状以及未来5年的预测数据，因此，计划者用11年跨度的窗口评估其业务，并形成一个利润模型。在模型中，价格变化、通货膨胀因素以及生产率提高等都会被考虑到，纳入模型的还有成本减少和控制计划、固定成本的处理方法以及业务组合方面的变化。计划者在所有这些领域作的都是最为保守的假设，以确保不夸大自己的估计。在此情况下，要达成两位数的税前利润增长是非常具有挑战性的，这一方法使管理者去寻求和详细讨论特定的行动计划，以满足利润目标，这包括新产品的研发带来的溢价、新产品销售带来的拉动效应、整合采购带来的效益、必要的工作转移、工厂转向最优成本地区、业务外包和其他可以改善资产管理的行动。所有这些计划都是保证子公司在大风暴中继续发展和成功的基石。在完成利润评估之后，“利润沙皇”将准备一份备忘录供计划会议使用，计划会议是计划周期的下一个阶段，它是艾默生计划的核心，一般在几个月之后举行。</p>
<h3 id="2、子公司计划会议"><a href="#2、子公司计划会议" class="headerlink" title="2、子公司计划会议"></a>2、子公司计划会议</h3><p>&emsp;&emsp;在通过“利润评估”之后，计划过程将转入子公司的“增长战略”阶段。出席这个1～2天会议的人员包括：子公司管理层、艾默生的CEO以及一些选定的公司领导。子公司计划会议的最终目的是确定为公司创造价值的最佳方法。子公司管理层将安排日程，准确说明如何创造价值。母公司并不要求提供指定形式的详细数据，不过，核心管理层希望观察到关于财务和竞争绩效—销售、利润、资本回报、市场规模、市场渗透能力和价格走势的有见地的讨论，以及关于客户和竞争对手的详细分析。与利润评估一样，增长计划评估时用11年作为时间跨度，对损益表和资产负债表展望未来5年，回顾过去5年。11年的窗口可以将投资与收益预测分散到一个较长期的观察视野之中。</p>
<p>&emsp;&emsp;尽管计划会议是属于子公司总裁及其团队的事情，但是，艾默生总部也参与对话和准备工作，以帮助子公司经理们完善计划并取得好的计划效果。艾默生总部的小型战略计划部门承担着为子公司“挑错”和核对各种数据的工作，计划经理们对研究和分析的质量以及总体计划的一体化与一致性程度加以检查；对于各个市场、竞争者和工业领域变化的数据向子公司管理团队提出质询；母公司计划经理们会确保企业所面临的关键问题和挑战都在会议资料中得到了详细论述，并制定应对这些问题和挑战相应的行动措施。在这些准备工作中，子公司管理层将主导这一切，即计划者是将来的执行者。</p>
<p>&emsp;&emsp;子公司计划会议的基调是对抗性的。子公司管理团队而不仅仅是子公司的总裁负有责任让艾默生的核心层信服：计划经过好的构思，而且有详尽的研究和严密的分析作支持。会议上要对一些假设和传统的思维表示质疑，并给出足够的时间来讨论每个重要问题。同时，会议将对前三至五个最重要的行动展开详细讨论，并对提供支持的因素及构成挑战的问题进行分析。会议讨论中母公司领导人有时候会故意不断从各个角度挑战子公司的观点，这并非是CEO或COO不赞同这一观点，只是他们希望子公司已经把各个方面都考虑清楚了。</p>
<p>&emsp;&emsp;子公司计划会议的产出将是诸多为大家共同认可的行动和优先考虑事项。艾默生的CEO也会向各子公司总裁发出备忘录，文件中将就计划、行动、承诺以及其他任何重要问题扼要地进行总结。这封信将成为下一次计划会议议程的一部分，在控制循环所举行的会议上，信中的内容将被一一跟踪考察。这种计划备忘录的做法在艾默生内部得到广泛应用，每一位经理人在和团队评估过计划后，都会以一封电子邮件或备忘录的形式总结要点、承诺和行动方案，因此，这也是控制和跟进的重要方式。</p>
<h3 id="3、战略评估：在业务集团层面制定计划"><a href="#3、战略评估：在业务集团层面制定计划" class="headerlink" title="3、战略评估：在业务集团层面制定计划"></a>3、战略评估：在业务集团层面制定计划</h3><p>&emsp;&emsp;业务集团计划并不仅仅是将子公司的计划汇总，艾默生也在业务集团层次制定计划，以便在发现子公司能力不足以应对某些机会的时候，能够在公司整体范围内进行整合，确保资源的充分利用。在这一更高层面，公司对于要寻求的机会进行选择和取舍，以决定哪些机会务必竭力获得，哪些业务必须支持，哪些业务需要降低重要性甚至需要退出。</p>
<p>&emsp;&emsp;各个业务集团每年夏季都进行年度战略评估。这时，业务集团领导人、核心管理人员与CEO、总裁和其他公司领导将会见面，聚在一起评估和讨论重大的战略性经营挑战以及关键性行为。会议将精力集中在成长和营销战略，以建立和保持艾默生的行业领导地位。业务集团的领导人也要评估业务集团的财务前景。</p>
<h3 id="4、总公司计划和全球高级管理者沟通会议"><a href="#4、总公司计划和全球高级管理者沟通会议" class="headerlink" title="4、总公司计划和全球高级管理者沟通会议"></a>4、总公司计划和全球高级管理者沟通会议</h3><p>&emsp;&emsp;子公司计划会议、利润评估和业务集团战略评估期间获得的信息，将成为艾默生每年秋天召开的公司规划会议(简称CPC)所需要的原始材料。出席CPC的是前300名总公司和子公司高层领导。各个子公司和业务集团是业务组合的一部分，对于其中的每一个部分，艾默生的管理层都在不断地衡量和评估其增长、赢利能力和现金流的趋势。在会议召开之前，CEO办公室要从子公司会议和战略评估之中找出关键性的主题，并将它们与宏观经济环境分析相应结合。然后，CEO办公室将这一信息整合成公司总计划：一个一体化的、有重点的关于公司目标以及实现公司目标的计划陈述。然后，将计划提交给CPC和区域性公司计划会议。</p>
<p>&emsp;&emsp;每年初秋，在公司计划被汇总及被批准之后，公司计划会议基本上就成为一个向经理人员传达信息的载体。公司高层在会议上汇报公司所取得的成就，并通报下一年度的财务计划及今后5年的战略计划。在总公司计划会议之后，还将举行区域(欧洲/亚洲)公司计划会议，以便对该区域经理进行沟通和宣贯。与上述的计划周期相平行，公司主要通过三种正式制度来对运营和行动计划执行情况进行监控，一种是每年1次的财务评估，通常在每财年后半段举行；第二是每季度1次的总裁行政会议—每个子公司的CEO和CFO将会参加；其次是每月1次的总裁运营报告(POR)—即要由各个子公司递交给总裁会议和年度财务会议的月度报告，它是动态工具，每月都要更新预期的年度结果并与历史和目标进行比较。</p>
<h2 id="二、艾默生战略规划体系“三重创新”分析"><a href="#二、艾默生战略规划体系“三重创新”分析" class="headerlink" title="二、艾默生战略规划体系“三重创新”分析"></a>二、艾默生战略规划体系“三重创新”分析</h2><p>&emsp;&emsp;战略规划的系统设计理论认为，战略规划系统可以从以下维度进行设计(斯坦纳，2001)：内容完整性与侧重点、时间尺度、分析深度与复杂性、流程、CEO的参与、直线管理者的角色、规划部门的角色、分析工具等。其中，前三项构成战略规划的内容体系，中间四项构成了规划的组织体系，最后一项构成了工具体系。本文从这三大方面分析艾默生战略规划体系的主要特点、创新及其影响(详见表1)。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/艾默生的战略规划创新及其启示/202303031439612-2023-03-06-10-18-58.png" alt="202303031439612-2023-03-06-10-18-58"></p>
<h3 id="1、“两栖型”内容创新：成长与赢利、前瞻与学习的平衡"><a href="#1、“两栖型”内容创新：成长与赢利、前瞻与学习的平衡" class="headerlink" title="1、“两栖型”内容创新：成长与赢利、前瞻与学习的平衡"></a>1、“两栖型”内容创新：成长与赢利、前瞻与学习的平衡</h3><p>&emsp;&emsp;艾默生战略规划体系在内容方面的创新，包括三个方面(表1中的①②③)：(1)以子公司为核心的增长计划和赢利评估的分立与并重；(2)赢利性评估中建立在细致、严苛预测基础上的行动方案；(3)跨度为11年的“瞻前顾后式”滚动计划。其中，第1条使得公司在关注公司赢利性的同时，很好地挖掘长期战略成长机会及行动方案，拓展公司的业务范围和能力疆域，避免了战略规划沦为“年度预算”或“运营项目”的倾向，防止了明茨伯格所谓的战略规划的“正式性谬误”—即由于过于关注正式性而忽略了“软性”的战略思考，促进了公司赢利基础上的持续增长。第二项创新则使赢利性评估建立在对近期最严苛的经营环境情景之上，部分避免了明茨伯格的战略规划的“可预测性谬误”；第三项创新是11年期的“瞻前顾后式”滚动性计划，它覆盖了制造业的投资波动周期，并且在战略学习(回顾过去5年)与前瞻性(展望未来5年)之间形成了平衡，使得战略规划过程成为一个持续的设计、学习、修正和改进的过程。本文把艾默生的“增长与赢利并重”(目标/内容)、“瞻前顾后型滚动计划”(时间尺度)称为战略规划内容的“两栖型创新”，并将其要素和相互关系概括如图1所示。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/艾默生的战略规划创新及其启示/202303031439106-2023-03-06-10-19-21.png" alt="202303031439106-2023-03-06-10-19-21"><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图1 艾默生的计划和控制周期</p>
<h3 id="2、“一体化”组织创新：规划主体与执行者的统一及分工协作"><a href="#2、“一体化”组织创新：规划主体与执行者的统一及分工协作" class="headerlink" title="2、“一体化”组织创新：规划主体与执行者的统一及分工协作"></a>2、“一体化”组织创新：规划主体与执行者的统一及分工协作</h3><p>&emsp;&emsp;艾默生的规划流程/组织设计有两方面的创新(表1中④⑥⑦⑧)：(1)计划主体与实施者的统一。它主要体现在表一中的④和⑦上，这种以子公司的领导团队为主体的规划组织体系，使得子公司领导层能充分利用其业务信息、提高其承诺和战略执行的主动性，避免了明茨伯格所谓的战略规划制定与执行的“分离性谬误”；(2)规划中总公司CEO、公司规划部门和子公司管理者之间的分工协作。这主要体现在表1的⑥⑦⑧。在这个过程中，CEO、子公司经理、公司规划经理的各司其职与紧密协作是至关重要的。其中，艾默生的公司规划经理主要承担了以下角色：为子公司“挑错”和核对各种数据、对研究和分析的质量以及总体计划的一体化与一致性进行检查；对于各种市场、竞争者和工业领域变化的数据向子公司管理团队提出质询；确定企业所面临的关键问题和挑战，并制定应对这些问题和挑战相应的行动措施等。总公司的CEO在规划会议中对子公司计划提出各角度的质询，甚至故意引起激烈争论，以保证各种因素在决策中得到考虑。</p>
<h3 id="3、有针对性的“独特”工具创新：“最佳成本制造商战略”和“利润瀑布分析”"><a href="#3、有针对性的“独特”工具创新：“最佳成本制造商战略”和“利润瀑布分析”" class="headerlink" title="3、有针对性的“独特”工具创新：“最佳成本制造商战略”和“利润瀑布分析”"></a>3、有针对性的“独特”工具创新：“最佳成本制造商战略”和“利润瀑布分析”</h3><p>&emsp;&emsp;艾默生在规划工具方面，也坚持从实际出发，在遵循一般规律的基础上，进行有针对性的“独特”的创新，这可以用“最佳成本制造商战略”和“利润瀑布分析”为例加以说明。1970年代，随着日本工业的兴起，艾默生率先意识到全面质量管理(TQM)的重要性，开始在所有子公司开展TQM管理。1980年初，艾默生意识到全球化激烈竞争将扩散到所有业务领域，因此，重新定义了一个新的“最佳成本制造商战略”来应付与日俱增的全球竞争—艾默生需要最佳成本，它不仅关注价格同时还关注客户所感受到的价值—即产品、服务和价格的最优组合而非简单的最低成本。这一模式顺应了国际竞争新趋势，符合一般竞争规律而又突破了竞争优势在低成本或差异化之间非此即彼的教条。根据这一原则，艾默生推动了大量子公司向低成本地区迁移和扩张，包括90年代中期在墨西哥的大规模建厂和90年代后期利用东欧的智力和工业资源的迅速扩张。</p>
<p>&emsp;&emsp;另外的一个例子是“利润瀑布分析”。1990年代初期北美经济面临另一个衰退周期时，通过收购和剥离的效果已经不够显著了，艾默生便将首席运营官(COO)博杰思调离重要的运作管理岗位，委派他负责重振和改善利润增进过程—以尽快地找出问题和解决问题。博杰思带领团队花了一周时间尝试分析什么事情出了错。他们找回1987年的子公司计划会议记录，了解曾经预测在1992年底达到3.5％利润增长计划的组成内容，目的是为了弄清楚为什么会落后于计划。这项工作有几项重要的发现：与原计划相比，需求增长的下降、定价压力、材料成本的膨胀、工资成本的膨胀、医疗福利费用增长等是计划失效的主要因素。基于这个发现，在首席财务官高文和首席运营官博杰思的直接领导下，艾默生的团队编制了一个以Excel为基础的数据分析表，它能够为制定5年预测计划提供精确的基础。这一软件将销售数量、价格和成本组成部分(材料、计时劳工、薪酬和一般费用)结合起来，并在上一个5年计划的实际结果的条件下对预测进行估计。这一分析工具名为“利润瀑布”，它很快被用作一年期财务评估和5年期计划的基础。同时，为防止不现实的乐观预测，并驱使管理层彻底考虑强有力的行动以在艰难环境中改善利润率，艾默生的最高管理层坚持要求各个子公司就计划利润作最为保守的假设，子公司的总裁还必须为那些在过去的实际结果中经常出现但从来没有被预测到的不可预见的成本因素留出余地。保守的估计以及瀑布设计的严密促进经理们意识到更多、更强硬的降低成本和提高赢利行动的需要。事实表明，这一从实际出发的有针对性的赢利分析工具为艾默生在严酷竞争环境下长期保持较高赢利能力做出了重要贡献。</p>
<h2 id="三、创新背后的理念和价值观"><a href="#三、创新背后的理念和价值观" class="headerlink" title="三、创新背后的理念和价值观"></a>三、创新背后的理念和价值观</h2><p>&emsp;&emsp;艾默生战略规划体系的创新，除了受公司“管理过程”六大要素的影响外，公司最高领导层的基本信念和价值观也是深层的影响因素。事实上，艾默生公司的最高领导层相当稳定，在过去60年间，只有三位CEO，其中，奈特从1973-2001年任CEO期间对于艾默生的“管理过程”做出了巨大的贡献。他系统地阐述了艾默生的“最优成本制造战略”，同时，完善并强化了公司商业竞争取胜的基本理念(奈特，戴尔，2007)，这些理念包括：(1)持续的高绩效；(2)寻觅为客户增加价值的新方法是致胜之道；(3)在关键市场中，艾默生必须是行业的领袖；(4)取得技术领先地位是取得市场领先地位的关键；(5)长期的成功需要整个组织的全心全意地投入；(6)主要的经理人员必须拥有自主权，从而发挥其最大潜力；(7)艾默生一贯通过员工来提高生产力。</p>
<p>&emsp;&emsp;应该指出，正是基于这些基本理念和价值观以及对管理任务的共同理解，艾默生在实践中不断完善了公司“管理过程”体系，并实现了战略规划体系的不断创新。</p>
<p>&emsp;&emsp;基于上述的分析，我们可以把艾默生战略规划在内容、组织、工具三方面的创新概括为战略规划设计的“三重创新”，并将其主要特征及其深层理念和价值观原因概括为图2的简略形式。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/艾默生的战略规划创新及其启示/202303031440300-2023-03-06-10-19-48.png" alt="202303031440300-2023-03-06-10-19-48"><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图2 艾默生战略规划的“两栖型”内容创新</p>
<h2 id="四、讨论与启示"><a href="#四、讨论与启示" class="headerlink" title="四、讨论与启示"></a>四、讨论与启示</h2><h3 id="1、战略规划体系创新与竞争优势"><a href="#1、战略规划体系创新与竞争优势" class="headerlink" title="1、战略规划体系创新与竞争优势"></a>1、战略规划体系创新与竞争优势</h3><p>&emsp;&emsp;从艾默生的战略规划实践来看，明茨伯格对战略规划“三重谬误”的批评并非是不可避免的。艾默生通过增长计划与赢利评估分立、子公司管理层为核心和利润瀑布分析等方式，实现了战略规划的“三重创新”：即内容方面的“双栖型创新”、组织/流程的“一体化创新”和工具方面量身定做的“独特工具”创新，有效地避免“正式性谬误”、“分离性谬误”和“可预测性谬误”等问题，取得了较好的战略规划与实施绩效。这说明了战略规划体系设计中内容、组织和工具“三重创新”对竞争优势的重要性。Barney曾经认为，正式的战略规划(如经典的SWOT分析工具、业务组合管理等)由于其广泛传播而不具有稀缺性、难模仿性和难替代性，因此它不能成为持续竞争优势的来源。Powell也根据资源基础观指出，当战略规划作为一种生产要素在行业中能被广泛获得时，其带来的竞争优势将消失。本文的案例研究则表明，由于战略规划体系的系统性和复杂性，战略规划的内容、组织或工具的创新确实可以带给企业竞争优势，甚至形成一定时期内的持续竞争优势。结合Grant(2003)对世界八大石油巨头战略规划体系的系统分析，可以看出，利用正式战略规划并根据环境变化和企业情况对内容、组织和工具进行调整或创新，仍然是大中型制造业企业可以利用的一种重要战略管理工具，也是其获得竞争优势的一种可行途径。当然，从艾默生的经验看，其领导人在战略发展方向(如“最优成本生产商战略”)和完善战略规划制度方面(“利润瀑布分析”、“计划跟进及控制”)起到了至关重要的作用，因此，领导人的战略领导和战略规划不是非此即彼的替代关系，领导人全身心地参与到战略规划中进行指导和引导是产生竞争优势的一个非常重要的驱动因素。从这个角度看，明茨伯格对正式战略规划可能导致“分析取代综合性战略思维”的批评仍有一定的警示意义。此外，本案例也表明，战略规划体系创新需要企业内部权力结构和文化体系的支持。因此，如何在战略规划中更好地促进战略思维并协调思维与行动之间的关系，同时系统考虑战略规划创新的政治、文化支持因素，既是战略规划体系设计必须应对的一个挑战，也是进入21世纪后战略规划理论发展的一个重要方向。</p>
<h3 id="2、大型企业战略决策模式的“混合化”趋势"><a href="#2、大型企业战略决策模式的“混合化”趋势" class="headerlink" title="2、大型企业战略决策模式的“混合化”趋势"></a>2、大型企业战略决策模式的“混合化”趋势</h3><p>&emsp;&emsp;在战略决策文献中，关于战略规划、企业家决策与自发/分散决策等战略决策类型及其作用的讨论一直很激烈。从国内外大型制造企业的实践看，一些企业选择了战略规划体系的创新或调整，如艾默生、联想、大石油公司等(Grant，2003；武亚军，2007)，另外一些企业如GE则“放弃”了传统的正式性很强的战略规划体系而转向以战略领导和分散决策为主的战略决策模式。从总体上看，这反映了一种动态环境下企业战略决策的“混合化”趋势—即正式战略规划与其他战略决策类型相结合。这一方面和企业国际化及竞争环境的快速变化有关，另一方面也与企业的管理基础、最高领导人的能力与管理风格有很大的关系。从大中型企业的战略决策方式看，正式战略规划是很普遍也很难逾越的决策方式。事实上，艾默生通过战略规划体系的创新，在战略领导、正式战略规划和一线业务领导人的分散决策之间形成了一种“综合协调”，进而取得了赢利的持续增长。从这个角度上看，艾默生的成功在于其以正式战略规划为主、辅以其他两种战略决策模式的成功。正如不少研究所揭示的那样，结合战略规划和其他两种模式的综合性战略决策模式将是动态复杂环境下大型制造企业战略决策的一种发展趋势。</p>
<h3 id="3、对中国大中型本土制造企业的启示"><a href="#3、对中国大中型本土制造企业的启示" class="headerlink" title="3、对中国大中型本土制造企业的启示"></a>3、对中国大中型本土制造企业的启示</h3><p>&emsp;&emsp;如表2所示，对比艾默生的战略规划创新与中国本土著名制造业企业——联想的战略规划经验(武亚军，2007)，可以发现：两个企业在外部环境的动态性、内容创新、工具创新、组织创新等方面都有一定的相似性，例如，艾默生通过利润与增长计划分立来平衡赢利性和成长问题，而联想则通过三类业务组合配置(成长战略)和完善业务模式(竞争战略)来协调两者的关系；艾默生在1990年代初未达到预期目标后通过反思性的战略学习形成了“利润瀑布”分析工具和“严苛预测”原则，而联想在经过2000-2003年规划挫折后也通过反思性的战略学习形成了“战略路线精准化”和“业务模式创新”等战略原则。所不同的是，艾默生在战略规划的体系化、制度化上比联想更为成熟，这和前者经历了更长期的发展有很大关系。无论如何，对于中国的大中型制造企业来说，联想和艾默生的经验都有很强的借鉴意义：(1)企业从小到大、从创业到逐步成熟、从国内到国际化的发展过程中，需要结合企业的环境和自身条件，进行战略规划的内容、组织和工具“三重创新”，才能真正通过战略规划提高竞争力和实现持续增长；(2)战略规划的创新需要组织权力结构和核心价值观的支持，这是企业战略规划创新的制度与文化基础。事实上，这恰恰是很多中国大中型本土企业所欠缺和需要面对的挑战。艾默生公司和联想为中国大中型制造企业的战略规划树立了两个标杆，不过联想的战略规划体系仍处于系统化和完善之中，而艾默生则由于其长期发展而比较成熟和完善，这也增大了艾默生公司经验对中国大中型企业(包括联想在内)的借鉴价值。</p>
<h2 id="五、结论与展望"><a href="#五、结论与展望" class="headerlink" title="五、结论与展望"></a>五、结论与展望</h2><p>&emsp;&emsp;艾默生案例清晰表明了战略规划体系设计和创新对大企业持续发展的重要性及其作用机制。艾默生公司在“管理过程”发展中有效地实现了战略规划体系的“三重创新”：即以“增长计划和赢利评估并重”及“瞻前顾后式”滚动计划为代表的“两栖型”内容创新、以子公司为主体又分工协作的“一体化”组织创新，以及以“最优成本制造”和“赢利瀑布分析”为代表的量身定做的“独特”工具创新。案例分析表明，基于“管理过程”及核心价值观上的战略规划体系创新，促进了艾默生公司在高层战略领导、正式战略规划和子公司领导层的主动性之间的合理平衡，实现了企业战略在增长与赢利、前瞻与学习、制定与执行、普遍与独特等方面的协调和统一，这是艾默生公司近50年来赢利性持续增长的重要驱动因素。可以认为，战略规划体系的“三重创新”是战略规划有效性的一个永恒主题，也是大中型企业在战略思维和行动之间保持有效连接的关键。</p>
<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/艾默生的战略规划创新及其启示/202303031440867-2023-03-06-10-21-31.png" alt="202303031440867-2023-03-06-10-21-31"></p>
<p>&emsp;&emsp;战略规划体系创新需要核心价值观支撑。艾默生的战略规划创新过程说明了其“管理过程”和核心理念的重要性，“保持精简”、“重视计划”、“发挥经理人员的自主性”等基本理念都显著地影响了艾默生的战略规划设计与创新。从这个意义上，“精于心，简于形”可以说是艾默生的规划之道。也许，每个企业的战略规划体系设计模式和经验不能直接复制，但其成功背后的智慧完全可以学习和借鉴。艾默生集团公司的战略规划创新和规划之道，值得中国本土大中型制造企业仔细品味和借鉴。</p>
<p><a href="http://59.252.42.34:6251/Qw/Paper/395094" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>艾默生</tag>
        <tag>企业管理研究</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获得成功</title>
    <url>/2023/03/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p><img src="https://daihuiblog.oss-cn-beijing.aliyuncs.com/picgo/如何获得成功/SamAltman-2023-03-08-11-06-13.jpg" alt="SamAltman"></p>
<blockquote>
<p>本文翻译自<a href="https://baike.baidu.com/item/%E5%B1%B1%E5%A7%86%C2%B7%E9%98%BF%E5%B0%94%E7%89%B9%E6%9B%BC/15957359" target="_blank" rel="noopener">Sam Altman</a>的博客“<a href="https://blog.samaltman.com/how-to-be-successful" target="_blank" rel="noopener">How To Be Successful</a>”</p>
</blockquote>
<p>我观察了成千上万的创始人，并思考了如何才能赚大钱或创造一些重要的东西。通常，人们一开始想要前者，最后想要后者。</p>
<p>这有13个关于如何实现这种异常成功的想法。一旦你达到了一个基准的成功程度（通过特权或努力），并且想投入工作将其转化为异常的成功，这一切都会变得更容易。这大部分适用于任何人。</p>
<p><code>原文：</code></p>
<blockquote>
<p>I’ve observed thousands of founders and thought a lot about what it takes to make a huge amount of money or to create something important. Usually, people start off wanting the former and end up wanting the latter.</p>
<p>Here are 13 thoughts about how to achieve such outlier success. Everything here is easier to do once you’ve already reached a baseline degree of success (through privilege or effort) and want to put in the work to turn that into outlier success. But much of it applies to anyone.</p>
</blockquote>
<a id="more"></a>
<h2 id="1-选择复利增长（Compound-yourself）"><a href="#1-选择复利增长（Compound-yourself）" class="headerlink" title="1.选择复利增长（Compound yourself）"></a>1.选择复利增长（Compound yourself）</h2><p>复利具有神奇的魔力，现在处处都在强调复利，这其中的奥秘就是指数曲线，因为指数曲线是创造财富的关键。</p>
<p>一家中型企业的价值如果按照每年50%的速度增长，那么它的规模可以在短时间内极速扩张。世界上少有企业具有真正的网络效应和高度的可扩展性，但是随着技术进步，这种情况会逐渐改变，这值得我们不断为之努力。</p>
<p>对个体的人生道路来说，我们也应该走成一条指数曲线。也就是说，我们要遵循不断向右增长的人生轨迹。在进行职业规划时，要选择具有复合效应的职业，而大多数职业的发展轨迹都是一条线性直线。</p>
<p>在线性职业领域，工作二十年的效率并不会比工作两年的效率高，像这样的职业不利于个人发展。</p>
<p>我们需要的是一份能保持不断学习的职业。随着职业发展，我们需要产出越来越多的成果。达成这一目标的途径多种多样，比如说资本、技术、品牌、网络效应和做管理。</p>
<p>专注于将你所定义的成功指标增加十倍是有用的，这些指标可以是赚钱、社会地位、世界级影响力或者其他东西。我乐意接受挑战，愿意在各种项目上花时间以解锁下一个项目。但是我希望在每一个项目上都能取得最大成就，创造职业生涯新高度。但是大多数人都被困于线性发展的泥潭，往往捡了芝麻丢了西瓜，我们要学会抓大放小，寻求跳跃式提升。</p>
<p>在我看来，无论是企业还是个人，最大的竞争优势就是要把目标放长远。我们要打开眼界，看出世界上不同体系之间交融互动的方式。复合增长最重要的就是眼光要尽可能放长远，这样的人才能抢占市场先机，获得最大回报。</p>
<p>要相信指数曲线，耐心坚持下去，最后一定会有惊喜。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Compounding is magic. Look for it everywhere. Exponential curves are the key to wealth generation.</p>
<p>A medium-sized business that grows 50% in value every year becomes huge in a very short amount of time. Few businesses in the world have true network effects and extreme scalability. But with technology, more and more will.  It’s worth a lot of effort to find them and create them.</p>
<p>You also want to be an exponential curve yourself—you should aim for your life to follow an ever-increasing up-and-to-the-right trajectory. It’s important to move towards a career that has a compounding effect—most careers progress fairly linearly.</p>
<p>You don’t want to be in a career where people who have been doing it for two years can be as effective as people who have been doing it for twenty—your rate of learning should always be high. As your career progresses, each unit of work you do should generate more and more results. There are many ways to get this leverage, such as capital, technology, brand, network effects, and managing people.</p>
<p>It’s useful to focus on adding another zero to whatever you define as your success metric—money, status, impact on the world, or whatever. I am willing to take as much time as needed between projects to find my next thing. But I always want it to be a project that, if successful, will make the rest of my career look like a footnote.</p>
<p>Most people get bogged down in linear opportunities. Be willing to let small opportunities go to focus on potential step changes.</p>
<p>I think the biggest competitive advantage in business—either for a company or for an individual’s career—is long-term thinking with a broad view of how different systems in the world are going to come together. One of the notable aspects of compound growth is that the furthest out years are the most important. In a world where almost no one takes a truly long-term view, the market richly rewards those who do.</p>
<p>Trust the exponential, be patient, and be pleasantly surprised.</p>
</blockquote>
<h2 id="2-要有绝对自信（Have-almost-too-much-self-belief）"><a href="#2-要有绝对自信（Have-almost-too-much-self-belief）" class="headerlink" title="2.要有绝对自信（Have almost too much self-belief）"></a>2.要有绝对自信（Have almost too much self-belief）</h2><p>自信拥有不可思议的力量，就我认识的人来说，最成功的往往都是那些自信到离谱的人。</p>
<p>我们要尽早树立自信。如果你的判断常常都很准确，能带来很好的结果，那么你一定要加倍自信。</p>
<p>对自己不自信的人很难对未来抱有逆向思维，但是往往逆向思维才能创造出最大的价值。还记得很多年前马斯克带我参观SpaceX工厂，他详细地谈到了制造火箭的一些细节，但是让我印象最深的还是马斯克谈到向火星发射火箭时的表情，离开工厂时我就在想 “啊，这就是自信的样子”。</p>
<p>对大多数创业者来说，激发自己以及团队的士气可以说是最大的挑战之一，如果没有自信，这就成了几乎不可能完成的任务。但往往一个人越有雄心壮志，其受到的打击就会越多。大多数非常成功的人在面对人们的质疑时至少有一次决定是正确的，否则他们面临的挑战会更多。</p>
<p>我们在自信的同时也要保持清醒的自我认知，才能避免盲目自大。我曾经非常讨厌受到批评和质疑，并且总是设法规避这些批评。但现在我开始尝试听取这些意见，我会先设想这些批评是正确的，然后在这个基础上调整我的计划。做决定的过程充满了艰辛和痛苦，但也只有经历了这个过程才能将自信和自欺欺人区分开来。</p>
<p>保持自信与自我认知之间的平衡可以让人免于傲气、避免与他人脱节。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Self-belief is immensely powerful. The most successful people I know believe in themselves almost to the point of delusion.</p>
<p>Cultivate this early. As you get more data points that your judgment is good and you can consistently deliver results, trust yourself more.</p>
<p>If you don’t believe in yourself, it’s hard to let yourself have contrarian ideas about the future. But this is where most value gets created.</p>
<p>I remember when Elon Musk took me on a tour of the SpaceX factory many years ago. He talked in detail about manufacturing every part of the rocket, but the thing that sticks in memory was the look of absolute certainty on his face when he talked about sending large rockets to Mars. I left thinking “huh, so that’s the benchmark for what conviction looks like.”</p>
<p>Managing your own morale—and your team’s morale—is one of the greatest challenges of most endeavors. It’s almost impossible without a lot of self-belief. And unfortunately, the more ambitious you are, the more the world will try to tear you down.  </p>
<p>Most highly successful people have been really right about the future at least once at a time when people thought they were wrong. If not, they would have faced much more competition.</p>
<p>Self-belief must be balanced with self-awareness. I used to hate criticism of any sort and actively avoided it. Now I try to always listen to it with the assumption that it’s true, and then decide if I want to act on it or not. Truth-seeking is hard and often painful, but it is what separates self-belief from self-delusion.</p>
<p>This balance also helps you avoid coming across as entitled and out of touch.</p>
</blockquote>
<h2 id="3-学会独立思考（Learn-to-think-independently）"><a href="#3-学会独立思考（Learn-to-think-independently）" class="headerlink" title="3.学会独立思考（Learn to think independently）"></a>3.学会独立思考（Learn to think independently）</h2><p>创业很难，因为培养原创性思维很难。这种思维在学校里面是学不到的，实际上学校培养的是一种相反的思维方式，所以只能靠我们自己来培养原创性思维。</p>
<p>我们可以从第一性原理(first principles) 出发，从中想出新的点子，然后与人交流沟通，对这些想法进行改良，之后我们再用轻松快捷的方式进行实际测试。</p>
<p>对创业者来说，失败是家常便饭，但我们一定要抱有必胜的信念，要不断尝试、不断试错，只有这样才能得到幸运之神的眷顾。</p>
<p>在这个过程中，最宝贵的经验之一就是，我们要学会在绝境中找到一线生机。我们经历的越多就会越对此深信不疑。要知道勇气来自于多次失败后的坚持不懈。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Entrepreneurship is very difficult to teach because original thinking is very difficult to teach. School is not set up to teach this—in fact, it generally rewards the opposite. So you have to cultivate it on your own.</p>
<p>Thinking from first principles and trying to generate new ideas is fun, and finding people to exchange them with is a great way to get better at this. The next step is to find easy, fast ways to test these ideas in the real world.</p>
<p>“I will fail many times, and I will be really right once” is the entrepreneurs’ way. You have to give yourself a lot of chances to get lucky.</p>
<p>One of the most powerful lessons to learn is that you can figure out what to do in situations that seem to have no solution. The more times you do this, the more you will believe it. Grit comes from learning you can get back up after you get knocked down.</p>
</blockquote>
<h2 id="4-做一个好”销售“（-Get-good-at-“sales”）"><a href="#4-做一个好”销售“（-Get-good-at-“sales”）" class="headerlink" title="4.做一个好”销售“（ Get good at “sales”）"></a>4.做一个好”销售“（ Get good at “sales”）</h2><p>光有自信是不够的，我们还要具备说服他人的能力。</p>
<p>就某种程度来说，所有职业的本质都是销售。你必须向客户、潜在职员、媒体、投资者等宣传兜售你的计划。想要说服他们，首先你的计划要有广阔的发展前景。对于个人而言，你要具备良好的沟通能力、一定的个人魅力以及强大的执行能力。</p>
<p>具备良好的沟通能力十分重要，尤其是书面沟通。在这方面我的建议是：首先要保持思路清晰，然后就是尽量使用简洁明了的语言。</p>
<p>而要做好“销售”最好的方式就是真诚，要对自己推销的产品抱有自信。销售其实无异于其他技能，我们可以通过可以练习提高销售技能。但是出于某些原因（比如人们可能不喜欢销售），很多人认为销售技能不可习得。</p>
<p>做销售的另一个秘诀是:重要的事情要亲力亲为。在刚开始创业时，我非常乐意出差办事，这在很多人看来是不必要的，但是事事亲力亲为却给我带来了三次职业生涯的转折点，如果当时没有选择这样做，我可能会走上另一条道路。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Self-belief alone is not sufficient—you also have to be able to convince other people of what you believe.</p>
<p>All great careers, to some degree, become sales jobs. You have to evangelize your plans to customers, prospective employees, the press, investors, etc. This requires an inspiring vision, strong communication skills, some degree of charisma, and evidence of execution ability.</p>
<p>Getting good at communication—particularly written communication—is an investment worth making. My best advice for communicating clearly is to first make sure your thinking is clear and then use plain, concise language.</p>
<p>The best way to be good at sales is to genuinely believe in what you’re selling. Selling what you truly believe in feels great, and trying to sell snake oil feels awful.</p>
<p>Getting good at sales is like improving at any other skill—anyone can get better at it with deliberate practice. But for some reason, perhaps because it feels distasteful, many people treat it as something unlearnable.</p>
<p>My other big sales tip is to show up in person whenever it’s important. When I was first starting out, I was always willing to get on a plane. It was frequently unnecessary, but three times it led to career-making turning points for me that otherwise would have gone the other way.</p>
</blockquote>
<h2 id="5-要有冒险精神（Make-it-easy-to-take-risks）"><a href="#5-要有冒险精神（Make-it-easy-to-take-risks）" class="headerlink" title="5.要有冒险精神（Make it easy to take risks）"></a>5.要有冒险精神（Make it easy to take risks）</h2><p>大多数人往往都高估了风险低估了回报。冒险对我们来说也很重要，因为人不可能永远不犯错，我们需要不断试错，学习并快速适应。</p>
<p>在职业生涯早期，人们往往更愿意冒险，因为那时你没有什么可失去的东西，但却可能得到很多。一旦一个人履行了自己的基本责任义务，就可以大胆冒险了。我篇幅可以先下小的赌注，如果赌输了会输掉1倍，但如果成功了，则可以赚到100倍。之后我们再沿着这个方向下更大的赌注。</p>
<p>但是要注意不能一直待在舒适圈。在YC，我们从谷歌和脸书长期工作的创始人身上看到了这样一个问题：当人们习惯了舒适的生活、稳定的工作和无论做什么都会取得成功的名气时，就很难将这些置之于身后了（人们总是将他们的生活方式与下一年的工资相匹配）。即使他们真的离开了，也非常有可能再回来。与长期利益相比，短期诱惑和便利往往更具吸引力，也更符合人的天性。</p>
<p>但当你摆脱了这些枯燥无味的工作，你可以跟随直觉将时间花在那些有趣的事情上。而想做到这一点，尽可能长时间地过着朴素灵动的生活是一个很好的方法。当然，任何选择背后都有相应的代价。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Most people overestimate risk and underestimate reward. Taking risks is important because it’s impossible to be right all the time—you have to try many things and adapt quickly as you learn more.</p>
<p>It’s often easier to take risks early in your career; you don’t have much to lose, and you potentially have a lot to gain. Once you’ve gotten yourself to a point where you have your basic obligations covered you should try to make it easy to take risks. Look for small bets you can make where you lose 1x if you’re wrong but make 100x if it works. Then make a bigger bet in that direction.</p>
<p>Don’t save up for too long, though. At YC, we’ve often noticed a problem with founders that have spent a lot of time working at Google or Facebook. When people get used to a comfortable life, a predictable job, and a reputation of succeeding at whatever they do, it gets very hard to leave that behind (and people have an incredible ability to always match their lifestyle to next year’s salary). Even if they do leave, the temptation to return is great. It’s easy—and human nature—to prioritize short-term gain and convenience over long-term fulfillment.  </p>
<p>But when you aren’t on the treadmill, you can follow your hunches and spend time on things that might turn out to be really interesting. Keeping your life cheap and flexible for as long as you can is a powerful way to do this, but obviously comes with tradeoffs.</p>
</blockquote>
<h2 id="6-保持专注（Focus）"><a href="#6-保持专注（Focus）" class="headerlink" title="6.保持专注（Focus）"></a>6.保持专注（Focus）</h2><p>专注可以让我们在工作中取得事半功倍的效果。</p>
<p>磨刀不误砍柴工，在我认识的人中，那些花时间想明白了未来方向的人最后都得到了不错的结果。由此可见，做正确的事比长时间做事更重要。很多人都将自己的时间花在了无关紧要的事情上面。</p>
<p>一旦你想明白了该做什么，就不要犹豫，快速行动起来去完成优先事项。毕竟成功人士就没有执行力弱的。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Focus is a force multiplier on work.</p>
<p>Almost everyone I’ve ever met would be well-served by spending more time thinking about what to focus on. It is much more important to work on the right thing than it is to work many hours. Most people waste most of their time on stuff that doesn’t matter.</p>
<p>Once you have figured out what to do, be unstoppable about getting your small handful of priorities accomplished quickly. I have yet to meet a slow-moving person who is very successful.</p>
</blockquote>
<h2 id="7-努力工作（Work-hard）"><a href="#7-努力工作（Work-hard）" class="headerlink" title="7.努力工作（Work hard）"></a>7.努力工作（Work hard）</h2><p>通过运用自己的聪明才智或者勤奋努力，一个人可以达成工作领域里百分之九十的成就，能做到这一点已经很不错了，但是想要尽量做到完美，达成百分之九十九的成就，那就必须要兼顾聪明与勤奋，因为这一阶段你的竞争者往往是两者兼备的人。</p>
<p>有付出才有收获，付出越多收获也就越大。努力工作可能会造成工作与生活失衡，我完全可以理解有的人选择去更好地平衡工作与生活，在工作中不那么拼命，但是拼命工作确实有很多好处，在多数情况下，努力工作会产生叠加效应，越是成功的人就越能成功。</p>
<p>这通常很有趣。生活中最大的乐趣之一就是找到你的目标，并且有所建树，然后你会发现你在这件事上的影响力比你自己本身更重要。一位YC创始人表示：他在离开一家大公司后，尽力发挥了自己的最大影响力，此时他发现自己变得更快乐、更充实。</p>
<p>为发挥出自己最大影响力而努力工作是值得庆祝的。我完全不能理解为什么在美国某些地区努力工作反而成了一件坏事，但我知道世界其他地区肯定不是这样的，那些地区的企业家表现出来的精力和干劲正在快速成为新的社会标杆。</p>
<p>你必须想出一条平衡之策，在努力工作的同时，又不至于透支身体。对此，虽然人们的应对之策不尽相同，但有条几乎不会出错的黄金准则，那就是与相处愉快的人一起从事喜欢的工作。</p>
<p>我认为，那些假装(在你生命中的某个时期)不用把精力放在工作上，就能平步青云的人，其实是在误人子弟。事实上，判断一个人能否笑到最后的关键因素之一就是工作耐力。</p>
<p>另外，我认为刚入职场时就应该要努力工作。努力工作就像利滚利一样，越早开始，获利时间就越长。一般来说，人们身上背负的责任越少，就越容易施展身手。</p>
<p><code>原文：</code></p>
<blockquote>
<p>You can get to about the 90th percentile in your field by working either smart or hard, which is still a great accomplishment. But getting to the 99th percentile requires both—you will be competing with other very talented people who will have great ideas and be willing to work a lot.</p>
<p>Extreme people get extreme results. Working a lot comes with huge life trade-offs, and it’s perfectly rational to decide not to do it. But it has a lot of advantages. As in most cases, momentum compounds, and success begets success.</p>
<p>And it’s often really fun. One of the great joys in life is finding your purpose, excelling at it, and discovering that your impact matters to something larger than yourself. A YC founder recently expressed great surprise about how much happier and more fulfilled he was after leaving his job at a big company and working towards his maximum possible impact. Working hard at that should be celebrated.  </p>
<p>It’s not entirely clear to me why working hard has become a Bad Thing in certain parts of the US, but this is certainly not the case in other parts of the world—the amount of energy and drive exhibited by entrepreneurs outside of the US is quickly becoming the new benchmark.</p>
<p>You have to figure out how to work hard without burning out. People find their own strategies for this, but one that almost always works is to find work you like doing with people you enjoy spending a lot of time with.</p>
<p>I think people who pretend you can be super successful professionally without working most of the time (for some period of your life) are doing a disservice. In fact, work stamina seems to be one of the biggest predictors of long-term success.</p>
<p>One more thought about working hard: do it at the beginning of your career. Hard work compounds like interest, and the earlier you do it, the more time you have for the benefits to pay off. It’s also easier to work hard when you have fewer other responsibilities, which is frequently but not always the case when you’re young.</p>
</blockquote>
<p>8.大胆一点（Be bold）</p>
<p>在我看来，与轻松创业相比，人们多半会选择更具挑战性的事业。因为后者往往更激动人心，能带来更大的成就感和满足感。</p>
<p>如果你在某个重大问题上取得了进展，就会有源源不断的人前来帮忙。志当存高远，不要害怕去做你真正想做的事情。</p>
<p>如果别人都在创办 meme 公司，而唯独你想创办一家基因编辑公司那就去做吧，不要犹豫。</p>
<p>追随你的好奇心。那些让你感到兴奋的事情，通常也适用于别人。</p>
<p><code>原文：</code><br>I believe that it’s easier to do a hard startup than an easy startup. People want to be part of something exciting and feel that their work matters.</p>
<p>If you are making progress on an important problem, you will have a constant tailwind of people wanting to help you. Let yourself grow more ambitious, and don’t be afraid to work on what you really want to work on.</p>
<p>If everyone else is starting meme companies, and you want to start a gene-editing company, then do that and don’t second guess it.</p>
<p>Follow your curiosity. Things that seem exciting to you will often seem exciting to other people too.</p>
<h2 id="9-足够坚定（Be-willful）"><a href="#9-足够坚定（Be-willful）" class="headerlink" title="9.足够坚定（Be willful）"></a>9.足够坚定（Be willful）</h2><p>很多人都不知道，只要你足够坚持，世界就会以你的意志为转移。但大多数人甚至都不会去尝试，只单纯认为世界有其自身的运作规律。</p>
<p>人的潜力是巨大的，只要敢想就能做成很多事。但大多数人都会怀疑自我、过早放弃，同时又不够努力，种种原因导致大多数人无法充分发挥自身潜能。</p>
<p>询问自身诉求，你通常不能得偿所愿，而且被拒绝的滋味往往不好受。但若一旦成功，效果就会好得出奇。</p>
<p>那些声称“我将永不言弃，直到梦想成真，不论前方有多少艰难险阻，我也会迎难而上”，并将其付诸行动的人，最后几乎总能获得成功。因为他们坚持了足够久，所以最终迎来了幸运之神的眷顾。</p>
<p>在这方面，爱彼迎 (Airbnb)是我认为的行动标杆。业内流传着许多有关爱彼迎的逸闻趣事，虽然我并不推崇他们的做法(比如透支信用卡、每顿都吃一元店买的麦片、乐此不疲地与强劲的对手进行较量等等) 但是正因为他们足够坚持，最后终于时来运转。</p>
<p>只有保持乐观才能足够坚定，而乐观这种性格特征是可以通过练习逐步提升的，而悲观者是很难成功的。</p>
<p><code>原文：</code></p>
<blockquote>
<p>A big secret is that you can bend the world to your will a surprising percentage of the time—most people don’t even try, and just accept that things are the way that they are.</p>
<p>People have an enormous capacity to make things happen. A combination of self-doubt, giving up too early, and not pushing hard enough prevents most people from ever reaching anywhere near their potential.</p>
<p>Ask for what you want. You usually won’t get it, and often the rejection will be painful. But when this works, it works surprisingly well.</p>
<p>Almost always, the people who say “I am going to keep going until this works, and no matter what the challenges are I’m going to figure them out”, and mean it, go on to succeed. They are persistent long enough to give themselves a chance for luck to go their way.</p>
<p>Airbnb is my benchmark for this. There are so many stories they tell that I wouldn’t recommend trying to reproduce (keeping maxed-out credit cards in those nine-slot three-ring binder pages kids use for baseball cards, eating dollar store cereal for every meal, battle after battle with powerful entrenched interest, and on and on) but they managed to survive long enough for luck to go their way.</p>
<p>To be willful, you have to be optimistic—hopefully this is a personality trait that can be improved with practice. I have never met a very successful pessimistic person.</p>
</blockquote>
<h2 id="10-保持强劲的市场竞争力（Be-hard-to-compete-with）"><a href="#10-保持强劲的市场竞争力（Be-hard-to-compete-with）" class="headerlink" title="10.保持强劲的市场竞争力（Be hard to compete with）"></a>10.保持强劲的市场竞争力（Be hard to compete with）</h2><p>大多数人都明白，企业竞争力越强，价值就越高。这点至关重要，而且也是显而易见的。这同样也适用于个人。如果你所从事的工作具有可替代性，那么你最终就会被薪资要求更低的人所取代。</p>
<p>增强竞争力的最佳方式就是建立话语权。例如，你可以利用好个人关系，打造强大的个人品牌，或是在不同领域的交叉点建立起自己的个人优势。当然增强竞争力的方式还有很多但不论采取什么方式，关键是你必须要做到这一点。</p>
<p>大多数人会模仿身边人的做法，但这种方式并不可取，如果一味模仿他人，那你还有什么竞争优势可言呢？</p>
<p><code>原文：</code></p>
<blockquote>
<p>Most people understand that companies are more valuable if they are difficult to compete with. This is important, and obviously true.</p>
<p>But this holds true for you as an individual as well. If what you do can be done by someone else, it eventually will be, and for less money.</p>
<p>The best way to become difficult to compete with is to build up leverage. For example, you can do it with personal relationships, by building a strong personal brand, or by getting good at the intersection of multiple different fields. There are many other strategies, but you have to figure out some way to do it.</p>
<p>Most people do whatever most people they hang out with do. This mimetic behavior is usually a mistake—if you’re doing the same thing everyone else is doing, you will not be hard to compete with.</p>
</blockquote>
<h2 id="11-建立人际网络（Build-a-network）"><a href="#11-建立人际网络（Build-a-network）" class="headerlink" title="11.建立人际网络（Build a network）"></a>11.建立人际网络（Build a network）</h2><p>出色的工作需要团队合作。打造既可密切合作又可轻松相处的优质人际网络是事业成功的必要因素。拥有优秀人才的人际网络的规模会决定你能成功的上限。</p>
<p>建立人际网络的有效方法之一是尽可能多帮助他人。长期以来，这种行为方式给我带来了最佳职场机遇以及四项最佳投资中的三项。我总是惊讶与发生在自己身上的意外之喜，仅仅因为我十年前曾帮助过一位企业创始人。</p>
<p>建立人际网络的另一个途径是拥有好的名声，不亏待每一个一起共事的人。要大方慷慨地与他人分享资源，这会给你带来10倍、100倍的回报。此外，要知人善用，让每个人都能充分施展自己的才华。</p>
<p>我们既要尽力挖掘他人的潜力但是又不能逼得太紧，这容易让人感到精疲力尽。每个人都有各自擅长的领域，因此，我们要多看看自己的优点，不要总盯着缺点，要用优点来定义自身。面对缺点，我们要承认它，想办法弥补它，不要让缺点成为我们前进路上的阻碍。我常能在一些创业者口中听到这样的说法“我不能做A，因为我不擅长B”。这种思维方式让我十分吃惊。这反映出他们缺乏创造力。弥补弱点的最佳方式是聘请互补的团队成员，而不是雇佣那些跟你擅长相同事情的人。</p>
<p>慧眼识珠挖掘未被发掘的人才是建立人际网络的有效途径。通过练习，我们能快速识别那些优质有动力、有创造力的人才。挖掘人才最简单的方式就是多社交，多与他人打交道并且与那些给你留下深刻印象的人保持联系。要记住一点，不要局限于他人过往的工作经验和当前成就，我们需要发掘那些有潜力且能在短时间激发潜能的人。</p>
<p>每当遇到新人，我都会扪心自问“这个人有异于常人的能力吗？”对于渴求人才的人来说，这个问题很值得思考。</p>
<p>建立人际网络的特例是找到你生命中的贵人，特别是在职业生涯早期。毫无疑问，能做到这点的最佳方法就是主动去帮助他人（记住，你必须在日后回报你的贵人！）</p>
<p>最后，我们要结交那些积极向上且志同道合之人。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Great work requires teams. Developing a network of talented people to work with—sometimes closely, sometimes loosely—is an essential part of a great career. The size of the network of really talented people you know often becomes the limiter for what you can accomplish.</p>
<p>An effective way to build a network is to help people as much as you can. Doing this, over a long period of time, is what lead to most of my best career opportunities and three of my four best investments. I’m continually surprised how often something good happens to me because of something I did to help a founder ten years ago.</p>
<p>One of the best ways to build a network is to develop a reputation for really taking care of the people who work with you. Be overly generous with sharing the upside; it will come back to you 10x. Also, learn how to evaluate what people are great at, and put them in those roles. (This is the most important thing I have learned about management, and I haven’t read much about it.) You want to have a reputation for pushing people hard enough that they accomplish more than they thought they could, but not so hard they burn out.</p>
<p>Everyone is better at some things than others. Define yourself by your strengths, not your weaknesses. Acknowledge your weaknesses and figure out how to work around them, but don’t let them stop you from doing what you want to do. “I can’t do X because I’m not good at Y” is something I hear from entrepreneurs surprisingly often, and almost always reflects a lack of creativity. The best way to make up for your weaknesses is to hire complementary team members instead of just hiring people who are good at the same things you are.</p>
<p>A particularly valuable part of building a network is to get good at discovering undiscovered talent. Quickly spotting intelligence, drive, and creativity gets much easier with practice. The easiest way to learn is just to meet a lot of people, and keep track of who goes on to impress you and who doesn’t. Remember that you are mostly looking for rate of improvement, and don’t overvalue experience or current accomplishment.</p>
<p>I try to always ask myself when I meet someone new “is this person a force of nature?” It’s a pretty good heuristic for finding people who are likely to accomplish great things.</p>
<p>A special case of developing a network is finding someone eminent to take a bet on you, ideally early in your career. The best way to do this, no surprise, is to go out of your way to be helpful. (And remember that you have to pay this forward at some point later!)</p>
<p>Finally, remember to spend your time with positive people who support your ambitions.</p>
</blockquote>
<h2 id="12-资产决定财富（You-get-rich-by-owning-things）"><a href="#12-资产决定财富（You-get-rich-by-owning-things）" class="headerlink" title="12.资产决定财富（You get rich by owning things）"></a>12.资产决定财富（You get rich by owning things）</h2><p>小时候，我对经济的最大误解就是人们通过高薪发财致富。虽然也有一些特例，比如说娱乐圈的艺人，但从以往的福布斯榜单来看，几乎没有人是靠高薪荣登榜单的。</p>
<p>拥有能迅速增值的东西才能真正发家致富。这些东西可以是商业资产、不动产、自然资源、知识产权等。但无论怎样，你需要实际拥有一些东西，而不是单靠出卖时间赚取工资，出卖时间赢来的财富只会呈慢速线性增长。</p>
<p>让事物迅速增值的最佳方法就是大量制造人们想要的东西。</p>
<p><code>原文：</code></p>
<blockquote>
<p>The biggest economic misunderstanding of my childhood was that people got rich from high salaries. Though there are some exceptions—entertainers for example —almost no one in the history of the Forbes list has gotten there with a salary.</p>
<p>You get truly rich by owning things that increase rapidly in value.</p>
<p>This can be a piece of a business, real estate, natural resource, intellectual property, or other similar things. But somehow or other, you need to own equity in something, instead of just selling your time. Time only scales linearly.</p>
<p>The best way to make things that increase rapidly in value is by making things people want at scale.</p>
</blockquote>
<h2 id="13-要有内驱力（Be-internally-driven）"><a href="#13-要有内驱力（Be-internally-driven）" class="headerlink" title="13.要有内驱力（Be internally driven）"></a>13.要有内驱力（Be internally driven）</h2><p>大多数人主要都是靠外部驱动，他们做事情是为了让别人佩服。这种做法坏处颇多，但以下两点最为突出：</p>
<p>首先这会导致你人云亦云，因循守旧。在工作中，你会过于在意他人的看法，这种在意程度可能已经远远超出了你的意识，并且这会阻碍你从事趣味性工作，即使你正在做这样的工作，也不过是在炒冷饭。</p>
<p>其次，这会让你误判风险等级。从短期影响来看，你会将注意力主要放在和他人的竞争上，以确保不会在竞争游戏中落后。</p>
<p>聪明人似乎更容易受到这种外驱力的影响。了解到了这一点可以帮助你摆脱这种影响，但帮助不大，我们必须要极其谨慎才能不至于掉入模仿他人的陷阱中。</p>
<p>我认识的大多数成功人士都是靠自我驱动。他们做事情是为了让自己心悦诚服，因为他们觉得给世界带来改变是自己的责任。当你赚得盆满钵满并且拥有了较高的社会地位之后，金钱和名誉对你的吸引力开始逐渐消失，这时候内驱力就成为了唯一的动力，推动你向更高的地方攀登。</p>
<p>这就是驱动力重要性的体现。驱动力是我了解他人时最先考察的点。我们很难用一套规则去定义正确的驱动力，但是当你遇到它时立刻就能有所体会。在这件事上，Jessica Livingston和Paul Graham是我认为的行动标杆。在YC创办的最初几年，人人都不看好它的发展，没有人认为YC能够成功。但是杰西卡和保罗很看好YC的发展，他们认为如果YC能够成功，将会对世界大有裨益，他们希望能够借此帮助到其他人，并且坚信这种新模式比现存的模式好。</p>
<p>最终你会发现成功是在自己看重的领域里做出出色的成绩。向着自己热爱的方向越早出发就能走得越远，没有热爱之事的人是很难取得成就的。</p>
<p><code>原文：</code></p>
<blockquote>
<p>Most people are primarily externally driven; they do what they do because they want to impress other people. This is bad for many reasons, but here are two important ones.</p>
<p>First, you will work on consensus ideas and on consensus career tracks.  You will care a lot—much more than you realize—if other people think you’re doing the right thing. This will probably prevent you from doing truly interesting work, and even if you do, someone else would have done it anyway.</p>
<p>Second, you will usually get risk calculations wrong. You’ll be very focused on keeping up with other people and not falling behind in competitive games, even in the short term.</p>
<p>Smart people seem to be especially at risk of such externally-driven behavior. Being aware of it helps, but only a little—you will likely have to work super-hard to not fall in the mimetic trap.</p>
<p>The most successful people I know are primarily internally driven; they do what they do to impress themselves and because they feel compelled to make something happen in the world. After you’ve made enough money to buy whatever you want and gotten enough social status that it stops being fun to get more, this is the only force I know of that will continue to drive you to higher levels of performance.</p>
<p>This is why the question of a person’s motivation is so important. It’s the first thing I try to understand about someone. The right motivations are hard to define a set of rules for, but you know it when you see it.</p>
<p>Jessica Livingston and Paul Graham are my benchmarks for this. YC was widely mocked for the first few years, and almost no one thought it would be a big success when they first started. But they thought it would be great for the world if it worked, and they love helping people, and they were convinced their new model was better than the existing model.</p>
<p>Eventually, you will define your success by performing excellent work in areas that are important to you. The sooner you can start off in that direction, the further you will be able to go. It is hard to be wildly successful at anything you aren’t obsessed with.</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Sam Altman</tag>
        <tag>成功</tag>
      </tags>
  </entry>
</search>
