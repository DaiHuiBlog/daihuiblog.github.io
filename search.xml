<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker命令大全整理</title>
    <url>/2019/04/24/Docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/Docker命令大全整理/1.jpg" alt="image1"></p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong><a href="#rqsmzqgl">容器生命周期管理</a></strong></p>
<ul>
<li><a href="#run">run</a></li>
<li><a href="#ssr">start/stop/restart</a></li>
<li><a href="#kill">kill</a>∏</li>
<li><a href="#rm">rm</a></li>
<li><a href="#pu">pause/unpause</a></li>
<li><a href="#create">create</a></li>
<li><a href="#exec">exec</a></li>
</ul>
<p><strong><a href="#rqcz">容器操作</a></strong></p>
<ul>
<li><a href="#ps">ps</a></li>
<li><a href="#inspect">inspect</a></li>
<li><a href="#top">top</a></li>
<li><a href="#attach">attach</a></li>
<li><a href="#events">events</a></li>
<li><a href="#logs">logs</a></li>
<li><a href="#wait">wait</a></li>
<li><a href="#export">export</a></li>
<li><a href="#port">port</a></li>
</ul>
<p><strong><a href="#rqrootfsml">容器rootfs命令</a></strong></p>
<ul>
<li><a href="#commit">commit</a></li>
<li><a href="#cp">cp</a></li>
<li><a href="#diff">diff</a></li>
</ul>
<p><strong><a href="#jxck">镜像仓库</a></strong></p>
<ul>
<li><a href="#login">login</a></li>
<li><a href="#pull">pull</a></li>
<li><a href="#push">push</a></li>
<li><a href="#search">search</a></li>
</ul>
<p><strong><a href="#bdjxgl">本地镜像管理</a></strong></p>
<ul>
<li><a href="#images">images</a></li>
<li><a href="#rmi">rmi</a></li>
<li><a href="#tag">tag</a></li>
<li><a href="#build">build</a></li>
<li><a href="#history">history</a></li>
<li><a href="#save">save</a></li>
<li><a href="#import">import</a></li>
</ul>
<p><strong><a href="#infoversion">info|version</a></strong></p>
<ul>
<li><a href="#info">info</a></li>
<li><a href="#version">version</a></li>
</ul>
<hr>
<h2 id="rqsmzqgl">容器生命周期管理</h2>

<h3 id="run">Docker run 命令</h3>

<p><strong>docker run :</strong> 创建一个新的容器并运行一个命令</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p>
</li>
<li><p>-d: 后台运行容器，并返回容器ID；</p>
</li>
<li><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p>
</li>
<li><p>-p: 端口映射，格式为：主机(宿主)端口:容器端口 </p>
</li>
<li><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
</li>
<li><p>–name=”nginx-lb”: 为容器指定一个名称；</p>
</li>
<li><p>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</p>
</li>
<li><p>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</p>
</li>
<li><p>-h “mars”: 指定容器的hostname；</p>
</li>
<li><p>-e username=”ritchie”: 设置环境变量；</p>
</li>
<li><p>–env-file=[]: 从指定文件读入环境变量；</p>
</li>
<li><p>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</p>
</li>
<li><p>-m :设置容器使用内存最大值；</p>
</li>
<li><p>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p>
</li>
<li><p>–link=[]: 添加链接到另一个容器；</p>
</li>
<li><p>–expose=[]: 开放一个端口或一组端口；</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>
<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure>
<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@b8573233d675:/#</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="ssr">Docker start/stop/restart 命令</h3>

<p><strong>docker start :</strong> 启动一个或多个已经被停止的容器</p>
<p><strong>docker stop :</strong> 停止一个运行中的容器</p>
<p><strong>docker restart :</strong> 重启容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker start [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<blockquote>
<p>docker stop [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<blockquote>
<p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>启动已被停止的容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start myrunoob</span><br></pre></td></tr></table></figure>
<p>停止运行中的容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop myrunoob</span><br></pre></td></tr></table></figure>
<p>重启容器myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="kill">Docker kill 命令</h3>

<p><strong>docker kill</strong> :杀掉一个运行中的容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-s :向容器发送一个信号</li>
</ul>
<p><strong>实例</strong></p>
<p>杀掉运行中的容器nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daihui@daihuideMBP:~$ docker kill -s KILL nginx</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="rm">Docker rm 命令</h3>

<p><strong>docker rm ：</strong> 删除一个或多少容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-f :通过SIGKILL信号强制删除一个运行中的容器</p>
</li>
<li><p>-l :移除容器间的网络连接，而非容器本身</p>
</li>
<li><p>-v :-v 删除与容器关联的卷</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>强制删除容器db01、db02</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure>
<p>移除容器nginx01对容器db01的连接，连接名db</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure>
<p>删除容器nginx01,并删除容器挂载的数据卷</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pu">Docker pause/unpause 命令</h3>

<p><strong>docker pause :</strong> 暂停容器中所有的进程</p>
<p><strong>docker unpause :</strong> 恢复容器中所有的进程</p>
<p><strong>语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>暂停数据库容器db01提供服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pause db01</span><br></pre></td></tr></table></figure>
<p>恢复数据库容器db01提供服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="create">Docker create 命令</h3>

<p><strong>docker create ：</strong> 创建一个新的容器但不启动它</p>
<p>用法同 <a href="#run">docker run</a></p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker create [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
</blockquote>
<p>语法同 <a href="#run">docker run</a></p>
<p><strong>实例</strong></p>
<p>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      </span><br><span class="line">09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961e</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="exec">Docker exec 命令</h3>

<p><strong>docker exec ：</strong> 在运行的容器中执行命令</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-d :分离模式: 在后台运行</p>
</li>
<li><p>-i :即使没有附加也保持STDIN 打开</p>
</li>
<li><p>-t :分配一个伪终端</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">http://www.runoob.com/</span><br></pre></td></tr></table></figure>
<p>在容器 mynginx 中开启一个交互模式的终端:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash</span><br><span class="line">root@b1a0703e41e7:/#</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>docker ps -a</code> 命令查看已经在运行的容器，然后使用容器 ID 进入容器。</p>
<p>查看已经在运行的容器 ID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> docker ps -a </span><br><span class="line">...</span><br><span class="line">9df70f9a0714     openjdk        "/usercode/script.sh…" </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第一列的 9df70f9a0714 就是容器 ID</p>
<p>通过 exec 命令对指定的容器执行 bash:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> docker exec -it 9df70f9a0714 /bin/bash</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rqcz">容器操作</h2>

<h3 id="ps">Docker ps 命令</h3>

<p><strong>docker ps :</strong> 列出容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker ps [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-a :显示所有的容器，包括未运行的。</li>
<li>-f :根据条件过滤显示的内容。</li>
<li>–format :指定返回值的模板文件。</li>
<li>-l :显示最近创建的容器。</li>
<li>-n :列出最近创建的n个容器。</li>
<li>–no-trunc :不截断输出。</li>
<li>-q :静默模式，只显示容器编号。</li>
<li>-s :显示总的文件大小。</li>
</ul>
<p><strong>实例</strong></p>
<p>列出所有在运行的容器信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   "nginx -g 'daemon off" ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line">96f7f14e99ab   mysql:5.6      "docker-entrypoint.sh" ...  0.0.0.0:3306-&amp;gt;3306/tcp   mymysql</span><br></pre></td></tr></table></figure>
<p>列出最近创建的5个容器信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        "nginx -g 'daemon off"    2 days ago   ...     </span><br><span class="line">b8573233d675        nginx:latest        "/bin/bash"               2 days ago   ...     </span><br><span class="line">b1a0703e41e7        nginx:latest        "nginx -g 'daemon off"    2 days ago   ...    </span><br><span class="line">f46fb1dec520        5c6e1090e771        "/bin/sh -c 'set -x \t"   2 days ago   ...   </span><br><span class="line">a63b4a5597de        860c279d2fec        "bash"                    2 days ago   ...</span><br></pre></td></tr></table></figure>
<p>列出所有创建的容器ID。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -a -q</span><br><span class="line">09b93464c2f7</span><br><span class="line">b8573233d675</span><br><span class="line">b1a0703e41e7</span><br><span class="line">f46fb1dec520</span><br><span class="line">a63b4a5597de</span><br><span class="line">6a4aa42e947b</span><br><span class="line">de7bb36e7968</span><br><span class="line">43a432b73776</span><br><span class="line">664a8ab1a585</span><br><span class="line">ba52eb632bbd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="inspect">Docker inspect 命令</h3>


<p><strong>docker inspect :</strong> 获取容器/镜像的元数据</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker inspect [OPTIONS] NAME|ID [NAME|ID…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件</li>
<li>-s :显示总的文件大小</li>
<li>–type :为指定类型返回JSON</li>
</ul>
<p><strong>实例</strong></p>
<p>获取镜像mysql:5.6的元信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        "Id": "sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec",</span><br><span class="line">        "RepoTags": [</span><br><span class="line">            "mysql:5.6"</span><br><span class="line">        ],</span><br><span class="line">        "RepoDigests": [],</span><br><span class="line">        "Parent": "",</span><br><span class="line">        "Comment": "",</span><br><span class="line">        "Created": "2016-05-24T04:01:41.168371815Z",</span><br><span class="line">        "Container": "e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54",</span><br><span class="line">        "ContainerConfig": &#123;</span><br><span class="line">            "Hostname": "b0cf605c7757",</span><br><span class="line">            "Domainname": "",</span><br><span class="line">            "User": "",</span><br><span class="line">            "AttachStdin": false,</span><br><span class="line">            "AttachStdout": false,</span><br><span class="line">            "AttachStderr": false,</span><br><span class="line">            "ExposedPorts": &#123;</span><br><span class="line">                "3306/tcp": &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>获取正在运行的容器mymysql的 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="top">Docker top 命令</h3>

<p><strong>docker top :</strong> 查看容器中运行的进程信息，支持 ps 命令参数</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker top [OPTIONS] CONTAINER [ps OPTIONS]</p>
</blockquote>
<p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p>
<p><strong>实例</strong></p>
<p>查看容器mymysql的进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker top mymysql</span><br><span class="line">UID    PID    PPID    C      STIME   TTY  TIME       CMD</span><br><span class="line">999    40347  40331   18     00:58   ?    00:00:02   mysqld</span><br></pre></td></tr></table></figure>
<p>查看所有运行容器的进程信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in  `docker ps |grep Up|awk '&#123;print $1&#125;'`;do echo \ &amp;amp;&amp;amp;docker top $i; done</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="attach">Docker attach 命令</h3>

<p><strong>docker attach :</strong> 连接到正在运行中的容器</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker attach [OPTIONS] CONTAINER</p>
</blockquote>
<p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。<br>官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上–sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。</p>
<p><strong>实例</strong></p>
<p>容器mynginx将访问日志指到标准输出，连接到容器查看访问信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker attach --sig-proxy=false mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:54:26 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="events">Docker events 命令</h3>

<p>docker events : 从服务器获取实时事件</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker events [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f ：根据条件过滤事件；</li>
<li>–since ：从指定的时间戳后显示所有事件；</li>
<li>–until ：流水时间显示到指定的时间为止；</li>
</ul>
<p><strong>实例</strong></p>
<p>显示docker 2016年7月1日后的所有事件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker events  --since="1467302400"</span><br><span class="line">2016-07-08T19:44:54.501277677+08:00 network connect 66f958fd13dc4314ad20034e576d5c5eba72e0849dcc38ad9e8436314a4149d4 (container=b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64, name=bridge, type=bridge)</span><br><span class="line">2016-07-08T19:44:54.723876221+08:00 container start b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (image=nginx:latest, name=elegant_albattani)</span><br><span class="line">2016-07-08T19:44:54.726110498+08:00 container resize b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (height=39, image=nginx:latest, name=elegant_albattani, width=167)</span><br><span class="line">2016-07-08T19:46:22.137250899+08:00 container die b8573233d675705df8c89796a2c2687cd8e36e03646457a15fb51022db440e64 (exitCode=0, image=nginx:latest, name=elegant_albattani)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>显示docker 镜像为mysql:5.6 2016年7月1日后的相关事件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~/mysql$ docker events -f "image"="mysql:5.6" --since="1467302400" </span><br><span class="line">2016-07-11T00:38:53.975174837+08:00 container start 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.022572452+08:00 container kill 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql, signal=9)</span><br><span class="line">2016-07-11T00:51:17.132532080+08:00 container die 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (exitCode=137, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:51:17.514661357+08:00 container destroy 96f7f14e99ab9d2f60943a50be23035eda1623782cc5f930411bbea407a2bb10 (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.551984549+08:00 container create c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.557405864+08:00 container attach c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:18.844134112+08:00 container start c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:57:19.140141428+08:00 container die c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (exitCode=1, image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:05.941019136+08:00 container destroy c8f0a32f12f5ec061d286af0b1285601a3e33a90a08ff1706de619ac823c345c (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:07.965128417+08:00 container create a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:08.188734598+08:00 container start a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T00:58:20.010876777+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br><span class="line">2016-07-11T01:06:01.395365098+08:00 container top a404c6c174a21c52f199cfce476e041074ab020453c7df2a13a7869b48f2f37e (image=mysql:5.6, name=mymysql)</span><br></pre></td></tr></table></figure>
<p>如果指定的时间是到秒级的，需要将时间转成时间戳。如果时间为日期的话，可以直接使用，如–since=”2017-07-01”</p>
<hr>
<h3 id="logs">Docker logs 命令</h3>

<p><strong>docker logs :</strong> 获取容器的日志</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker logs [OPTIONS] CONTAINER</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<p><strong>实例</strong></p>
<p>跟踪查看容器mynginx的日志输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">2016/07/10 16:53:33 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.239.130", referrer: "http://192.168.239.130/"</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] "GET /favicon.ico HTTP/1.1" 404 571 "http://192.168.239.130/" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] "GET / HTTP/1.1" 304 0 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36" "-"</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看容器mynginx从2016年7月1日后的最新10条日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs --since="2016-07-01" --tail=10 mynginx</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="wait">Docker wait 命令</h3>


<p><strong>docker wait :</strong> 阻塞运行直到容器停止，然后打印出它的退出代码</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker wait [OPTIONS] CONTAINER [CONTAINER…]</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker wait CONTAINER</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="export">Docker export 命令</h3>

<p><strong>docker export :</strong> 将文件系统作为一个tar归档文件导出到STDOUT</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker export [OPTIONS] CONTAINER</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-o :将输入内容写到文件。</li>
</ul>
<p><strong>实例</strong></p>
<p>将id为a404c6c174a2的容器按日期保存为tar文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2</span><br><span class="line">runoob@runoob:~$ ls mysql-`date +%Y%m%d`.tar</span><br><span class="line">mysql-20160711.tar</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="port">Docker port 命令</h3>

<p><strong>docker port :</strong> 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看容器mynginx的端口映射情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker port mymysql</span><br><span class="line">3306/tcp -&gt; 0.0.0.0:3306</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rqrootfsml">容器rootfs命令</h2>

<h3 id="commit">Docker commit 命令</h3>

<p><strong>docker commit :</strong> 从容器创建一个新的镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a :提交的镜像作者；</p>
</li>
<li><p>-c :使用Dockerfile指令来创建镜像；</p>
</li>
<li><p>-m :提交时的说明文字；</p>
</li>
<li><p>-p :在commit时，将容器暂停</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker commit -a "runoob.com" -m "my apache" a404c6c174a2  mymysql:v1 </span><br><span class="line">sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057</span><br><span class="line">runoob@runoob:~$ docker images mymysql:v1</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql             v1                  37af1236adef        15 seconds ago      329 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="cp">Docker cp 命令</h3>

<p><strong>docker cp :</strong> 用于容器与主机之间的数据拷贝</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</p>
</blockquote>
<blockquote>
<p>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-L :保持源目标中的链接</li>
</ul>
<p><strong>实例</strong></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br></pre></td></tr></table></figure>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="diff">Docker diff 命令</h3>

<p><strong>docker diff :</strong> 检查容器里文件结构的更改</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker diff [OPTIONS] CONTAINER</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看容器mymysql的文件结构更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker diff mymysql</span><br><span class="line">A /logs</span><br><span class="line">A /mysql_data</span><br><span class="line">C /run</span><br><span class="line">C /run/mysqld</span><br><span class="line">A /run/mysqld/mysqld.pid</span><br><span class="line">A /run/mysqld/mysqld.sock</span><br><span class="line">C /tmp</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="jxck">镜像仓库</h2>

<h3 id="login">Docker login 命令</h3>

<p><strong>docker login :</strong> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>
<p><strong>docker logout :</strong> 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker login [OPTIONS] [SERVER]</p>
</blockquote>
<blockquote>
<p>docker logout [OPTIONS] [SERVER]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-u :登陆的用户名</p>
</li>
<li><p>-p :登陆的密码</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>登陆到Docker Hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码</span><br></pre></td></tr></table></figure>
<p>登出Docker Hub</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logout</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="pull">Docker pull 命令</h3>

<p><strong>docker pull :</strong> 从镜像仓库中拉取或者更新指定镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-a :拉取所有 tagged 镜像</p>
</li>
<li><p>–disable-content-trust :忽略镜像的校验,默认开启</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>从Docker Hub下载java最新版镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure>
<p>从Docker Hub下载REPOSITORY为java的所有镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="push">Docker push 命令</h3>

<p><strong>docker push :</strong> 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker push [OPTIONS] NAME[:TAG]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<p><strong>实例</strong></p>
<p>上传本地镜像myapache:v1到镜像仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push myapache:v1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="search">Docker search 命令</h3>

<p><strong>docker search :</strong> 从Docker Hub查找镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker search [OPTIONS] TERM</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>–automated :只列出 automated build类型的镜像；</p>
</li>
<li><p>–no-trunc :显示完整的镜像描述；</p>
</li>
<li><p>-s :列出收藏数不小于指定值的镜像。</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker search -s 10 java</span><br><span class="line">NAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATED</span><br><span class="line">java                  Java is a concurrent, class-based...   1037    [OK]       </span><br><span class="line">anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]</span><br><span class="line">develar/java                                                 46                 [OK]</span><br><span class="line">isuper/java-oracle    This repository contains all java...   38                 [OK]</span><br><span class="line">lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]</span><br><span class="line">nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="bdjxgl">本地镜像管理</h2>

<h3 id="images">Docker images 命令</h3>

<p><strong>docker images :</strong> 列出本地镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker images [OPTIONS] [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>
<li>–digests :显示镜像的摘要信息；</li>
<li>-f :显示满足条件的镜像；</li>
<li>–format :指定返回值的模板文件；</li>
<li>–no-trunc :显示完整的镜像信息；</li>
<li>-q :只显示镜像ID。</li>
</ul>
<p><strong>实例</strong></p>
<p>查看本地镜像列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mymysql                 v1                  37af1236adef        5 minutes ago       329 MB</span><br><span class="line">runoob/ubuntu           v4                  1c06aa18edee        2 days ago          142.1 MB</span><br><span class="line">&amp;lt;none&amp;gt;                  &amp;lt;none&amp;gt;              5c6e1090e771        2 days ago          165.9 MB</span><br><span class="line">httpd                   latest              ed38aaffef30        11 days ago         195.1 MB</span><br><span class="line">alpine                  latest              4e38e38c8ce0        2 weeks ago         4.799 MB</span><br><span class="line">mongo                   3.2                 282fd552add6        3 weeks ago         336.1 MB</span><br><span class="line">redis                   latest              4465e4bcad80        3 weeks ago         185.7 MB</span><br><span class="line">php                     5.6-fpm             025041cd3aa5        3 weeks ago         456.3 MB</span><br><span class="line">python                  3.5                 045767ddf24a        3 weeks ago         684.1 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>列出本地镜像中REPOSITORY为ubuntu的镜像列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker images  ubuntu</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               90d5884b1ee0        9 weeks ago         188 MB</span><br><span class="line">ubuntu              15.10               4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="rmi">Docker rmi 命令</h3>

<p><strong>docker rmi :</strong> 删除本地一个或多少镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker rmi [OPTIONS] IMAGE [IMAGE…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li><p>-f :强制删除；</p>
</li>
<li><p>–no-prune :不移除该镜像的过程镜像，默认移除；</p>
</li>
</ul>
<p><strong>实例</strong></p>
<p>强制删除本地镜像runoob/ubuntu:v4。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker rmi -f runoob/ubuntu:v4</span><br><span class="line">Untagged: runoob/ubuntu:v4</span><br><span class="line">Deleted: sha256:1c06aa18edee44230f93a90a7d88139235de12cd4c089d41eed8419b503072be</span><br><span class="line">Deleted: sha256:85feb446e89a28d58ee7d80ea5ce367eebb7cec70f0ec18aa4faa874cbd97c73</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="tag">Docker tag 命令</h3>

<p><strong>docker tag :</strong> 标记本地镜像，将其归入某一仓库</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>将镜像ubuntu:15.10标记为 runoob/ubuntu:v3 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker tag ubuntu:15.10 runoob/ubuntu:v3</span><br><span class="line">root@runoob:~# docker images   runoob/ubuntu:v3</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v3                  4e3b13c8a266        3 months ago        136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="build">Docker build 命令</h3>

<p><strong>docker build</strong> 命令用于使用 Dockerfile 创建镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker build [OPTIONS] PATH | URL | -</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>–build-arg=[] :设置镜像创建时的变量；</li>
<li>–cpu-shares :设置 cpu 使用权重；</li>
<li>–cpu-period :限制 CPU CFS周期；</li>
<li>–cpu-quota :限制 CPU CFS配额；</li>
<li>–cpuset-cpus :指定使用的CPU id；</li>
<li>–cpuset-mems :指定使用的内存 id；</li>
<li>–disable-content-trust :忽略校验，默认开启；</li>
<li>-f :指定要使用的Dockerfile路径；</li>
<li>–force-rm :设置镜像过程中删除中间容器；</li>
<li>–isolation :使用容器隔离技术；</li>
<li>–label=[] :设置镜像使用的元数据；</li>
<li>-m :设置内存最大值；</li>
<li>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>
<li>–no-cache :创建镜像的过程不使用缓存；</li>
<li>–pull :尝试去更新镜像的新版本；</li>
<li>–quiet, -q :安静模式，成功后只输出镜像 ID；</li>
<li>–rm :设置镜像成功后删除中间容器；</li>
<li>–shm-size :设置/dev/shm的大小，默认值是64M；</li>
<li>–ulimit :Ulimit配置。</li>
<li>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>
<li>–network: 默认 default。在构建期间设置RUN指令的网络模式</li>
</ul>
<p><strong>实例</strong></p>
<p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t runoob/ubuntu:v1 .</span><br></pre></td></tr></table></figure>
<p>使用URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build github.com/creack/docker-firefox</span><br></pre></td></tr></table></figure>
<p>也可以通过 -f Dockerfile 文件的位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure>
<p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="history">Docker history 命令</h3>

<p><strong>docker history :</strong> 查看指定镜像的创建历史</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker history [OPTIONS] IMAGE</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-H :以可读的格式打印镜像大小和日期，默认为true；</li>
<li>–no-trunc :显示完整的提交记录；</li>
<li>-q :仅列出提交记录ID。</li>
</ul>
<p><strong>实例</strong></p>
<p>查看本地镜像runoob/ubuntu:v3的创建历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@runoob:~# docker history runoob/ubuntu:v3</span><br><span class="line">IMAGE             CREATED           CREATED BY                                      SIZE      COMMENT</span><br><span class="line">4e3b13c8a266      3 months ago      /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B                 </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$/   1.863 kB            </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c set -xe   &amp;amp;&amp;amp; echo '#!/bin/sh' &amp;gt; /u   701 B               </span><br><span class="line">&amp;lt;missing&amp;gt;         3 months ago      /bin/sh -c #(nop) ADD file:43cb048516c6b80f22   136.3 MB</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="save">Docker save 命令</h3>

<p><strong>docker save :</strong> 将指定镜像保存成 tar 归档文件</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker save [OPTIONS] IMAGE [IMAGE…]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-o :输出到的文件</li>
</ul>
<p><strong>实例</strong></p>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</span><br><span class="line">runoob@runoob:~$ ll my_ubuntu_v3.tar</span><br><span class="line">-rw------- 1 runoob runoob 142102016 Jul 11 01:37 my_ubuntu_v3.ta</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="import">Docker import 命令</h3>

<p><strong>docker import :</strong> 从归档文件中创建镜像</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-c :应用docker 指令创建镜像；</li>
<li>-m :提交时的说明文字；</li>
</ul>
<p><strong>实例</strong></p>
<p>从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker import  my_ubuntu_v3.tar runoob/ubuntu:v4  </span><br><span class="line">sha256:63ce4a6d6bc3fabb95dbd6c561404a309b7bdfc4e21c1d59fe9fe4299cbfea39</span><br><span class="line">runoob@runoob:~$ docker images runoob/ubuntu:v4</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">runoob/ubuntu       v4                  63ce4a6d6bc3        20 seconds ago      142.1 MB</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="infoversion">info|version</h2>

<h3 id="info">Docker info 命令</h3>

<p><strong>docker info :</strong> 显示 Docker 系统信息，包括镜像和容器数</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker info [OPTIONS]</p>
</blockquote>
<p><strong>实例</strong></p>
<p>查看docker系统信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker info</span><br><span class="line">Containers: 12</span><br><span class="line">Images: 41</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 66</span><br><span class="line"> Dirperm1 Supported: false</span><br><span class="line">Execution Driver: native-0.2</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Kernel Version: 3.13.0-32-generic</span><br><span class="line">Operating System: Ubuntu 14.04.1 LTS</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 1.954 GiB</span><br><span class="line">Name: iZ23mtq8bs1Z</span><br><span class="line">ID: M5N4:K6WN:PUNC:73ZN:AONJ:AUHL:KSYH:2JPI:CH3K:O4MK:6OCX:5OYW</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="version">Docker version 命令</h3>

<p><strong>docker version :</strong> 显示 Docker 版本信息</p>
<p><strong>语法</strong></p>
<blockquote>
<p>docker version [OPTIONS]</p>
</blockquote>
<p>OPTIONS说明：</p>
<ul>
<li>-f :指定返回值的模板文件</li>
</ul>
<p><strong>实例</strong></p>
<p>显示 Docker 版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      1.8.2</span><br><span class="line"> API version:  1.20</span><br><span class="line"> Go version:   go1.4.2</span><br><span class="line"> Git commit:   0a8c2e3</span><br><span class="line"> Built:        Thu Sep 10 19:19:00 UTC 2015</span><br><span class="line"> OS/Arch:      linux/amd64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse下JSP中使用UEditor（以富文本编辑器为例）</title>
    <url>/2017/02/20/Eclipse%E4%B8%8BJSP%E4%B8%AD%E4%BD%BF%E7%94%A8UEditor(%E4%BB%A5%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%BA%E4%BE%8B)/</url>
    <content><![CDATA[<h3 id="1-下载UEditor"><a href="#1-下载UEditor" class="headerlink" title="1.下载UEditor"></a>1.下载UEditor</h3><p><a href="http://ueditor.baidu.com/website/download.html" target="_blank" rel="noopener">http://ueditor.baidu.com/website/download.html</a>     </p>
<a id="more"></a>
<p>版本如下：<br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/1.png" alt="avatar">      </p>
<h3 id="2-解压，简单暴力地将-ueditor1-4-3-utf8-jsp-jsp-lib目录下的文件拷贝到项目的-WEB-INF-lib目录下"><a href="#2-解压，简单暴力地将-ueditor1-4-3-utf8-jsp-jsp-lib目录下的文件拷贝到项目的-WEB-INF-lib目录下" class="headerlink" title="2.解压，简单暴力地将\ueditor1_4_3-utf8-jsp\jsp\lib目录下的文件拷贝到项目的/WEB-INF/lib目录下"></a>2.解压，简单暴力地将<strong><em>\ueditor1_4_3-utf8-jsp\jsp\lib</em></strong>目录下的文件拷贝到项目的<strong><em>/WEB-INF/lib</em></strong>目录下</h3><p>如图所示：<br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/2.png" alt="avatar"><br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/3.png" alt="avatar"></p>
<h3 id="3-将除index-html文件外的文件拷贝到项目中，例如："><a href="#3-将除index-html文件外的文件拷贝到项目中，例如：" class="headerlink" title="3.将除index.html文件外的文件拷贝到项目中，例如："></a>3.将除index.html文件外的文件拷贝到项目中，例如：</h3><p><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/4.png" alt="avatar">      </p>
<h3 id="4-在要使用富文本编辑器的页面引入脚本："><a href="#4-在要使用富文本编辑器的页面引入脚本：" class="headerlink" title="4.在要使用富文本编辑器的页面引入脚本："></a>4.在要使用富文本编辑器的页面引入脚本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/ueditor.all.min.js&quot;&gt; &lt;/script&gt;</span><br><span class="line">&lt;!--建议手动加在语言，避免在ie下有时因为加载语言失败导致编辑器加载失败--&gt;</span><br><span class="line">&lt;!--这里加载的语言文件会覆盖你在配置项目里添加的语言类型，比如你在配置项目里配置的是英文，这里加载的中文，那最后就是中文--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;&lt;%=path%&gt;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/5.png" alt="avatar">      </p>
<h3 id="5-在需要用富文本编辑器的区域添加以下脚本："><a href="#5-在需要用富文本编辑器的区域添加以下脚本：" class="headerlink" title="5.在需要用富文本编辑器的区域添加以下脚本："></a>5.在需要用富文本编辑器的区域添加以下脚本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:486px;height:300px;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/6.png" alt="avatar">        </p>
<h3 id="6-在页面最下端写以下javascript脚本："><a href="#6-在页面最下端写以下javascript脚本：" class="headerlink" title="6.在页面最下端写以下javascript脚本："></a>6.在页面最下端写以下javascript脚本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;   </span><br><span class="line">    //实例化编辑器    </span><br><span class="line">    //建议使用工厂方法getEditor创建和引用编辑器实例，如果在某个闭包下引用该编辑器，直接调用UE.getEditor(&apos;editor&apos;)就能拿到相关的实例</span><br><span class="line">    var ue = UE.getEditor(&apos;editor&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/7.png" alt="avatar">      </p>
<h3 id="7-添加提交按钮的js脚本，用来提交内容"><a href="#7-添加提交按钮的js脚本，用来提交内容" class="headerlink" title="7.添加提交按钮的js脚本，用来提交内容"></a>7.添加提交按钮的js脚本，用来提交内容</h3><p><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/8.png" alt="avatar"><br>脚本文件：<img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/9.png" alt="avatar"><br><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/10.png" alt="avatar"><br>代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function check_post_msg_valid()&#123;      </span><br><span class="line">          if(false==UE.getEditor(&apos;editor&apos;).hasContents())&#123;      </span><br><span class="line">               alert(&apos;请输入内容！&apos;);       </span><br><span class="line">               return false;        </span><br><span class="line">          &#125;           </span><br><span class="line">     document.getElementById(&quot;msg&quot;).value=UE.getEditor(&apos;editor&apos;).getContent();        </span><br><span class="line">     document.forms[0].submit();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-其他："><a href="#8-其他：" class="headerlink" title="8.其他："></a>8.其他：</h3><p><img src="https://DaiHuiBlog.github.io/images/posts/Eclipse下JSP中使用UEditor/11.png" alt="avatar">       </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>UEditor</tag>
        <tag>富文本编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios基本使用说明</title>
    <url>/2018/04/11/Axios%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p><a href="https://www.npmjs.org/package/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/v/axios.svg?style=flat-square" alt="npm version"></a><a href="https://travis-ci.org/axios/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/travis/axios/axios.svg?style=flat-square" alt="build status"></a><a href="https://coveralls.io/r/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" alt="code coverage"></a><a href="http://npm-stat.com/charts.html?package=axios" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/dm/axios.svg?style=flat-square" alt="npm downloads"></a><a href="https://gitter.im/mzabriskie/axios" target="_blank" rel="noopener"><img src="https://img.shields.io/gitter/room/mzabriskie/axios.svg?style=flat-square" alt="gitter chat"></a><a href="https://www.codetriage.com/axios/axios" target="_blank" rel="noopener"><img src="https://www.codetriage.com/axios/axios/badges/users.svg" alt="code helpers"></a></p>
<p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<a id="more"></a>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>从浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequests</a></li>
<li>从 node.js 创建 <a href="http://nodejs.org/api/http.html" target="_blank" rel="noopener">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">XSRF</a></li>
</ul>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><table>
<thead>
<tr>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png" alt="Chrome"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png" alt="Firefox"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/safari/safari_48x48.png" alt="Safari"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/opera/opera_48x48.png" alt="Opera"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/edge/edge_48x48.png" alt="Edge"></th>
<th><img src="https://raw.github.com/alrra/browser-logos/master/src/archive/internet-explorer_9-11/internet-explorer_9-11_48x48.png" alt="IE"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>Latest ✔</td>
<td>8+ ✔</td>
<td></td>
</tr>
</tbody>
</table>
<p><a href="https://saucelabs.com/u/axios" target="_blank" rel="noopener"><img src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" alt="Browser Matrix"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure>
<p>使用 bower:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure>
<p>使用 cdn:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/axios/dist/axios.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>执行 <code>GET</code> 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想使用异步/等待？将`async`关键字添加到外部函数/方法中。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">'/user?ID=12345'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong> async/await是ECMAScript 2017的一部分，在Internet Explorer和旧版浏览器中不支持，因此请谨慎使用。</p>
</blockquote>
<p>执行 <code>POST</code> 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'/user'</span>, &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>执行多个并发请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'/user/12345/permissions'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//两个请求均已完成</span></span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h2><p>请求可以通过传递相关配置来完成 <code>axios</code>.</p>
<p><strong>axios(config)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送一个POST请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET请求远程图像</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  method:<span class="string">'get'</span>,</span><br><span class="line">  url:<span class="string">'http://bit.ly/2mTM3nY'</span>,</span><br><span class="line">  responseType:<span class="string">'stream'</span></span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  response.data.pipe(fs.createWriteStream(<span class="string">'ada_lovelace.jpg'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>axios(url[, config])</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送GET请求（默认方法）</span></span><br><span class="line">axios(<span class="string">'/user/12345'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h2><p>为方便起见，为所有支持的请求方法提供了别名</p>
<p><strong>axios.request(config)</strong><br><strong>axios.get(url[, config])</strong><br><strong>axios.delete(url[, config])</strong><br><strong>axios.head(url[, config])</strong><br><strong>axios.options(url[, config])</strong><br><strong>axios.post(url[, data[, config]])</strong><br><strong>axios.put(url[, data[, config]])</strong><br><strong>axios.patch(url[, data[, config]])</strong></p>
<blockquote>
<p>注意: 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</p>
</blockquote>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>处理并发请求的助手函数</p>
<p><strong>axios.all(iterable)</strong><br><strong>axios.spread(callback)</strong></p>
<h3 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h3><p>您可以使用自定义配置创建一个新的axios实例。</p>
<p><strong>axios.create([config])</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;<span class="string">'X-Custom-Header'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<p><strong>axios#request(config)</strong><br><strong>axios#get(url[, config])</strong><br><strong>axios#delete(url[, config])</strong><br><strong>axios#head(url[, config])</strong><br><strong>axios#options(url[, config])</strong><br><strong>axios#post(url[, data[, config]])</strong><br><strong>axios#put(url[, data[, config]])</strong><br><strong>axios#patch(url[, data[, config]])</strong></p>
<h2 id="请求配置"><a href="#请求配置" class="headerlink" title="请求配置"></a>请求配置</h2><p>这些是创建请求时可以用的配置选项。只有 <code>url</code> 是必需的。如果没有指定 <code>method</code>，请求将默认使用 <code>get</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url: <span class="string">'/user'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method: <span class="string">'get'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL: <span class="string">'https://some-domain.com/api/'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">  <span class="comment">// 您可以修改headers对象。</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data, headers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是即将被发送的自定义请求头</span></span><br><span class="line">  headers: &#123;<span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span>&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `params`  是即将与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个普通对象(plain object)或 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">  <span class="comment">// (例如： https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">'brackets'</span>&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `data` 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属： FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node专属: Stream, Buffer</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span></span><br><span class="line">  <span class="comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span></span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">'janedoe'</span>,</span><br><span class="line">    password: <span class="string">'s00pers3cret'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span></span><br><span class="line">  responseType: <span class="string">'json'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码</span></span><br><span class="line">  <span class="comment">// 注意：忽略'stream'或客户端请求的`responseType`</span></span><br><span class="line">  responseEncoding: <span class="string">'utf8'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">'XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span></span><br><span class="line">  xsrfHeaderName: <span class="string">'X-XSRF-TOKEN'</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span> (<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义在 node.js 中遵循的最大重定向数目</span></span><br><span class="line">  <span class="comment">// 如果设置为0，将不会 follow 任何重定向</span></span><br><span class="line">  maxRedirects: <span class="number">5</span>, <span class="comment">// default</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `socketPath` 定义了一个在Socket.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// 例如'/var/run/docker.sock'发送请求到docker守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定`socketPath`或`proxy`。</span></span><br><span class="line">  <span class="comment">// 如果两者都指定，则使用`socketPath`。</span></span><br><span class="line">  socketPath: <span class="literal">null</span>, <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span></span><br><span class="line">  <span class="comment">// `keepAlive` 默认没有启用</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> https.Agent(&#123; <span class="attr">keepAlive</span>: <span class="literal">true</span> &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 'proxy' 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// 使用'false'来禁用代理，忽略环境变量。</span></span><br><span class="line">  <span class="comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">'mikeymike'</span>,</span><br><span class="line">      password: <span class="string">'rapunz3l'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `cancelToken` 指定用于取消请求的 cancel token</span></span><br><span class="line">  <span class="comment">// （查看后面的 Cancellation 这节了解更多）</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> (<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h2><p>某个请求的响应包含以下信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: <span class="string">'OK'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` t服务器响应的头</span></span><br><span class="line">  <span class="comment">// 所有的 header 都是小写</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是为请求提供给`axios`的配置</span></span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 它是node.js中的最后一个ClientRequest实例和浏览器请求的XMLHttpRequest实例</span></span><br><span class="line">  request: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>then</code> 时，你将接收下面这样的响应：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>在使用 <code>catch</code> 时，或传递<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">rejection callback</a> 作为 <code>then</code> 的第二个参数时, 响应可以通过 <code>error</code> 对象可被使用，正如在<a href="#错误处理">错误处理</a> 这一节所讲.</p>
<h2 id="配置的默认值-defaults"><a href="#配置的默认值-defaults" class="headerlink" title="配置的默认值/defaults"></a>配置的默认值/defaults</h2><p>你可以指定将被用在各个请求的配置默认值</p>
<h3 id="全局axios默认值"><a href="#全局axios默认值" class="headerlink" title="全局axios默认值"></a>全局axios默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="自定义实例默认值"><a href="#自定义实例默认值" class="headerlink" title="自定义实例默认值"></a>自定义实例默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建实例时设置配置的默认值</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">'https://api.example.com'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例已创建后修改默认值</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure>
<h3 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h3><p>配置会以一个优先顺序进行合并。这个顺序是：在 <a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L28" target="_blank" rel="noopener">lib/defaults.js</a>找到的库的默认值，然后是实例的 <code>defaults</code> 属性，最后是请求的 <code>config</code> 参数。后者将优先于前者。这里是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 `0`</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写库的超时默认值</span></span><br><span class="line"><span class="comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>
<p>可以为自定义 axios 实例添加拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">      <span class="comment">// 请求已发出，但服务器响应的状态码不在 2xx 范围内</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">      <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.request) &#123;</span><br><span class="line">      <span class="comment">// 请求被提出，但没有接收到响应</span></span><br><span class="line">      <span class="comment">// `error.request`是在浏览器中一个XMLHttpRequest的实例和node.js中http.ClientRequest的实例</span></span><br><span class="line">      <span class="built_in">console</span>.log(error.request);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置触发错误</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error'</span>, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>validateStatus</code> 配置选项定义一个自定义 <code>HTTP</code> 状态码的错误范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span> (<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> status &lt; <span class="number">500</span>; <span class="comment">// 仅当状态码大于或等于500时才拒绝</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h2><p>使用 <em>cancel token</em> 取消请求</p>
<blockquote>
<p>Axios 的 cancel token API 基于<a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener">cancelable promises proposal</a>，它还处于第一阶段。</p>
</blockquote>
<p>可以使用 <code>CancelToken.source</code> 工厂创建取消令牌，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  name: <span class="string">'new name'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（消息参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">'Operation canceled by the user.'</span>);</span><br></pre></td></tr></table></figure>
<p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/user/12345'</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 可以使用同一个 cancel token 取消多个请求</p>
</blockquote>
<h2 id="使用-application-x-www-form-urlencoded-格式"><a href="#使用-application-x-www-form-urlencoded-格式" class="headerlink" title="使用 application/x-www-form-urlencoded 格式"></a>使用 application/x-www-form-urlencoded 格式</h2><p>默认情况下，axios将JavaScript对象序列化为JSON。要以<code>application/x-www-form-urlencoded</code> 格式发送数据，您可以使用以下选项之一。</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>在浏览器中，您可以使用以下<a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener"><code>URLSearchParams</code></a> API:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">'param1'</span>, <span class="string">'value1'</span>);</span><br><span class="line">params.append(<span class="string">'param2'</span>, <span class="string">'value2'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, params);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意， <code>URLSearchParams</code> 并非所有浏览器都支持(请参阅 <a href="http://www.caniuse.com/#feat=urlsearchparams" target="_blank" rel="noopener">caniuse.com</a>), 但可以使用 <a href="https://github.com/WebReflection/url-search-params" target="_blank" rel="noopener">polyfill</a>(请确保填充全局环境)。<br>或者，您可以使用<a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a> 库对数据进行编码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'qs'</span>);</span><br><span class="line">axios.post(<span class="string">'/foo'</span>, qs.stringify(&#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>或者以另一种方式（ES6），</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">'bar'</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  headers: &#123; <span class="string">'content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span> &#125;,</span><br><span class="line">  data: qs.stringify(data),</span><br><span class="line">  url,</span><br><span class="line">&#125;;</span><br><span class="line">axios(options);</span><br></pre></td></tr></table></figure>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>在node.js中，您可以<a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener"><code>querystring</code></a>按如下方式使用模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">axios.post(<span class="string">'http://something.com/'</span>, querystring.stringify(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;));</span><br></pre></td></tr></table></figure>
<p>您也可以使用该<a href="https://github.com/ljharb/qs" target="_blank" rel="noopener"><code>qs</code></a>库.</p>
<h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><p>在axios达到<code>1.0</code> 发布之前，将通过新的次要版本发布重大更改。例如 <code>0.5.1</code>, 和 <code>0.5.4</code>将具有相同的API, 但 <code>0.6.0</code> 会有重大更改。</p>
<h2 id="承诺"><a href="#承诺" class="headerlink" title="承诺"></a>承诺</h2><p>aaxios依赖于原生ES6 Promise实现的<a href="http://caniuse.com/promises" target="_blank" rel="noopener">支持</a>。如果您的环境不支持ES6 Promise，则可以<a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="noopener">polyfill</a>。</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>axios包括<a href="http://typescriptlang.org" target="_blank" rel="noopener">TypeScript</a>定义。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.get(<span class="string">'/user?ID=12345'</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul>
<li><a href="https://github.com/axios/axios/blob/master/CHANGELOG.md" target="_blank" rel="noopener">更新日志</a></li>
<li><a href="https://github.com/axios/axios/blob/master/UPGRADE_GUIDE.md" target="_blank" rel="noopener">升级指南</a></li>
<li><a href="https://github.com/axios/axios/blob/master/ECOSYSTEM.md" target="_blank" rel="noopener">生态系统</a></li>
<li><a href="https://github.com/axios/axios/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">C参与指南</a></li>
<li><a href="https://github.com/axios/axios/blob/master/CODE_OF_CONDUCT.md" target="_blank" rel="noopener">行为守则</a></li>
</ul>
]]></content>
      <categories>
        <category>翻译</category>
        <category>README</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简明指南</title>
    <url>/2018/04/24/Git%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/Git简明指南/3.jpg" alt="image1"></p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载-git-OSX-版"><a href="#下载-git-OSX-版" class="headerlink" title="下载 git OSX 版"></a><a href="http://git-scm.com/download/mac" target="_blank" rel="noopener">下载 git OSX 版</a></h2><h2 id="下载-git-Windows-版"><a href="#下载-git-Windows-版" class="headerlink" title="下载 git Windows 版"></a><a href="http://git-for-windows.github.io/" target="_blank" rel="noopener">下载 git Windows 版</a></h2><h2 id="下载-git-Linux-版"><a href="#下载-git-Linux-版" class="headerlink" title="下载 git Linux 版"></a><a href="http://book.git-scm.com/2_installing_git.html" target="_blank" rel="noopener">下载 git Linux 版</a></h2><h1 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h1><p>创建新文件夹，打开，然后执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p>以创建新的 git 仓库。</p>
<h1 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h1><p>执行如下命令以创建一个本地仓库的克隆版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone /path/to/repository</span><br></pre></td></tr></table></figure></p>
<p>如果是远端服务器上的仓库，你的命令会是这个样子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone username@host:/path/to/repository</span><br></pre></td></tr></table></figure></p>
<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><p>你的本地仓库由 git 维护的三棵“树”组成。<br>第一个是你的<code>工作目录</code>，它持有实际文件；<br>第二个是<code>暂存区（Index）</code>，它像个缓存区域，临时保存你的改动；<br>最后是 <code>HEAD</code>，它指向你最后一次提交的结果。</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Git简明指南/1.png" alt="image1"></p>
<h1 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h1><p>你可以提出更改（把它们添加到暂存区），使用如下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure></p>
<p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure></p>
<p>现在，你的改动已经提交到了<code>HEAD</code>，但是还没到你的远端仓库。</p>
<h1 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h1><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>可以把 master 换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure></p>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Git简明指南/2.png" alt="image2"></p>
<p>创建一个叫做“feature_x”的分支，并切换过去：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure></p>
<p>切换回主分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></p>
<p>再把新建的分支删掉：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure></p>
<p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h1><p>要更新你的本地仓库至最新改动，执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p>
<p>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。<br>这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure></p>
<p>在合并改动之前，你可以使用如下命令预览差异：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure></p>
<p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p>
<p>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p>
<h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><p>如果你想了解本地仓库的历史记录，最简单的命令就是使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p>
<p>你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author=bob</span><br></pre></td></tr></table></figure></p>
<p>一个压缩后的每一条提交记录只占一行的输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></p>
<p>或者你想通过<strong>ASCII</strong>艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure></p>
<p>看看哪些文件改变了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --name-status</span><br></pre></td></tr></table></figure></p>
<p>这些只是你可以使用的参数中很小的一部分。更多的信息，参考：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --help</span><br></pre></td></tr></table></figure></p>
<h1 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h1><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure></p>
<p>此命令会使用<code>HEAD</code>中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p>
<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p>
<h1 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h1><p>内建的图形化 git：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure></p>
<p>彩色的 git 输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config color.ui true</span><br></pre></td></tr></table></figure></p>
<p>显示历史记录时，每个提交的信息只显示一行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure></p>
<p>交互式添加文件到暂存区：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure></p>
<h1 id="链接与资源"><a href="#链接与资源" class="headerlink" title="链接与资源"></a>链接与资源</h1><h2 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h2><p><a href="http://gitx.laullon.com/" target="_blank" rel="noopener">GitX (L) (OSX, 开源软件)</a><br><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower (OSX)</a><br><a href="http://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree (OSX, 免费)</a><br><a href="http://mac.github.com/" target="_blank" rel="noopener">GitHub for Mac (OSX, 免费)</a><br><a href="https://itunes.apple.com/gb/app/gitbox/id403388357?mt=12" target="_blank" rel="noopener">GitBox (OSX, App Store)</a>  </p>
<h2 id="指南和手册"><a href="#指南和手册" class="headerlink" title="指南和手册"></a>指南和手册</h2><p><a href="http://book.git-scm.com/" target="_blank" rel="noopener">Git 社区参考书</a><br><a href="http://progit.org/book/" target="_blank" rel="noopener">专业 Git</a><br><a href="http://think-like-a-git.net/" target="_blank" rel="noopener">像 git 那样思考</a><br><a href="http://help.github.com/" target="_blank" rel="noopener">GitHub 帮助</a><br><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a>  </p>
<p>git命令大全：<br><img src="https://DaiHuiBlog.github.io/images/posts/Git简明指南/4.jpg" alt="image2"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(1)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-1/</url>
    <content><![CDATA[<h3 id="配置虚拟机子网网段-hostonly模式时"><a href="#配置虚拟机子网网段-hostonly模式时" class="headerlink" title="配置虚拟机子网网段(hostonly模式时)"></a>配置虚拟机子网网段(hostonly模式时)</h3><ul>
<li>配置网段  <blockquote>
<p>点击VMware快捷方式，右键打开文件所在位置 -&gt; 双击vmnetcfg.exe -&gt; VMnet1 host-only -&gt;<br>修改subnet ip 设置网段：192.168.8.0 子网掩码：255.255.255.0 -&gt; apply -&gt; ok</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>设置本地机器IP  </p>
<blockquote>
<p>回到windows –&gt; 打开网络和共享中心 -&gt; 更改适配器设置 -&gt; 右键VMnet1 -&gt; 属性 -&gt; 双击IPv4 -&gt;<br>设置windows的IP：192.168.8.100 子网掩码：255.255.255.0 -&gt; 点击确定</p>
</blockquote>
</li>
<li><p>设置为hostonly模式  </p>
<blockquote>
<p>在虚拟软件上 –My Computer -&gt; 选中虚拟机 -&gt; 右键 -&gt; settings -&gt; network adapter -&gt; host only -&gt; ok   </p>
</blockquote>
</li>
<li><p>另:桥接模式    </p>
<blockquote>
<p>桥接模式直接将本地机器的当前正在使用的网卡(无线/非无线网卡)IP改为静态IP即可.设置windows的IP：192.168.8.100 子网掩 码：255.255.255.0 -&gt; 网关:192.168.1.1 -&gt; 若为无线网卡,设置前先查看路由分配的DNS是多少,直接照着填进来就行.-&gt;<br>点击确定</p>
</blockquote>
</li>
</ul>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><blockquote>
<p>vim /etc/sysconfig/network</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=dh01 #随便设置一个名字</span><br></pre></td></tr></table></figure>
<h3 id="修改虚拟机IP-这里是centos7"><a href="#修改虚拟机IP-这里是centos7" class="headerlink" title="修改虚拟机IP(这里是centos7)"></a>修改虚拟机IP(这里是centos7)</h3><p>两种方式：  </p>
<ul>
<li><p>第一种：通过Linux图形界面进行修改（推荐）</p>
<blockquote>
<p>进入Linux图形界面 -&gt; 右键点击右上方的两个小电脑 -&gt;<br>点击Edit connections -&gt; 选中当前网络System eth0 -&gt;<br>点击edit按钮 -&gt; 选择IPv4 -&gt; method选择为manual -&gt;<br>点击add按钮 -&gt;添加IP：192.168.8.88<br>子网掩码：255.255.255.0 网关：192.168.8.1 -&gt; apply</p>
</blockquote>
</li>
<li><p>第二种：修改配置文件方式   </p>
<blockquote>
<p>vim /etc/sysconfig/network-scripts/ifcfg-eth0 (不一定一定是ifcfg-eth0)</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;               #修改</span><br><span class="line">HWADDR=&quot;00:0C:29:3C:BF:E7&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">NM_CONTROLLED=&quot;yes&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">UUID=&quot;ce22eeca-ecde-4536-8cc2-ef0dc36d4a8c&quot;</span><br><span class="line">IPADDR=&quot;192.168.8.88&quot;               #修改</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;           #修改</span><br><span class="line">GATEWAY=&quot;192.168.8.1&quot;               #修改</span><br></pre></td></tr></table></figure>
<h3 id="修改主机名和IP的映射关系"><a href="#修改主机名和IP的映射关系" class="headerlink" title="修改主机名和IP的映射关系"></a>修改主机名和IP的映射关系</h3><blockquote>
<p>vim /etc/hosts</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.8.88 dh01</span><br></pre></td></tr></table></figure>
<h3 id="关闭防火墙-以下为centos7以前命令-centos7"><a href="#关闭防火墙-以下为centos7以前命令-centos7" class="headerlink" title="关闭防火墙(以下为centos7以前命令,centos7)"></a>关闭防火墙(以下为centos7以前命令,centos7)</h3><blockquote>
<p>#查看防火墙状态<br>service iptables status</p>
<p>#关闭防火墙<br>service iptables stop</p>
<p>#查看防火墙开机启动状态<br>chkconfig iptables –list</p>
<p>#关闭防火墙开机启动<br>chkconfig iptables off    </p>
</blockquote>
<p>CentOS 7.0默认使用的是firewall作为防火墙  </p>
<blockquote>
<p>systemctl start firewalld.service    #启动firewall<br>systemctl stop firewalld.service    #停止firewall<br>systemctl disable firewalld.service    #禁止firewall开机启动  </p>
</blockquote>
<p>也可以改成使用iptables：systemctl start iptables.service</p>
<h3 id="重启Linux"><a href="#重启Linux" class="headerlink" title="重启Linux"></a>重启Linux</h3><blockquote>
<p>reboot</p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(4)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-4/</url>
    <content><![CDATA[<h3 id="生成ssh免登陆密钥"><a href="#生成ssh免登陆密钥" class="headerlink" title="生成ssh免登陆密钥"></a>生成ssh免登陆密钥</h3><ul>
<li>进入到/dh/下的home目录(隐藏)  <blockquote>
<p>cd ~/.ssh<br>ssh-keygen -t rsa （一直回车）</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<p>执行完这个命令后，会生成两个文件id_rsa（私钥）、id_rsa.pub（公钥）</p>
<ul>
<li>将公钥拷贝到要免登陆的机器上<blockquote>
<p>ssh-copy-id -i localhost (ssh-copy-id -i 要免登陆的机器的IP)<br>或者<br>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys  </p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(2)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-2/</url>
    <content><![CDATA[<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ul>
<li>从Windows上传jdk到虚拟机  <blockquote>
<p>你可以用FlashFXP/FileZilla/SecureCRT将jdk-7u79-linux-x64.gz传到Linux上。假设现在你已经传到了虚拟机的root目录下</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>解压jdk   </p>
<blockquote>
<p>mkdir /usr/java<br>tar -zxvf jdk-7u79-linux-x64.gz -C /usr/java/</p>
</blockquote>
</li>
<li><p>将java添加到环境变量中  </p>
<blockquote>
<p>vim /etc/profile  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79  </span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新配置   </p>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop伪分布式搭建-(3)</title>
    <url>/2018/03/18/Hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA-3/</url>
    <content><![CDATA[<p><em><br>安装hadoop2.4.1（或其他更高版本&lt;最好用更高的64位版本，免得重新编译&gt;）<br>注意：hadoop2.x的配置文件$HADOOP_HOME/etc/hadoop伪分布式需要修改5个配置文件
</em></p>
<a id="more"></a>
<h3 id="上传hadoop并解压到指定目录"><a href="#上传hadoop并解压到指定目录" class="headerlink" title="上传hadoop并解压到指定目录"></a>上传hadoop并解压到指定目录</h3><p>同jdk一样,上传Hadoop的包到本目录,并在root目录下创建/dh/这个目录,将Hadoop解压到该目录</p>
<h3 id="配置hadoop"><a href="#配置hadoop" class="headerlink" title="配置hadoop"></a>配置hadoop</h3><ol>
<li><p>hadoop-env.sh文件  </p>
<blockquote>
<p>vim hadoop-env.sh</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79</span><br></pre></td></tr></table></figure>
</li>
<li><p>core-site.xml文件</p>
<blockquote>
<p>vim core-site.xml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--设定NameNode地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://dh01:9000&lt;/value&gt;  &lt;!--或者把dh01换成对应IP--&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/dh/hadoop-2.4.1/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hdfs-site.xml文件  </p>
<blockquote>
<p>vim hdfs-site.xml</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定HDFS副本的数量 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;&lt;!--因为为伪分布式,所以只有一个副本--&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mapred-site.xml文件</p>
<blockquote>
<p>#重命名<br>mv mapred-site.xml.template mapred-site.xml<br>#打开重命名后的文件<br>vim mapred-site.xml  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定mapreduce运行在YARN上 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>yarn-site.xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 指定YARN的老大（ResourceManager）的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;dh01&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- mapreduce获取数据的方式 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="将hadoop添加到环境变量"><a href="#将hadoop添加到环境变量" class="headerlink" title="将hadoop添加到环境变量"></a>将hadoop添加到环境变量</h3><blockquote>
<p>vim /etc/proflie</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">export HADOOP_HOME=/dh/hadoop-2.4.1</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/lib</span><br></pre></td></tr></table></figure>
<p>刷新配置文件  </p>
<blockquote>
<p>source /etc/profile</p>
</blockquote>
<h3 id="格式化namenode（是对namenode进行初始化）"><a href="#格式化namenode（是对namenode进行初始化）" class="headerlink" title="格式化namenode（是对namenode进行初始化）"></a>格式化namenode（是对namenode进行初始化）</h3><blockquote>
<p>hdfs namenode -format (hadoop namenode -format)</p>
</blockquote>
<h3 id="启动hadoop"><a href="#启动hadoop" class="headerlink" title="启动hadoop"></a>启动hadoop</h3><p>先启动HDFS</p>
<blockquote>
<p>sbin/start-dfs.sh</p>
</blockquote>
<p>再启动YARN</p>
<blockquote>
<p>sbin/start-yarn.sh</p>
</blockquote>
<h3 id="验证是否启动成功"><a href="#验证是否启动成功" class="headerlink" title="验证是否启动成功"></a>验证是否启动成功</h3><p>使用jps命令验证</p>
<blockquote>
<p>jsp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27408 NameNode</span><br><span class="line">28218 Jps</span><br><span class="line">27643 SecondaryNameNode</span><br><span class="line">28066 NodeManager</span><br><span class="line">27803 ResourceManager</span><br><span class="line">27512 DataNode</span><br></pre></td></tr></table></figure>
<p><a href="http://192.168.8.88:50070" target="_blank" rel="noopener">http://192.168.8.88:50070</a> （HDFS管理界面）</p>
<p>在这个文件中添加linux主机名和IP的映射关系<br>C:\Windows\System32\drivers\etc\hosts下添加:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.1.66	dh01</span><br></pre></td></tr></table></figure></p>
<p>打开：<a href="http://192.168.8.88:8088验证" target="_blank" rel="noopener">http://192.168.8.88:8088验证</a> （mapreduce管理界面）  </p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo下NexT主题添加Gitment评论插件</title>
    <url>/2018/06/20/Hexo%E4%B8%8BNexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Gitment%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="最终效果图大概是这个样子："><a href="#最终效果图大概是这个样子：" class="headerlink" title="最终效果图大概是这个样子："></a>最终效果图大概是这个样子：</h3><p><img src="https://DaiHuiBlog.github.io/images/posts/Hexo下NexT主题添加Gitment评论插件/3.png" alt="最终">  </p>
<a id="more"></a>
<p>Gitment 是作者<a href="https://imsun.net/" target="_blank" rel="noopener">imsun</a>实现的一款基于 GitHub Issues 的评论系统。 支持在前端直接引入， 不需要任何后端代码。 可以在页面进行登录， 查看，评论，点赞等操作。 同时有完整的 Markdown / GFM 和代码高亮支持。 尤为适合各种基于 GitHub Pages 的静态博客或项目页面。</p>
<p>这篇文章仅介绍如果在 hexo-NexT 中添加 Gitment 评论插件，并且增加一个点开显示评论的按钮，对于 Gitment 的使用请参考 <a href="https://imsun.net/" target="_blank" rel="noopener">imsun</a> 的博客。</p>
<p>另外，本教程的按钮样式和代码均直接取自 <a href="https://ehlxr.me/" target="_blank" rel="noopener">ehlxr</a> 博主。</p>
<h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><p>因为 Gitment 评论插件是基于Github Issues评论系统，这类评论系统都需要一个OAuth Application，所以咱们没有注册OAuth Application的同学先注册一个。<br>博客咱们已经有啦，例如我的：DaiHuiBlog.github.io。没有的同学以自己GitHub用户新建一个仓库就行：<strong>你的用户名.github.io</strong><br>接下来创建 <em>OAuth Application</em>，没有的同学可以<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener"><strong>新建一个</strong></a>。</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Hexo下NexT主题添加Gitment评论插件/1.png" alt="新建OA">  </p>
<p>其中</p>
<ul>
<li><strong>Application name</strong> 为仓库名，例：DaiHuiBlog.github.io  </li>
<li><strong>Homepage URL</strong> 填你的博客网址，例：blog.daihui888.com</li>
<li><strong>Application description</strong> 描述，随便写</li>
<li><strong>Authorization callback URL</strong> 填你的博客网址，例：blog.daihui888.com  </li>
</ul>
<p>完成后会生成相应的 <strong>clientID</strong> 和 <strong>clientSecret</strong>。</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Hexo下NexT主题添加Gitment评论插件/2.jpg" alt="完成OA">  </p>
<p>接下来开始配置Gitment</p>
<h3 id="“显示-Gitment-评论”-的按钮样式"><a href="#“显示-Gitment-评论”-的按钮样式" class="headerlink" title="“显示 Gitment 评论” 的按钮样式"></a>“显示 Gitment 评论” 的按钮样式</h3><p>在 <strong>next/source/css/_common/components</strong> 目录中新建一个 <strong>gitment.styl</strong> 的 css 样式文件, 复制以下代码    </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gitment_title</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: initial;</span><br><span class="line">    <span class="attribute">background-position-x</span>: initial;</span><br><span class="line">    <span class="attribute">background-position-y</span>: initial;</span><br><span class="line">    <span class="attribute">background-size</span>: initial;</span><br><span class="line">    <span class="attribute">background-repeat-x</span>: initial;</span><br><span class="line">    <span class="attribute">background-repeat-y</span>: initial;</span><br><span class="line">    <span class="attribute">background-attachment</span>: initial;</span><br><span class="line">    <span class="attribute">background-origin</span>: initial;</span><br><span class="line">    <span class="attribute">background-clip</span>: initial;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gitment_title</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-top-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-top-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-right-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-right-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-bottom-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-bottom-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-left-color</span>: <span class="built_in">rgb</span>(10, 156, 175);</span><br><span class="line">    <span class="attribute">border-left-style</span>: solid;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-image-source</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-slice</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-width</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-outset</span>: initial;</span><br><span class="line">    <span class="attribute">border-image-repeat</span>: initial;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gitment_title</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;</span><br></pre></td></tr></table></figure>
<h3 id="添加-Gitment-插件"><a href="#添加-Gitment-插件" class="headerlink" title="添加 Gitment 插件"></a>添加 Gitment 插件</h3><p>打开 <strong>/next/layout/_partials/comments.swig</strong> 文件, 在最后一个 <em>elseif</em> 代码块下面添加 Gitment 的内容.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面的略... ...</span></span><br><span class="line">&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125;</span><br><span class="line"> &lt;div id=<span class="string">"SOHUCS"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line"> &lt;div onclick=<span class="string">"showGitment()"</span> id=<span class="string">"gitment_title"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"gitment_title"</span>&gt;显示 Gitment 评论&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> &lt;div id="container" style="display:none"&gt;&lt;/</span>div&gt;</span><br><span class="line"> &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span><br><span class="line"> &lt;script src=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"> &lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> myTheme = &#123;</span><br><span class="line">   render(state, instance) &#123;</span><br><span class="line">     <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">     container.lang = <span class="string">"en-US"</span>;</span><br><span class="line">     container.className = <span class="string">'gitment-container gitment-root-container'</span>;</span><br><span class="line">     container.appendChild(instance.renderHeader(state, instance));</span><br><span class="line">     container.appendChild(instance.renderEditor(state, instance));</span><br><span class="line">     container.appendChild(instance.renderComments(state, instance));</span><br><span class="line">     container.appendChild(instance.renderFooter(state, instance));</span><br><span class="line">     <span class="keyword">return</span> container;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showGitment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   $(<span class="string">"#gitment_title"</span>).attr(<span class="string">"style"</span>, <span class="string">"display:none"</span>);</span><br><span class="line">   $(<span class="string">"#container"</span>).attr(<span class="string">"style"</span>, <span class="string">""</span>).addClass(<span class="string">"gitment_container"</span>);</span><br><span class="line">   <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">     id: <span class="built_in">decodeURI</span>(<span class="built_in">window</span>.location.pathname),</span><br><span class="line">     theme: myTheme,</span><br><span class="line">     owner: <span class="string">'&#123;&#123; theme.gitment.owner &#125;&#125;'</span>,</span><br><span class="line">     repo: <span class="string">'&#123;&#123; theme.gitment.repo &#125;&#125;'</span>,</span><br><span class="line">     oauth: &#123;</span><br><span class="line">       client_id: <span class="string">'&#123;&#123; theme.gitment.client_id &#125;&#125;'</span>,</span><br><span class="line">       client_secret: <span class="string">'&#123;&#123; theme.gitment.client_secret &#125;&#125;'</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   gitment.render(<span class="string">'container'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后打开 NexT 主题的_config.yml 文件，在评论相关设置的区域添加下面的代码，并根据 Gitment 文档说明来添加相应的值</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gitment comments</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  lazy:</span> <span class="literal">true</span>  <span class="comment">#lazy属性为是否直接显示评论模块，true会显示”显示评论”按钮，false会直接显示</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外，Gitment需要自己手动初始化一下来创建一个issues，不喜欢他的同学可以用<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener"><strong>Gitalk</strong></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见异常总结</title>
    <url>/2018/03/18/Java%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><h5 id="java-lang-NullPointerException-空指针异常"><a href="#java-lang-NullPointerException-空指针异常" class="headerlink" title="java.lang.NullPointerException(空指针异常)"></a>java.lang.NullPointerException(空指针异常)</h5><blockquote>
<p>调用了未经初始化的对象或者是不存在的对象</p>
</blockquote>
<p>经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，<br>即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，<br>依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。</p>
<a id="more"></a>
</li>
<li><h5 id="java-lang-ClassNotFoundException"><a href="#java-lang-ClassNotFoundException" class="headerlink" title="java.lang.ClassNotFoundException　　"></a>java.lang.ClassNotFoundException　　</h5><blockquote>
<p>指定的类不存在</p>
</blockquote>
<p> 这里主要考虑一下类的名称和路径是否正确即可，通常都是程序试图通过字符串来加载某个类时可能引发 异常<br> 比如：调用Class.forName();<br> 或者调用ClassLoad的finaSystemClass();或者LoadClass();</p>
</li>
<li><h5 id="java-lang-NumberFormatException"><a href="#java-lang-NumberFormatException" class="headerlink" title="java.lang.NumberFormatException"></a>java.lang.NumberFormatException</h5><blockquote>
<p>字符串转换为数字异常</p>
</blockquote>
<p>当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常.如现在讲字符型的数据“123456”转换为数值型数据时，是允许的。<br>但是如果字符型数据中包含了非数字型的字符，如123#56，此时转换为数值型时就会出现异常。系统就会捕捉到这个异常，并进行处理.</p>
</li>
<li><h5 id="java-lang-IndexOutOfBoundsException"><a href="#java-lang-IndexOutOfBoundsException" class="headerlink" title="java.lang.IndexOutOfBoundsException"></a>java.lang.IndexOutOfBoundsException</h5><blockquote>
<p>数组下标越界异常</p>
</blockquote>
<p>查看调用的数组或者字符串的下标值是不是超出了数组的范围，一般来说，显示（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了，还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的length，以免出现这个异常。</p>
</li>
<li><h5 id="java-lang-IllegalArgumentException"><a href="#java-lang-IllegalArgumentException" class="headerlink" title="java.lang.IllegalArgumentException"></a>java.lang.IllegalArgumentException</h5><blockquote>
<p>方法的参数错误</p>
</blockquote>
<p>比如g.setColor(int red,int green,int blue)这个方法中的三个值，如果有超过２５５的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。</p>
</li>
<li><h5 id="java-lang-IllegalAccessException"><a href="#java-lang-IllegalAccessException" class="headerlink" title="java.lang.IllegalAccessException"></a>java.lang.IllegalAccessException</h5><blockquote>
<p>没有访问权限</p>
</blockquote>
<p>当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常</p>
</li>
<li><h5 id="java-lang-ArithmeticException"><a href="#java-lang-ArithmeticException" class="headerlink" title="java.lang.ArithmeticException"></a>java.lang.ArithmeticException</h5><blockquote>
<p>数学运算异常</p>
</blockquote>
<p>当算术运算中出现了除以零这样的运算就会出这样的异常。</p>
</li>
<li><h5 id="java-lang-ClassCastException"><a href="#java-lang-ClassCastException" class="headerlink" title="java.lang.ClassCastException"></a>java.lang.ClassCastException</h5><blockquote>
<p>数据类型转换异常</p>
</blockquote>
<p>当试图将对某个对象强制执行向下转型，但该对象又不可转换又不可转换为其子类的实例时将引发该异常，如下列代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object obj = new Integer(0);</span><br><span class="line">String str = obj;</span><br><span class="line">java.lang.FileNotFoundException</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="java-lang-FileNotFoundException"><a href="#java-lang-FileNotFoundException" class="headerlink" title="java.lang.FileNotFoundException"></a>java.lang.FileNotFoundException</h5><blockquote>
<p>文件未找到异常</p>
</blockquote>
<p>当程序试图打开一个不存在的文件进行读写时将会引发该异常。该异常由FileInputStream,FileOutputStream,RandomAccessFile的构造器声明抛出<br>即使被操作的文件存在，但是由于某些原因不可访问，比如打开一个只读文件进行写入，这些构造方法仍然会引发异常</p>
</li>
<li><h5 id="java-lang-ArrayStoreException"><a href="#java-lang-ArrayStoreException" class="headerlink" title="java.lang.ArrayStoreException"></a>java.lang.ArrayStoreException</h5><blockquote>
<p>数组存储异常</p>
</blockquote>
<p>当试图将类型不兼容类型的对象存入一个Object[]数组时将引发异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object[] obj = new String[3];</span><br><span class="line">obj[0] = new Integer(0);</span><br><span class="line">java.lang.NoSuchMethodException</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="java-lang-NoSuchMethodException"><a href="#java-lang-NoSuchMethodException" class="headerlink" title="java.lang.NoSuchMethodException"></a>java.lang.NoSuchMethodException</h5><blockquote>
<p>方法不存在异常  </p>
</blockquote>
<p>当程序试图通过反射来创建对象，访问(修改或读取)某个方法，但是该方法不存在就会引发异常</p>
</li>
<li><h5 id="java-lang-NoSuchFiledException"><a href="#java-lang-NoSuchFiledException" class="headerlink" title="java.lang.NoSuchFiledException"></a>java.lang.NoSuchFiledException</h5><blockquote>
<p>方法不存在异常</p>
</blockquote>
<p>当程序试图通过反射来创建对象，访问(修改或读取)某个filed，但是该filed不存在就会引发异常</p>
</li>
<li><h5 id="java-lang-EOFException"><a href="#java-lang-EOFException" class="headerlink" title="java.lang.EOFException"></a>java.lang.EOFException</h5><blockquote>
<p>文件已结束异常</p>
</blockquote>
<p>当程序在输入的过程中遇到文件或流的结尾时，引发异常。因此该异常用于检查是否达到文件或流的结尾</p>
</li>
<li><h5 id="java-lang-InstantiationException"><a href="#java-lang-InstantiationException" class="headerlink" title="java.lang.InstantiationException"></a>java.lang.InstantiationException</h5><blockquote>
<p>实例化异常</p>
</blockquote>
<p>当试图通过Class的newInstance()方法创建某个类的实例,但程序无法通过该构造器来创建该对象时引发<br>Class对象表示一个抽象类，接口，数组类，基本类型<br>该Class表示的类没有对应的构造器</p>
</li>
<li><h5 id="java-lang-InterruptedException"><a href="#java-lang-InterruptedException" class="headerlink" title="java.lang.InterruptedException"></a>java.lang.InterruptedException</h5><blockquote>
<p>被中止异常</p>
</blockquote>
<p>当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。</p>
</li>
<li><h5 id="java-lang-CloneNotSupportedException"><a href="#java-lang-CloneNotSupportedException" class="headerlink" title="java.lang.CloneNotSupportedException"></a>java.lang.CloneNotSupportedException</h5><blockquote>
<p>不支持克隆异常</p>
</blockquote>
<p>当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。</p>
</li>
<li><h5 id="java-lang-OutOfMemoryException"><a href="#java-lang-OutOfMemoryException" class="headerlink" title="java.lang.OutOfMemoryException"></a>java.lang.OutOfMemoryException</h5><blockquote>
<p>内存不足错误</p>
</blockquote>
<p>当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</p>
</li>
<li><h5 id="java-lang-NoClassDefFoundException"><a href="#java-lang-NoClassDefFoundException" class="headerlink" title="java.lang.NoClassDefFoundException"></a>java.lang.NoClassDefFoundException</h5><blockquote>
<p>未找到类定义错误</p>
</blockquote>
<p>当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。</p>
</li>
<li><h5 id="违背安全原则异常：SecturityException"><a href="#违背安全原则异常：SecturityException" class="headerlink" title="违背安全原则异常：SecturityException"></a>违背安全原则异常：SecturityException</h5></li>
<li><h5 id="操作数据库异常：SQLException"><a href="#操作数据库异常：SQLException" class="headerlink" title="操作数据库异常：SQLException"></a>操作数据库异常：SQLException</h5></li>
<li><h5 id="输入输出异常：IOException"><a href="#输入输出异常：IOException" class="headerlink" title="输入输出异常：IOException"></a>输入输出异常：IOException</h5></li>
<li><h5 id="通信异常：SocketException"><a href="#通信异常：SocketException" class="headerlink" title="通信异常：SocketException"></a>通信异常：SocketException</h5></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下删除launchpad还有残留图标的应用</title>
    <url>/2018/05/16/Mac%E4%B8%8B%E5%88%A0%E9%99%A4launchpad%E8%BF%98%E6%9C%89%E6%AE%8B%E7%95%99%E5%9B%BE%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>有时候用户在删除自己应用的时候在应用程序里直接右键“移到废纸楼”，有的应用这样删除后在launchpad里还有残留的图标，按住option键也没有删除标记可以删除该图标。这让人很蛋疼，但是可以通过下面这个小技巧将该图标删除，方法如下：<br><a id="more"></a></p>
<h2 id="打开launchpad"><a href="#打开launchpad" class="headerlink" title="打开launchpad"></a>打开launchpad</h2><p>下列三个放都可以打开launchpad  </p>
<ol>
<li>fn + F4（F1-F12是正常使用情况）  </li>
<li>F4（F1-F12使用需要借助fn键使用）  </li>
<li>四个指头抓一下  </li>
</ol>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h4 id="1-长按control-option-command，看到图标抖动"><a href="#1-长按control-option-command，看到图标抖动" class="headerlink" title="1. 长按control+option+command，看到图标抖动"></a>1. 长按control+option+command，看到图标抖动</h4><h4 id="2-单击待删除图标，图标中心出现白色问号"><a href="#2-单击待删除图标，图标中心出现白色问号" class="headerlink" title="2. 单击待删除图标，图标中心出现白色问号"></a>2. 单击待删除图标，图标中心出现白色问号</h4><h4 id="3-松开按住的三个快捷键（control-option-command）"><a href="#3-松开按住的三个快捷键（control-option-command）" class="headerlink" title="3. 松开按住的三个快捷键（control+option+command）"></a>3. 松开按住的三个快捷键（control+option+command）</h4><h4 id="4-再次按下这三个快捷键，图标左上角会出现“✘”，点击删除"><a href="#4-再次按下这三个快捷键，图标左上角会出现“✘”，点击删除" class="headerlink" title="4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除"></a>4. 再次按下这三个快捷键，图标左上角会出现“✘”，点击删除</h4>]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac删除</tag>
        <tag>launchpad</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的StreamsAPI详解</title>
    <url>/2018/09/30/Java8%E4%B8%AD%E7%9A%84StreamsAPI%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java-8-中的-Streams-API-详解"><a href="#Java-8-中的-Streams-API-详解" class="headerlink" title="Java 8 中的 Streams API 详解"></a>Java 8 中的 Streams API 详解</h1><h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data     operation)。</p>
<a id="more"></a>
<p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p>
<p>所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p>
<h3 id="什么是聚合操作"><a href="#什么是聚合操作" class="headerlink" title="什么是聚合操作"></a>什么是聚合操作</h3><p>在传统的 J2EE 应用中，Java 代码经常不得不依赖于关系型数据库的聚合操作来完成诸如：  </p>
<ul>
<li>客户每月平均消费金额</li>
<li>最昂贵的在售商品</li>
<li>本周完成的有效订单（排除了无效的）</li>
<li>取十个数据样本作为首页推荐  </li>
</ul>
<p>这类的操作。</p>
<p>但在当今这个数据大爆炸的时代，在数据来源多样化、数据海量化的今天，很多时候不得不脱离 RDBMS，或者以底层返回的数据为基础进行更上层的数据统计。而 Java 的集合 API     中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。这是一种远不够高效、笨拙的方法。在 Java 7 中，如果要发现 type 为     grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p>
<p>清单 1. Java 7 的排序、取值实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Transaction&gt; groceryTransactions = <span class="keyword">new</span> Arraylist&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: transactions)&#123;</span><br><span class="line"> <span class="keyword">if</span>(t.getType() == Transaction.GROCERY)&#123;</span><br><span class="line"> groceryTransactions.add(t);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(groceryTransactions, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Transaction t1, Transaction t2)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> t2.getValue().compareTo(t1.getValue());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;Integer&gt; transactionIds = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Transaction t: groceryTransactions)&#123;</span><br><span class="line"> transactionsIds.add(t.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。</p>
<p>清单 2. Java 8 的排序、取值实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = transactions.parallelStream().</span><br><span class="line"> filter(t -&gt; t.getType() == Transaction.GROCERY).</span><br><span class="line"> sorted(comparing(Transaction::getValue).reversed()).</span><br><span class="line"> map(Transaction::getId).</span><br><span class="line"> collect(toList());</span><br></pre></td></tr></table></figure>
<h2 id="Stream-总览"><a href="#Stream-总览" class="headerlink" title="Stream 总览"></a>Stream 总览</h2><h3 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h3><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的     Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10     的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个     item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join     框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<p>1 1.0-1.4 中的 java.lang.Thread</p>
<p>2 5.0 中的 java.util.concurrent</p>
<p>3 6.0 中的 Phasers 等</p>
<p>4 7.0 中的 Fork/Join 框架</p>
<p>5 8.0 中的 Lambda</p>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h3 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h3><p>当我们使用一个流的时候，通常包括三个基本步骤：</p>
<p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream     对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道，如下图所示。</p>
<p>图 1. 流管道 (Stream Pipeline) 的构成</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/java8中的streamsapi详解/1.png" alt="流管道 (Stream Pipeline) 的构成"></p>
<p>有多种方式生成 Stream Source：</p>
<ul>
<li>从 Collection 和数组<ul>
<li>Collection.stream()</li>
<li>Collection.parallelStream()</li>
<li>Arrays.stream(T array) or Stream.of()</li>
</ul>
</li>
<li>从 BufferedReader<ul>
<li>java.io.BufferedReader.lines()</li>
</ul>
</li>
<li>静态工厂<ul>
<li>java.util.stream.IntStream.range()</li>
<li>java.nio.file.Files.walk()</li>
</ul>
</li>
<li>自己构建<ul>
<li>java.util.Spliterator</li>
</ul>
</li>
<li>其它<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
</ul>
</li>
</ul>
<p>流的操作类型分为两种：</p>
<ul>
<li><p><strong>Intermediate</strong>：一个流可以后面跟随零个或多个 intermediate      操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
</li>
<li><p><strong>Terminal</strong>：一个流只能有一个 terminal      操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
</li>
</ul>
<p>在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>还有一种操作被称为 <strong>short-circuiting</strong>。用以指：</p>
<ul>
<li><p>对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。</p>
</li>
<li><p>对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。</p>
</li>
</ul>
<p>当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。</p>
<p>清单 3. 一个流操作的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">.filter(w -&gt; w.getColor() == RED)</span><br><span class="line"> .mapToInt(w -&gt; w.getWeight())</span><br><span class="line"> .sum();</span><br></pre></td></tr></table></figure>
<p>stream() 获取当前小物件的 source，filter 和 mapToInt 为 intermediate 操作，进行数据筛选和转换，最后一个 sum() 为 terminal     操作，对符合条件的全部小物件作重量求和。</p>
<h2 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h2><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p>
<h3 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h3><p>下面提供最常见的几种构造 Stream 的样例。</p>
<p>清单 4. 构造流的几种常见方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Individual values</span></span><br><span class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"><span class="comment">// 2. Arrays</span></span><br><span class="line">String [] strArray = <span class="keyword">new</span> String[] &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">stream = Stream.of(strArray);</span><br><span class="line">stream = Arrays.stream(strArray);</span><br><span class="line"><span class="comment">// 3. Collections</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure>
<p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p>
<p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream&lt;Integer>、Stream&lt;Long>、Stream&lt;Double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p>
<p>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p>
<p>清单 5. 数值流的构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).forEach(System.out::println);</span><br><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>清单 6. 流转换为其它数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Array</span></span><br><span class="line">String[] strArray1 = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 2. Collection</span></span><br><span class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">Set set1 = stream.collect(Collectors.toSet());</span><br><span class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::<span class="keyword">new</span>));</span><br><span class="line"><span class="comment">// 3. String</span></span><br><span class="line">String str = stream.collect(Collectors.joining()).toString();</span><br></pre></td></tr></table></figure>
<p>一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。</p>
<h3 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h3><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p>
<ul>
<li>Intermediate：</li>
</ul>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、     sequential、 unordered</p>
<ul>
<li>Terminal：</li>
</ul>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、     allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
<ul>
<li>Short-circuiting：</li>
</ul>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
<p>我们下面看一下 Stream 的比较典型用法。</p>
<p><strong>map/flatMap</strong>  </p>
<p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p>
<p>清单 7. 转换大写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = wordList.stream().</span><br><span class="line">map(String::toUpperCase).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码把所有的单词转换为大写。</p>
<p>清单 8. 平方数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Integer&gt; squareNums = nums.stream().</span><br><span class="line">map(n -&gt; n * n).</span><br><span class="line">collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p>
<p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<p>清单 9. 一对多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line"> Arrays.asList(<span class="number">1</span>),</span><br><span class="line"> Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"> );</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.</span><br><span class="line">flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>
<p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p>
<p><strong>filter</strong>  </p>
<p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p>
<p>清单 10. 留下偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] sixNums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">Integer[] evens =</span><br><span class="line">Stream.of(sixNums).filter(n -&gt; n%<span class="number">2</span> == <span class="number">0</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>经过条件“被 2 整除”的 filter，剩下的数字为 {2, 4, 6}。</p>
<p>清单 11. 把单词挑出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; output = reader.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(REGEXP))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p>
<p><strong>forEach</strong>  </p>
<p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p>
<p>清单 12. 打印姓名（forEach 和 pre-java8 的对比）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">roster.stream()</span><br><span class="line"> .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line"> .forEach(p -&gt; System.out.println(p.getName()));</span><br><span class="line"><span class="comment">// Pre-Java 8</span></span><br><span class="line"><span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line"> <span class="keyword">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class="line"> System.out.println(p.getName());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda     表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p>
<p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p>
<p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.forEach(element -&gt; doOneThing(element));</span><br><span class="line">stream.forEach(element -&gt; doAnotherThing(element));</span><br></pre></td></tr></table></figure>
<p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p>
<p>清单 13. peek 对每个元素执行操作并返回一个新的 Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line"> .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line"> .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p>
<p><strong>findFirst</strong>  </p>
<p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>
<p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免     NullPointerException。</p>
<p>清单 14. Optional 的两个用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String strA = <span class="string">" abcd "</span>, strB = <span class="keyword">null</span>;</span><br><span class="line">print(strA);</span><br><span class="line">print(<span class="string">""</span>);</span><br><span class="line">print(strB);</span><br><span class="line">getLength(strA);</span><br><span class="line">getLength(<span class="string">""</span>);</span><br><span class="line">getLength(strB);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Java 8</span></span><br><span class="line"> Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line"> <span class="comment">// Pre-Java 8</span></span><br><span class="line"> <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line"> System.out.println(text);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Java 8</span></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// Pre-Java 8</span></span><br><span class="line"><span class="comment">// return if (text != null) ? text.length() : -1;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p>
<p><strong>reduce</strong>  </p>
<p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n     个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p>
<p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p>
<p>Integer sum = integers.reduce(0, Integer::sum);</p>
<p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<p>清单 15. reduce 的用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = "ABCD"</span></span><br><span class="line">String concat = Stream.of(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>).reduce(<span class="string">""</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = "ace"</span></span><br><span class="line">concat = Stream.of(<span class="string">"a"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"F"</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">"Z"</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">""</span>, String::concat);</span><br></pre></td></tr></table></figure>
<p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce()     都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p>
<p><strong>limit/skip</strong>  </p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）。</p>
<p>清单 16. limit 和 skip 对运行次数的影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimitAndSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;String&gt; personList2 = persons.stream().</span><br><span class="line">map(Person::getName).limit(<span class="number">10</span>).skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"> System.out.println(personList2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.no = no;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(name);</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name1</span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">name4</span><br><span class="line">name5</span><br><span class="line">name6</span><br><span class="line">name7</span><br><span class="line">name8</span><br><span class="line">name9</span><br><span class="line">name10</span><br><span class="line">[name4, name5, name6, name7, name8, name9, name10]</span><br></pre></td></tr></table></figure>
<p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName()     方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p>
<p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate     操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p>
<p>清单 17. limit 和 skip 对 sorted 后的运行次数无影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; </span><br><span class="line">p1.getName().compareTo(p2.getName())).limit(<span class="number">2</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>
<p>上面的示例对清单 13 做了微调，首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">name3</span><br><span class="line">name2</span><br><span class="line">name4</span><br><span class="line">name3</span><br><span class="line">name5</span><br><span class="line">name4</span><br><span class="line">[stream.StreamDW$Person@<span class="number">816f</span>27d, stream.StreamDW$Person@<span class="number">87</span>aac27]</span><br></pre></td></tr></table></figure>
<p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p>
<p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p>
<p><strong>sorted</strong></p>
<p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct     来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p>
<p>清单 18. 优化：排序前进行 limit 和 skip</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"> Person person = <span class="keyword">new</span> Person(i, <span class="string">"name"</span> + i);</span><br><span class="line"> persons.add(person);</span><br><span class="line"> &#125;</span><br><span class="line">List&lt;Person&gt; personList2 = persons.stream().limit(<span class="number">2</span>).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());</span><br><span class="line">System.out.println(personList2);</span><br></pre></td></tr></table></figure>
<p>结果会简单很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name2</span><br><span class="line">name1</span><br><span class="line">[stream.StreamDW$Person@<span class="number">6</span>ce253f1, stream.StreamDW$Person@<span class="number">53</span>d8d10a]</span><br></pre></td></tr></table></figure>
<p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p>
<p><strong>min/max/distinct</strong></p>
<p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p>
<p>清单 19. 找出最长一行的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\SUService.log"</span>));</span><br><span class="line"><span class="keyword">int</span> longest = br.lines().</span><br><span class="line"> mapToInt(String::length).</span><br><span class="line"> max().</span><br><span class="line"> getAsInt();</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(longest);</span><br></pre></td></tr></table></figure>
<p>下面的例子则使用 distinct 来找出不重复的单词。</p>
<p>清单 20. 找出全文的单词，转小写，并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words = br.lines().</span><br><span class="line"> flatMap(line -&gt; Stream.of(line.split(<span class="string">" "</span>))).</span><br><span class="line"> filter(word -&gt; word.length() &gt; <span class="number">0</span>).</span><br><span class="line"> map(String::toLowerCase).</span><br><span class="line"> distinct().</span><br><span class="line"> sorted().</span><br><span class="line"> collect(Collectors.toList());</span><br><span class="line">br.close();</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>
<p><strong>Match</strong></p>
<p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li>
</ul>
<p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p>
<p>清单 21. 使用 Match</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList();</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"name"</span> + <span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"name"</span> + <span class="number">2</span>, <span class="number">21</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">3</span>, <span class="string">"name"</span> + <span class="number">3</span>, <span class="number">34</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">4</span>, <span class="string">"name"</span> + <span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line">persons.add(<span class="keyword">new</span> Person(<span class="number">5</span>, <span class="string">"name"</span> + <span class="number">5</span>, <span class="number">55</span>));</span><br><span class="line"><span class="keyword">boolean</span> isAllAdult = persons.stream().</span><br><span class="line"> allMatch(p -&gt; p.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"All are adult? "</span> + isAllAdult);</span><br><span class="line"><span class="keyword">boolean</span> isThereAnyChild = persons.stream().</span><br><span class="line"> anyMatch(p -&gt; p.getAge() &lt; <span class="number">12</span>);</span><br><span class="line">System.out.println(<span class="string">"Any child? "</span> + isThereAnyChild);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">All are adult? <span class="keyword">false</span></span><br><span class="line">Any child? <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p>
<p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier     实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用     limit 之类的操作限制 Stream 大小。</p>
<p>清单 22. 生成 10 个随机整数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random seed = <span class="keyword">new</span> Random();</span><br><span class="line">Supplier&lt;Integer&gt; random = seed::nextInt;</span><br><span class="line">Stream.generate(random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//Another way</span></span><br><span class="line">IntStream.generate(() -&gt; (<span class="keyword">int</span>) (System.nanoTime() % <span class="number">100</span>)).</span><br><span class="line">limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream     的每个元素值。这些都是维持状态信息的情形。</p>
<p>清单 23. 自实现 Supplier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line">limit(<span class="number">10</span>).</span><br><span class="line">forEach(p -&gt; System.out.println(p.getName() + <span class="string">", "</span> + p.getAge()));</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Person <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Person(index++, <span class="string">"StormTestUser"</span> + index, random.nextInt(<span class="number">100</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StormTestUser1, <span class="number">9</span></span><br><span class="line">StormTestUser2, <span class="number">12</span></span><br><span class="line">StormTestUser3, <span class="number">88</span></span><br><span class="line">StormTestUser4, <span class="number">51</span></span><br><span class="line">StormTestUser5, <span class="number">22</span></span><br><span class="line">StormTestUser6, <span class="number">28</span></span><br><span class="line">StormTestUser7, <span class="number">81</span></span><br><span class="line">StormTestUser8, <span class="number">51</span></span><br><span class="line">StormTestUser9, <span class="number">4</span></span><br><span class="line">StormTestUser10, <span class="number">76</span></span><br></pre></td></tr></table></figure>
<p><strong>Stream.iterate</strong></p>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed)     为第二个，f(f(seed)) 第三个，以此类推。</p>
<p>清单 24. 生成一个等差数列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">3</span>).limit(<span class="number">10</span>). forEach(x -&gt; System.out.print(x + <span class="string">" "</span>));.</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">6</span> <span class="number">9</span> <span class="number">12</span> <span class="number">15</span> <span class="number">18</span> <span class="number">21</span> <span class="number">24</span> <span class="number">27</span></span><br></pre></td></tr></table></figure>
<p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>
<h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。<br>groupingBy/partitioningBy</p>
<p>清单 25. 按照年龄归组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line"> limit(<span class="number">100</span>).</span><br><span class="line"> collect(Collectors.groupingBy(Person::getAge));</span><br><span class="line">Iterator it = personGroups.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line"> Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next();</span><br><span class="line"> System.out.println(<span class="string">"Age "</span> + persons.getKey() + <span class="string">" = "</span> + persons.getValue().size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Age <span class="number">0</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">5</span> = <span class="number">2</span></span><br><span class="line">Age <span class="number">8</span> = <span class="number">1</span></span><br><span class="line">Age <span class="number">9</span> = <span class="number">1</span></span><br><span class="line">Age <span class="number">11</span> = <span class="number">2</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>清单 26. 按照未成年人和成年人归组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(<span class="keyword">new</span> PersonSupplier()).</span><br><span class="line">limit(<span class="number">100</span>).</span><br><span class="line"> collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; <span class="number">18</span>));</span><br><span class="line">System.out.println(<span class="string">"Children number: "</span> + children.get(<span class="keyword">true</span>).size());</span><br><span class="line">System.out.println(<span class="string">"Adult number: "</span> + children.get(<span class="keyword">false</span>).size());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Children number: <span class="number">23</span> </span><br><span class="line">Adult number: <span class="number">77</span></span><br></pre></td></tr></table></figure>
<p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的     groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总之，Stream 的特性可以归纳为：</p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的</li>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream        进行运算并很快完成。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams API</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上用QuickTimePlayer和Soundflower插件录制完美视频</title>
    <url>/2019/04/10/Mac%E4%B8%8A%E7%94%A8QuickTimePlayer%E5%92%8CSoundflower%E6%8F%92%E4%BB%B6%E5%BD%95%E5%88%B6%E5%AE%8C%E7%BE%8E%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/0.png" alt="logo"></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MacOS自带的QuickTime Player录制视频的时候默认是不会有内部视频里的音频的，默认情况下除非你开到最大声，然后通过内置的麦克风“听到”，又录进到视频。这是很傻X的。<br>今天整理了一下可以录制到音视频的两个方法：</p>
<blockquote>
<ol>
<li>录制只有屏内音频视频的方法  </li>
<li>录制有屏内音频和屏外声音视频的方法</li>
</ol>
</blockquote>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote>
<p>软件： Soundflower 小插件<br>操作系统：macOS<br>其他：一个聪明的脑袋  </p>
</blockquote>
<h2 id="1-下载Soundflower并安装"><a href="#1-下载Soundflower并安装" class="headerlink" title="1. 下载Soundflower并安装"></a>1. 下载<a href="https://github.com/mattingalls/Soundflower/releases" target="_blank" rel="noopener">Soundflower</a>并安装</h2><p>点击上面这个链接，进入GitHub选择下载<code>Soundflower-2.0b2.dmg</code>(版本可能不一样)</p>
<p>下载完成后，无脑安装，再次期间可能会提示<code>提示来自身份不明的开发者</code>，这个时候不要慌，打开系统偏好设置-&gt;安全性与隐私，选择“仍要打开”（此时我们在“通用”选项卡）</p>
<p>在这里我们顺便检查一下，QuickTime Player的麦克风权限。打开系统偏好设置-&gt;安全性与隐私-&gt;选择“隐私”选项卡，选择左侧的“麦克风”选项，看右侧的“QuickTime Player”有没有勾上对勾，没有的话把它勾上</p>
<p>到这里Soundflower基本就算安装好了，接下来开始设置</p>
<h2 id="2-设置"><a href="#2-设置" class="headerlink" title="2. 设置"></a>2. 设置</h2><p>设置我们需要打开<code>音频 MIDI 设置</code>这个Mac自带的软件：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/1.png" alt="音频MIDI设置"></p>
<h3 id="2-1-创建多输出设备并设置"><a href="#2-1-创建多输出设备并设置" class="headerlink" title="2.1 创建多输出设备并设置"></a>2.1 创建<code>多输出设备</code>并设置</h3><p>点击左下角“+”，选择“创建多输出设备”，按如图所示设置：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/2.png" alt="创建多输出设备"></p>
<h3 id="2-2-创建只有屏内音频的配置（创建聚集设备）"><a href="#2-2-创建只有屏内音频的配置（创建聚集设备）" class="headerlink" title="2.2 创建只有屏内音频的配置（创建聚集设备）"></a>2.2 创建<code>只有屏内音频</code>的配置（创建聚集设备）</h3><p>点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/3.png" alt="只有屏内音频"></p>
<h3 id="2-3-创建屏内音频和屏外声音的配置（创建聚集设备）"><a href="#2-3-创建屏内音频和屏外声音的配置（创建聚集设备）" class="headerlink" title="2.3 创建屏内音频和屏外声音的配置（创建聚集设备）"></a>2.3 创建<code>屏内音频和屏外声音</code>的配置（创建聚集设备）</h3><p>点击左下角“+”，选择“创建聚集设备”，将默认名称（聚集设备）改为自己的名称，以区分另外一个聚集设备，按如图所示设置：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/4.png" alt="屏内音频和屏外声音"></p>
<h2 id="3-录制"><a href="#3-录制" class="headerlink" title="3. 录制"></a>3. 录制</h2><p>录制时因为分为两种不同的方式，所以在录制是设置稍有不同，我大致总结如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.录制只有内部音频</span><br><span class="line">    QuickTime：</span><br><span class="line">        选择对应的设置(录屏专用-内部音频)  ✔️</span><br><span class="line">        音量最小  （调大会有回音，默认最小即可）</span><br><span class="line">    扬声器输出：</span><br><span class="line">        多输出设备   ✔️</span><br><span class="line"></span><br><span class="line">2.录制有内外部音频</span><br><span class="line">    QuickTime：</span><br><span class="line">        选择对应的设置(录屏专用-内外部音频)  ✔️</span><br><span class="line">        音量最小  （调大会有回音，默认最小即可）</span><br><span class="line">    扬声器：</span><br><span class="line">        多输出设备（内外声音结合很好，效果好） ✔️</span><br><span class="line">        内置扬声器（内部音频不明显，人声大，内部声音小，效果不好）  </span><br><span class="line">        刚才建的两个选项（自己听不到声音，但是录完屏后视频内有声音）</span><br></pre></td></tr></table></figure>
<p>看不懂的同学请往下看</p>
<h3 id="3-1-录制只有屏内音频视频的方法"><a href="#3-1-录制只有屏内音频视频的方法" class="headerlink" title="3.1 录制只有屏内音频视频的方法"></a>3.1 录制只有屏内音频视频的方法</h3><p>打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内部音频”，音量选项保持最小(调大会有回音，默认最小即可）</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/5.png" alt="录屏专用-内部音频"></p>
<p>点击右上角“小喇叭”并选择“多输出设备”：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/6.png" alt="多输出设备1"></p>
<p>如果没有小喇叭可以打开系统偏好设置-&gt;声音-&gt;选择输出选项卡，选中“多输出设备”。最后把“在菜单栏中显示音量”选中即可，方便以后使用</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/7.png" alt="多输出设备2"></p>
<p>至此，点击开始，录制你的视频吧</p>
<h3 id="3-2-录制有屏内音频和屏外声音视频的方法"><a href="#3-2-录制有屏内音频和屏外声音视频的方法" class="headerlink" title="3.2 录制有屏内音频和屏外声音视频的方法"></a>3.2 录制有屏内音频和屏外声音视频的方法</h3><p>打开QuickTime Player，右键“新建屏幕录制”，选择“录屏专用-内外部音频”，音量选项保持最小(调大会有回音，默认最小即可）</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/8.png" alt="录屏专用-内外部音频"></p>
<p>点击右上角“小喇叭”并选择“多输出设备”：</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac上用QuickTimePlayer和Soundflower插件录制完美视频/6.png" alt="多输出设备3"></p>
<p>剩下的其他选项：</p>
<blockquote>
<p>内置扬声器（内部音频不明显，人声大，内部声音小，效果不好）<br>刚才建的两个选项(录屏专用-内部音频/录屏专用-内外部音频)，自己听不到声音，但是录完屏后视频内有声音（感觉这个适合用来夜深人静的时候录~）</p>
</blockquote>
<p>至此，点击开始，录制你的视频吧</p>
<h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><p>如果同学你机器上装有 <code>homebrew</code> 和 <code>homebrew cask</code>，可以直接用如下命令安装Soundflower：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew cask install soundflower</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>录视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac安装软件时提示已损坏的解决方法</title>
    <url>/2018/09/27/Mac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%97%B6%E6%8F%90%E7%A4%BA%E5%B7%B2%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>从网上下载的常用软件，安装时总是提示“已损坏，移至废纸篓”这类信息，无法打开。如下图：<br><img src="https://DaiHuiBlog.github.io/images/posts/Mac安装软件时提示已损坏的解决方法/1.png" alt="已损坏">  </p>
<a id="more"></a>
<p>这是新系统（macOS Sierra 10.12.X）惹的祸。新系统加强了安全机制，默认不允许用户自行下载安装应用程序，只能从Mac App Store里安装应用。</p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><p>打开终端，在终端中输入：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure></p>
<p>输入密码，回车。搞定<br><img src="https://DaiHuiBlog.github.io/images/posts/Mac安装软件时提示已损坏的解决方法/2.png" alt="已损坏">  </p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>文件损坏</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下利用GCP和v2ray搭建无限使用梯子</title>
    <url>/2019/02/18/Mac%E4%B8%8B%E5%88%A9%E7%94%A8GCP%E5%92%8Cv2ray%E6%90%AD%E5%BB%BA%E6%97%A0%E9%99%90%E4%BD%BF%E7%94%A8%E6%A2%AF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>妈妈再也不用为我担心没梯子用了</p>
<a id="more"></a>
<h2 id="新用户申请GCP-Google-Cloud-Platform"><a href="#新用户申请GCP-Google-Cloud-Platform" class="headerlink" title="新用户申请GCP(Google Cloud Platform) "></a><a href="https://cloud.google.com/free/?hl=zh-cn" target="_blank" rel="noopener">新用户申请GCP(Google Cloud Platform) </a></h2><ul>
<li>这一步很蛋疼，需要先fq，所以小伙伴们可以先借同事或朋友的梯子注册一下来搞。总之，先注册上GCP</li>
<li>进去之后按照步骤填写信息。在最后需要小伙伴填写一个信用卡号，用来验证和今后扣取费用（我们这里只需要验证，右边的提示也说不会自动扣费）</li>
<li>关于信用卡，小伙伴们可以上<strong>某宝</strong>买一个，直接搜“<strong>虚拟信用卡</strong>”，大概在25元左右一个。一般来说店小二会给你提供包括：<strong>持卡人</strong>、<strong>卡号</strong>、<strong>卡有效期</strong>、<strong>CVV</strong>和<strong>账单地址</strong>等信息。这些信息在注册GCP时按照店小二给你发的如实填写即可。<em>注：地区最好和店小二发给你的保持一致</em>。</li>
<li>假设到这里没问题的话，点击注册，你就会得到一个为期365天的试用期，里面有300刀。</li>
</ul>
<h2 id="创建MV实例"><a href="#创建MV实例" class="headerlink" title="创建MV实例"></a>创建MV实例</h2><ul>
<li>进入 “导航菜单”-&gt;“Compute Engine”-&gt;”VM 实例”，选择“VM 实例”。首次进来可能需要初始化一下，初始化后点击“创建”来创建我们的VM；如果以前用过的话直接点击创建实例即可。</li>
<li><p>进入到创建实例界面，按照步骤填写即可，这里给个建议：</p>
<ul>
<li><p>区域，最好选一个里你进的地方，比如香港，台湾，东京等地；机器类型</p>
</li>
<li><p>机器类型，选择<strong>微型</strong>即可，够用且便宜</p>
</li>
<li><p>启动磁盘，<strong>默认</strong>即可</p>
</li>
<li><p>防火墙，“<strong>允许HTTP流量</strong>”和“<strong>允许HTTPS流量</strong>”都勾上</p>
</li>
<li><p>展开防火墙管理，选择“网络”，并在“网络标记”处填入防火墙出入站规则名称，分别为“<strong>ruzhan</strong>”和”<strong>chuzhan</strong>“（咱们先填写，后面再创建）</p>
</li>
</ul>
</li>
<li><p>点击创建，完成MV创建</p>
</li>
</ul>
<h2 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h2><ul>
<li><p>点击新创建的实例的连接“<strong>SSH</strong>”，登入远程连接。登入后做一下几个准备操作：<br><img src="https://DaiHuiBlog.github.io/images/posts/Mac下利用GCP和v2ray搭建无限使用梯子/2.png" alt="SSH">  </p>
<ul>
<li><p>切换为管理员，<strong>sudo -i</strong></p>
</li>
<li><p>执行”date -R”查看当前时间和服务器是否一致（一般都不一致）</p>
</li>
<li><p>以服务器在<em>上海</em>的为例，执行一下命令将时间同步一下 “<strong>cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</strong>“，执行后查看当前时间是否一致“<strong>date -R</strong>”，这个时候发现时间已经同步了</p>
</li>
<li><p>接下来开始安装v2ray，咱们直接执行官方提供的脚本命令”<strong>bash &lt;(curl -L -s <a href="https://install.direct/go.sh" target="_blank" rel="noopener">https://install.direct/go.sh</a>)</strong>“</p>
</li>
<li><p>等待安装完毕，配置v2ray的配置文件位置在”/etc/v2ray/config.json”，里面已经有一个官方默认配置好的配置，我们先把内容删除，都是基本vi操作。打开”vi /etc/v2ray/config.json“，按”dd“删除了第一行，后面的可以直接按”.”把剩下的内容删完。</p>
</li>
<li><p>此时咱们打开<a href="https://intmainreturn0.com/v2ray-config-gen/#" target="_blank" rel="noopener">v2ray配置生成器</a>，<strong>设置</strong>填写建议如下：</p>
<ul>
<li>服务种类：默认</li>
<li>用户设置-&gt;用户uuid：多点几下</li>
<li>用户设置-&gt;使用的alterID数量：随意，我填了101</li>
<li>端口设置-&gt;端口号：随意，找一个不太会被占用的</li>
</ul>
</li>
<li><p>点击<strong>服务端配置</strong>的<strong>复制配置</strong>，将该配置粘贴到”/etc/v2ray/config.json“，在删完内容的配置文件里按下”i”，直接command+v粘贴即可</p>
</li>
<li><p>依次按下 ”ESC“+”:wq“+回车，保存退出</p>
</li>
<li><p>重启v2ray服务，”<strong>sudo systemctl restart v2ray</strong>“</p>
</li>
<li><p>查看v2ray运行状态，”<strong>service v2ray status</strong>“，看到此时已经是”Active: active (running)“</p>
</li>
<li><p>到此MV基本配置完成，接下来配置两个出入站规则</p>
</li>
</ul>
</li>
</ul>
<h2 id="出入站防火墙搭建"><a href="#出入站防火墙搭建" class="headerlink" title="出入站防火墙搭建"></a>出入站防火墙搭建</h2><ul>
<li><p>进入 “导航菜单”-&gt;“VPC网络”-&gt;”防火墙规则”，点击”创建防火墙规则“，分别创建出站和入站规则，如下图：</p>
</li>
<li><p>出站规则  </p>
</li>
</ul>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac下利用GCP和v2ray搭建无限使用梯子/3.png" alt="出站规则">  </p>
<ul>
<li>入站规则</li>
</ul>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac下利用GCP和v2ray搭建无限使用梯子/4.png" alt="入站规则">  </p>
<ul>
<li>回到MV实例，单击MV实例的名称，进入到MV实例详情页面，点击”<strong>修改</strong>“，如果在<strong>创建VM实例</strong>步骤没有配置”<strong>网络标记</strong>“选项，在这里把出入站规则名称填入其中，保存即可；因为在<strong>创建VM实例</strong>时已经把出入站名称填好了，这里就不用设置了</li>
</ul>
<h2 id="配置Mac端v2ray客户端配置信息"><a href="#配置Mac端v2ray客户端配置信息" class="headerlink" title="配置Mac端v2ray客户端配置信息"></a>配置Mac端v2ray客户端配置信息</h2><ul>
<li><p>没有客户端的小伙伴可以<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">自行下载</a>，Mac端可以用brew安装”<strong>brew cask install v2rayx</strong>“</p>
</li>
<li><p>安装完毕，打开软件配置。点击”Configure…“，配置可参考我的：</p>
</li>
</ul>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac下利用GCP和v2ray搭建无限使用梯子/5.png" alt="Configure">  </p>
<ul>
<li>配置完成，选择”Global Mode“，再点击”local core“，完成！剩下的你懂的</li>
</ul>
<h2 id="续命"><a href="#续命" class="headerlink" title="续命"></a>续命</h2><ul>
<li>当你试用账号快到期的时候，进入“导航菜单”-&gt;“结算”-&gt;”显示信息面板“，将结算账号管理员删除，过个5、6分钟后再次申请试用账号即可，而且你的VM也还在</li>
</ul>
<p><img src="https://DaiHuiBlog.github.io/images/posts/Mac下利用GCP和v2ray搭建无限使用梯子/6.png" alt="Configure"></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>梯子</tag>
        <tag>v2ray</tag>
        <tag>GCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下安装mysql5.7完整步骤及问题整理</title>
    <url>/2018/03/19/Mac%E4%B8%8B%E5%AE%89%E8%A3%85mysql5-7%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>参考以下这个博客:  </p>
<p><a href="http://www.jb51.net/article/103841.htm" target="_blank" rel="noopener">Mac下安装mysql5.7完整步骤</a></p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li><p>“MAC下安装Mysql找不到my.cnf配置文件的问题”，参考：<br><a href="http://blog.csdn.net/jyongchong/article/details/77862819" target="_blank" rel="noopener">MAC 安装MySQL的my.cnf配置文件</a></p>
</li>
<li><p>“Warning: World-writable config file ‘/etc/my.cnf’ is ignored”，参考：<br><a href="http://blog.csdn.net/xeay123/article/details/44127951" target="_blank" rel="noopener">World-writable</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac安装Mysql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac远程连接谷歌云VM实例</title>
    <url>/2019/02/19/Mac%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%B7%E6%AD%8C%E4%BA%91VM%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>一般在管理远程主机时，都用ssh登录，ssh user@host，但是这样每次会使用密码。 使用ssh-keygen生成的密钥对，然后将公钥添加的目标主机的~/.ssh/authorized_keys文件中，当前主机就成为可信任的主机，下次使用ssh登录时，就不用输入密码了<br>官方网站的教程很详细，但是表达方式不是很好理解，并且有的功能在操作上第一次用GCP的我来说有点陌生，这里就Linux或Mac连接VM实例方式作一个简要记录（全是大白话）</p>
<a id="more"></a>
<h2 id="第一步-生成密钥对"><a href="#第一步-生成密钥对" class="headerlink" title="第一步:生成密钥对"></a>第一步:生成密钥对</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/.ssh/秘钥名称 -C "邮箱"</span><br></pre></td></tr></table></figure>
<p>这样就在主目录下的.ssh目录中生成了两个文件“秘钥名称”和“秘钥名称.pub”。“秘钥名称”中保存的是私钥，”秘钥名称.pub“中保存的是公钥。</p>
<h2 id="第二步-添加公钥"><a href="#第二步-添加公钥" class="headerlink" title="第二步:添加公钥"></a>第二步:添加公钥</h2><p>拷贝公钥到剪切板:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pbcopy &lt; 秘钥名称.pub</span><br></pre></td></tr></table></figure></p>
<p>在GPC导航菜单中找到”元数据“连接，选择”SSH秘钥“选项卡-&gt;点击”修改“按钮-&gt;”添加一项“，粘贴公钥，保存，就添加完成了。</p>
<h2 id="第三步-测试"><a href="#第三步-测试" class="headerlink" title="第三步:测试"></a>第三步:测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -i ~/.ssh/秘钥名称 用户名@VM外部IP</span><br></pre></td></tr></table></figure>
<ul>
<li>用户名，在第二部添加公钥时，粘贴之后会在第一列出现你的用户名</li>
</ul>
<p>如果没问题的话你已经进入到VM实例终端了</p>
<p>同样的方式gitlab和GitHub也是支持的</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>GCP</tag>
        <tag>谷歌云</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm 2和Oh My Zsh代替自带terminal教程简单整理</title>
    <url>/2018/04/02/iTerm-2%E5%92%8COh-My-Zsh%E4%BB%A3%E6%9B%BF%E8%87%AA%E5%B8%A6terminal%E6%95%99%E7%A8%8B%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h4 id="最终效果图大概是这个样子："><a href="#最终效果图大概是这个样子：" class="headerlink" title="最终效果图大概是这个样子："></a>最终效果图大概是这个样子：</h4><p><img src="https://DaiHuiBlog.github.io/images/posts/iTerm 2和Oh My Zsh代替自带terminal教程简单整理/1.png" alt="avatar">  </p>
<a id="more"></a>
<p>但是如果你有用到Atom编辑器的控制台插件的话可能会由于字体原因特殊的符号显示不了，就像我这样：<br><img src="https://DaiHuiBlog.github.io/images/posts/iTerm 2和Oh My Zsh代替自带terminal教程简单整理/4.png" alt="avatar">    </p>
<h4 id="1-首先下载iterm2"><a href="#1-首先下载iterm2" class="headerlink" title="1. 首先下载iterm2"></a>1. 首先下载<a href="http://www.iterm2.com/" target="_blank" rel="noopener">iterm2</a></h4><h4 id="2-打开iTerm-2"><a href="#2-打开iTerm-2" class="headerlink" title="2. 打开iTerm 2"></a>2. 打开iTerm 2</h4><h4 id="3-输入下面指令安装oh-my-zsh"><a href="#3-输入下面指令安装oh-my-zsh" class="headerlink" title="3. 输入下面指令安装oh-my-zsh"></a>3. 输入下面指令安装<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></h4><blockquote>
<p>curl -L <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh</a> | sh</p>
</blockquote>
<h4 id="4-接下来安装Powerline"><a href="#4-接下来安装Powerline" class="headerlink" title="4. 接下来安装Powerline"></a>4. 接下来安装<a href="http://powerline.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">Powerline</a></h4><p>在官网有教程，我们只需要执行官网第一条安装指令就行</p>
<p>如果你的终端能够正常执行pip指令，那么直接执行下面的指令可以完成安装</p>
<blockquote>
<p>pip install powerline-status</p>
</blockquote>
<p>如果没有，则先执行安装pip指令</p>
<blockquote>
<p>sudo easy_install pip</p>
</blockquote>
<h4 id="5-下载、安装库字体库"><a href="#5-下载、安装库字体库" class="headerlink" title="5. 下载、安装库字体库"></a>5. 下载、安装库<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">字体库</a></h4><p>1）将工程下载下来后cd到<em>install.sh</em>文件所在目录</p>
<p>2）执行指令安装字体库</p>
<p>执行<em>./install.sh</em>指令安装所有Powerline字体</p>
<p>安装完成后提示所有字体均已下载到<em>/Users/superdanny/Library/Fonts</em>路径下</p>
<p>All Powerline fonts installed to /Users/superdanny/Library/Fonts</p>
<h4 id="6-设置iTerm-2的Regular-Font-和-Non-ASCII-Font"><a href="#6-设置iTerm-2的Regular-Font-和-Non-ASCII-Font" class="headerlink" title="6. 设置iTerm 2的Regular Font 和 Non-ASCII Font"></a>6. 设置iTerm 2的Regular Font 和 Non-ASCII Font</h4><p>安装完字体库之后，把iTerm 2的设置里的<em>Profile</em>中的<em>Text</em> 选项卡中里的<em>Regular Font</em>和<em>Non-ASCII Font</em>的字体都设置成 Powerline的字体，我这里设置的字体是12pt Meslo LG S DZ Regular for Powerline</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/iTerm 2和Oh My Zsh代替自带terminal教程简单整理/2.jpg" alt="avatar">  </p>
<p>设置iTerm 2设置iTerm 2</p>
<h4 id="7-配色方案"><a href="#7-配色方案" class="headerlink" title="7. 配色方案"></a>7. <a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">配色方案</a></h4><p>1）安装配色方案</p>
<p>进入刚刚下载的工程的<em>solarized/iterm2-colors-solarized</em>下双击<em>Solarized Dark.itermcolors</em>和<em>Solarized Light.itermcolors</em>两个文件就可以把配置文件导入到 iTerm2 里</p>
<p>2）配置配色方案</p>
<p>通过load presets选择刚刚安装的配色主题即可</p>
<p><img src="https://DaiHuiBlog.github.io/images/posts/iTerm 2和Oh My Zsh代替自带terminal教程简单整理/3.jpg" alt="avatar">  </p>
<p>配色方案配色方案</p>
<h4 id="8-使用agnoster主题"><a href="#8-使用agnoster主题" class="headerlink" title="8. 使用agnoster主题"></a>8. 使用agnoster主题</h4><p>1）下载<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="noopener">agnoster</a>主题</p>
<p>到下载的工程里面运行install文件,主题将安装到<em>~/.oh-my-zsh/themes</em>目录下</p>
<p>2）设置该主题<br>进入<em>~/.zshrc</em>打开<em>.zshrc</em>文件，然后将<em>ZSH_THEME</em>后面的字段改为<em>agnoster</em>。<em>ZSH_THEME=”agnoster”</em>（agnoster即为要设置的主题）</p>
<h4 id="9-增加指令高亮效果——zsh-syntax-highlighting"><a href="#9-增加指令高亮效果——zsh-syntax-highlighting" class="headerlink" title="9. 增加指令高亮效果——zsh-syntax-highlighting"></a>9. 增加指令高亮效果——<a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a></h4><p>指令高亮效果作用是当用户输入正确命令时指令会绿色高亮，错误时命令红色高亮</p>
<p>1）首先在~/.oh-my-zsh/custom/plugins/路径下执行git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting.git</a><br>到了此路径:<em>~/.oh-my-zsh/custom/plugins/</em></p>
<p>2）然后在<em>~/.zshrc</em>最后添加了下面两句：<br><strong>“plugins=(zsh-syntax-highlighting)<br>source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh”</strong></p>
<p>3）最后执行 source ~/.zshrc</p>
<p>这样就同时配置好了zsh和oh-my-zsh。<br>有两点需要注意(摘自官网):<br>Note the source command must be at the end of ~/.zshrc.<br>Note that zsh-syntax-highlighting must be the last plugin sourced, so make it the last element of the $plugins array.    </p>
<h4 id="问题解答区"><a href="#问题解答区" class="headerlink" title="问题解答区"></a>问题解答区</h4><ol>
<li><p>启动iTerm 2 默认使用dash改用zsh解决方法：</p>
<blockquote>
<p>chsh -s /bin/zsh  </p>
</blockquote>
</li>
<li><p>如果想切换回原来的dash：</p>
<blockquote>
<p>chsh -s /bin/bash   </p>
</blockquote>
</li>
<li><p>卸载oh my zsh，在命令行输入如下命令，回车即可：</p>
<blockquote>
<p>uninstall_oh_my_zsh  </p>
</blockquote>
</li>
<li><p>执行指令pip install powerline-status出错解决方法：<br>需要下载苹果官方的<a href="https://idmsa.apple.com/IDMSWebAuth/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2Fdownload%2Fmore%2F%3Fname%3Dfor%2520Xcode%2520&amp;rv=1" target="_blank" rel="noopener">Command line</a>。必須官方工具下载最新版 Command Line  </p>
</li>
<li><p>⌘+Q关闭iTerm 2 时每次弹窗提示问题：<br>iTerm 2 中，进入Preference-General-Closing栏目，将Confirm “Quit iTerm2(⌘Q)” command选项勾选去掉就行   </p>
</li>
<li><p>找不到.zshrc文件问题：<br>我这里将原作者的.zshrc文件分享出来。供大家下载<a href="https://pan.baidu.com/s/1sk1LqCt" target="_blank" rel="noopener">网盘</a>   </p>
</li>
<li><p>路径前缀的XX@XX太长，缩短问题：<br>在此感谢评论区的朋友提供的<a href="https://blog.csdn.net/z3512498/article/details/51245853" target="_blank" rel="noopener">解决方案</a>。在~/.oh-my-zsh/themes路径下找到agnoster.zsh-theme文件，可使用文本工具打开，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可。    </p>
</li>
<li><p>执行指令pip install powerline-status出错，下载了Command Line也没有办法,是权限原因造成的,执行:   </p>
<blockquote>
<p>pip install powerline-status –user</p>
</blockquote>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/7de00c73a2bb" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>iTerm 2</tag>
        <tag>Oh My Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10下.Net Framework 3.5无法安装【错误代码0x800F081F】</title>
    <url>/2018/03/18/Win10%E4%B8%8B-Net-Framework-3-5%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<ol>
<li><p>首先下载 .Net Framework 3.5.</p>
</li>
<li><p>将下载的文件复制到复制到 【C盘】 的 【Windows】 文件夹，然后后在“命令提示符（管理员）”中执行下面的命令：</p>
<a id="more"></a>
<blockquote>
<p>dism /online /Enable-Feature /FeatureName:NetFx3 /Source:”%windir%” /LimitAccess</p>
</blockquote>
</li>
</ol>
<p>其他:</p>
<ul>
<li>Windows 10下安装有的软件需要 .Net Framework 3.5的环境。默认是没有开启的，一般情况下可以【右键开始】菜单，选择【程序和功能】<br>然后再选择【启用或关闭Windows功能】里的第一项【.Net Framework 3.5(包括.NET 2.0和3.0)  </li>
<li>再一个就是去官网下一个手动安装一下也行，这两种方法都不行再用上面那个方法，这样大部分人的问题应该都可以解决了。</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Framework3.5无法安装</tag>
      </tags>
  </entry>
  <entry>
    <title>win2008R2磁盘脱机和写入保护解决办法</title>
    <url>/2018/10/22/win2008R2%E7%A3%81%E7%9B%98%E8%84%B1%E6%9C%BA%E5%92%8C%E5%86%99%E5%85%A5%E4%BF%9D%E6%8A%A4%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/1.png" alt="磁盘脱机"></p>
<a id="more"></a>
<ol>
<li><p>打开cmd命令行，输入：<strong>diskpart</strong>，进入diskpart工具</p>
</li>
<li><p>输入：<strong>list disk</strong>，查看到所有磁盘</p>
</li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/2.png" alt="listdisk1"></p>
<ol>
<li>找到脱机的磁盘，输入：<strong>select disk 1</strong></li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/3.png" alt="selectDisk"></p>
<ol>
<li>接着输入：<strong>online disk</strong></li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/4.png" alt="onlineDisk"></p>
<ol>
<li>查看此时磁盘联机状态</li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/5.png" alt="listdisk2"></p>
<ol>
<li>清除只读属性，输入：<strong>attribute disk clear readonly</strong></li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/6.png" alt="attributeDiskClearReadonly"></p>
<ol>
<li>查看此时的清盘情况，输入：<strong>attribute disk</strong></li>
</ol>
<p><img src="https://DaiHuiBlog.github.io/images/posts/win2008R2磁盘脱机和写入保护解决办法/7.png" alt="attributeDisk"></p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows磁盘脱机</tag>
        <tag>写入保护</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派3B+制作视频监控</title>
    <url>/2019/03/12/%E6%A0%91%E8%8E%93%E6%B4%BE3Bplus%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/树莓派3B+制作视频监控/logo.png" alt="logo"></p>
<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>本人育有一毛，此猫调皮捣蛋，因此想要做个监控放在家里，在公司上班的时候看看它到底在家里捣什么鬼蛋！</p>
<a id="more"></a>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><blockquote>
<p>环境：树莓派3B+<br>操作系统：树莓派3B+默认系统<br>摄像头：N年前买的一个USB摄像头（比树莓派官方好点）  </p>
</blockquote>
<h1 id="1-更新列表"><a href="#1-更新列表" class="headerlink" title="1.更新列表"></a>1.更新列表</h1><p>这一步可能有点慢，请耐心等待。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新软件列表</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新软件</span></span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h1 id="2-开启摄像头"><a href="#2-开启摄像头" class="headerlink" title="2.开启摄像头"></a>2.开启摄像头</h1><p>执行如下命令，进入配置页面，开启摄像头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p><img src="https://DaiHuiBlog.github.io/images/posts/树莓派3B+制作视频监控/1.png" alt="raspiConfig1"><br><img src="https://DaiHuiBlog.github.io/images/posts/树莓派3B+制作视频监控/2.png" alt="raspiConfig2"></p>
<p>选择: “是”  -&gt; “Back” -&gt; “Finish”</p>
<p>重启一下树莓派</p>
<h1 id="3-安装依赖库"><a href="#3-安装依赖库" class="headerlink" title="3.安装依赖库"></a>3.安装依赖库</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> JPEG支持库</span></span><br><span class="line">sudo apt-get install libjpeg8-dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载编译工具</span></span><br><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure>
<h1 id="4-下载mjpg-streamer"><a href="#4-下载mjpg-streamer" class="headerlink" title="4.下载mjpg-streamer"></a>4.下载mjpg-streamer</h1><p>随意找个目录执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/jacksonliam/mjpg-streamer.git</span><br></pre></td></tr></table></figure>
<p>以常见的<strong>Downloads</strong>目录为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ cd Downloads/</span><br><span class="line">pi@raspberrypi:~ $ git clone https://github.com/jacksonliam/mjpg-streamer.git</span><br></pre></td></tr></table></figure>
<h1 id="5-编辑源文件（非必须）"><a href="#5-编辑源文件（非必须）" class="headerlink" title="5.编辑源文件（非必须）"></a>5.编辑源文件（非必须）</h1><p>网上有教程基本都编辑<strong>plugins/input_raspicam/input_raspicam.c</strong>源码里的几个参数（fps、width和height）<br>，这个文件是对应官方的摄像头（RaspiCamera）。</p>
<p>我这里用的是自己的普通USB摄像头，所以这个文件可以不用修改。</p>
<p>如果你的摄像头是普通USB摄像头，可以跳过。</p>
<p>如果你的摄像头是官方的摄像头（RaspiCamera）那么请修改之：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:/ $ cd /home/pi/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/</span><br><span class="line">pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental/plugins/input_raspicam/ $ vi input_raspicam.c</span><br></pre></td></tr></table></figure>
<p><img src="https://DaiHuiBlog.github.io/images/posts/树莓派3B+制作视频监控/3.png" alt="input_raspicam"></p>
<h1 id="6-编译mjpg-streamer"><a href="#6-编译mjpg-streamer" class="headerlink" title="6.编译mjpg-streamer"></a>6.编译mjpg-streamer</h1><p>进入工程mjpg-streamer-experimental，进行完全编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~/Downloads/mjpg-streamer/mjpg-streamer-experimental $ make clean all</span><br></pre></td></tr></table></figure>
<h1 id="7-开启mjpg-streamer"><a href="#7-开启mjpg-streamer" class="headerlink" title="7.开启mjpg-streamer"></a>7.开启mjpg-streamer</h1><p>进入mjpg-streamer-experimental目录，使用一下指令启动摄像头。</p>
<ul>
<li><p>启动普通USB摄像头指令：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -i "./input_uvc.so" -o "./output_http.so -w ./www"</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动树莓派专用摄像头RaspiCamera指令：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mjpg_streamer -i "./input_raspicam.so" -o "./output_http.so -w ./www"</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h1><p>在浏览器里输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 静态图（拍照）</span></span><br><span class="line">http://&lt;IP&gt;：8080/?action=snapshot</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 动态图（视频监控）</span></span><br><span class="line">http://&lt;IP&gt;：8080/?action=stream</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个兼容性好点</span></span><br><span class="line">http://&lt;IP&gt;：8080/javascript_stream.html</span><br></pre></td></tr></table></figure>
<p><img src="https://DaiHuiBlog.github.io/images/posts/树莓派3B+制作视频监控/cat.jpeg" alt="cat"></p>
<h1 id="9-问题"><a href="#9-问题" class="headerlink" title="9.问题"></a>9.问题</h1><p>有的同学可能在<strong>开启mjpg-streamer</strong>的时候会报错，可能是你USB摄像头用了树莓派专用摄像头RaspiCamera指令的指令启动造成的（我就是这样，哈哈哈）</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Raspberry</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>如何超过大多数人</title>
    <url>/2019/07/22/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/如何超过大多数人/1.png" alt="如何超过大多数人"></p>
<a id="more"></a>
<p>当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的 “武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径…… 然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力…… 然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍” 用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个 “人生导师” 可以写得好。毕竟，我的生命过到了十六进制 2B 的年纪，踏入这个社会已超过 20 年，舍我其谁呢？！</p>
<p>P.S. 这篇文章借鉴于《<a href="https://coolshell.cn/articles/4758.html" target="_blank" rel="noopener">如何写出无法维护的代码</a>》一文的风格…… 嘿嘿</p>
<blockquote>
<h4 id="相关技巧和最佳实践"><a href="#相关技巧和最佳实践" class="headerlink" title="相关技巧和最佳实践"></a>相关技巧和最佳实践</h4></blockquote>
<p>要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。<strong>所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了</strong>。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些 “技巧” 你要多多了解一下。</p>
<p>在信息获取上，你要不断地向大众鼓吹下面的这些事：</p>
<ul>
<li><p>让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识…… 要做到这一步，你就需要把 “百度一下” 挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种 “如何看待……” 这样的文章，让他们爱上八卦，爱上转发，爱上碎片。</p>
</li>
<li><p>让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向…… 是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。</p>
</li>
<li><p>把今日头条和抖音这样的 APP 推荐给大家…… 你只需要让你有朋友成功地安装这两个 APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。</p>
</li>
<li><p>让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，…… 这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些 SB 或是很极端的观点，造成大家的一睦讨论后，就早早离场……</p>
</li>
<li><p>利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了…… 这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。</p>
</li>
</ul>
<p>然后，在知识学习和技能训练上，让他们不得要领并产生幻觉</p>
<ul>
<li><p>让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……</p>
</li>
<li><p>培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……</p>
</li>
<li><p>不断地给他们各种各样 “有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书 “收藏家”……</p>
</li>
<li><p>让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用 “死记硬背” 的方式来学习，甚至直接让他们失去信心，直接放弃……</p>
</li>
<li><p>玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……</p>
</li>
<li><p>让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……</p>
</li>
<li><p>告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……</p>
</li>
<li><p>让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……</p>
</li>
<li><p>让他们觉得 “读完书”、“读过书” 就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……</p>
</li>
</ul>
<p>最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。</p>
<ul>
<li><p>让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好……</p>
</li>
<li><p>宣扬一夜暴富以及快速挣钱的案例，最好让他们进入 “赌博类” 或是 “传销类” 的地方，比如：股市、数字货币…… 要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……</p>
</li>
<li><p>告诉他们，一些看上去很难的事都是有捷径的，比如：21 天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……</p>
</li>
<li><p>多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……</p>
</li>
<li><p>多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……</p>
</li>
<li><p>让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……</p>
</li>
<li><p>让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……</p>
</li>
<li><p>告诉他们你的行业太累太辛苦，干不到 30 岁。让他们早点转行，不要耽误人生和青春……</p>
</li>
<li><p>当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）</p>
</li>
<li><p>告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的…… 这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……</p>
</li>
<li><p>每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……</p>
</li>
</ul>
<p><strong>最后友情提示一下，上述的这些 “最佳实践” 你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是 “欲练神功，必先自宫” 的道理。</strong></p>
<blockquote>
<h4 id="相关原理和思维模型"><a href="#相关原理和思维模型" class="headerlink" title="相关原理和思维模型"></a>相关原理和思维模型</h4></blockquote>
<p>对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。</p>
<p>一般来说，超过别人一般来说就是两个维度：</p>
<ul>
<li><p><strong>在认知、知识和技能上。</strong> 这是一个人赖以立足社会的能力（参看《<a href="https://coolshell.cn/articles/4235.html" target="_blank" rel="noopener">程序员的荒谬之言还是至理名言？</a>》和《<a href="https://coolshell.cn/articles/2250.html" target="_blank" rel="noopener">21 天教你学会 C++</a>》）</p>
</li>
<li><p><strong>在领导力上。</strong> 所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《<a href="https://coolshell.cn/articles/17583.html" target="_blank" rel="noopener">技术人员发展之路</a>》）</p>
</li>
</ul>
<p>首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把 “零碎的认知” 转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90% 的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。</p>
<blockquote>
<h4 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h4></blockquote>
<p>要在认知上超过别人，就要在下面几个方面上做足功夫：</p>
<p>1）<strong>信息渠道。</strong> 试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人 hack 其中的信息（也就是 “中间人攻击”），而这些找不出信息源的人，只能 “被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习 C 语言，放着原作者 K&amp;R 的不用，硬要用错误百出谭浩强的书，能有什么好呢？）</p>
<p>2）<strong>信息质量。</strong> 信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。</p>
<p>3）<strong>信息密度。</strong> 优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践…… 一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix 编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像 Netflix 的官方 blog 和 AWS CTO 的 blog 等等地方也会经常有一些这样的文章。</p>
<blockquote>
<h4 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h4></blockquote>
<p>要在知识上超过别人，你就需要在下面几个方面上做足功夫：</p>
<p>1）<strong>知识树（图）。</strong> 任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，<strong>对于一棵树来说，“根基” 是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！</strong></p>
<p>2）<strong>知识缘由。</strong> 任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。<strong>能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。</strong></p>
<p>3）<strong>方法套路。</strong> 学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。</p>
<blockquote>
<h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4></blockquote>
<p>要在技能上超过别人，你就需要在下面几个方面做足功夫：</p>
<p>1）<strong>精益求精。</strong> 如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。</p>
<p>2）<strong>让自己犯错。</strong> 犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！</p>
<p>3）<strong>找高手切磋。</strong> 下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！</p>
<blockquote>
<h4 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h4></blockquote>
<p>最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。</p>
<p>1）<strong>识别自己的特长和天赋。</strong> 首先，每个人 DNA 都可能或多或少都会有一些比大多数人 NB 的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。</p>
<p>2）<strong>识别自己的兴趣和事业。</strong> 没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus 就是在学校里对 minx 着迷了，于是整出个 Linux 来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫 “真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心” 和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。</p>
<p>3）<strong>建立高级的习惯和方法。</strong> 没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来…… 自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。</p>
<p>4）<strong>勤奋努力执着坚持。</strong> 如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的 “一万小时定律” 了（参看《21 天教你学会 C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要 1 年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。</p>
<p>好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。</p>
<p>（全文完）</p>
<blockquote>
<p>本文转自：<a href="https://coolshell.cn/" target="_blank" rel="noopener">CoolShell</a> 的<a href="https://coolshell.cn/articles/19464.html/comment-page-1#comments" target="_blank" rel="noopener">《如何超过大多数人》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>超过</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员工作中常见的英语词汇</title>
    <url>/2019/06/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87/</url>
    <content><![CDATA[<p><img src="https://DaiHuiBlog.github.io/images/posts/程序员工作中常见的英语词汇/1.jpg" alt="words"></p>
<a id="more"></a>
<h1 id="程序员工作中常见的英语词汇"><a href="#程序员工作中常见的英语词汇" class="headerlink" title="程序员工作中常见的英语词汇"></a>程序员工作中常见的英语词汇</h1><p>本列表中的单词是英语类计算机书籍、文档、文章中高频常见的技术词汇，最终目的是希望程序员集合自身的英语基础，在掌握列表中的词汇后，可以无障碍阅读英语技术文章和文档。</p>
<blockquote>
<p>本文内容来自Wei-Xia的项目<a href="https://github.com/Wei-Xia/most-frequent-technology-english-words" target="_blank" rel="noopener">most-frequent-technology-english-words</a>，并加了一些音标</p>
</blockquote>
<blockquote>
<p>文末是网上搜集的资料</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><table>
<thead>
<tr>
<th>单词</th>
<th>词性</th>
<th>意思</th>
<th>音标</th>
</tr>
</thead>
<tbody>
<tr>
<td>aggregate</td>
<td>verb</td>
<td>聚合</td>
<td>英 [‘ægrɪgət; (for v.) ˈægrɪgeɪt] 美 [‘æɡrɪɡət; (for v.) æɡrɪˌɡet]</td>
</tr>
<tr>
<td>aggregation</td>
<td>noun</td>
<td>聚合</td>
<td>英 [,æɡrɪ’ɡeɪʃən] 美 [,ægrɪ’geʃən]</td>
</tr>
<tr>
<td>analyze</td>
<td>verb</td>
<td>分析</td>
<td>英 [‘ænə,laɪz] 美 [‘ænə,laɪz]</td>
</tr>
<tr>
<td>architecture</td>
<td>noun</td>
<td>架构</td>
<td>英 [‘ɑːkɪtektʃə] 美 [‘ɑrkə’tɛktʃɚ]</td>
</tr>
<tr>
<td>asynchronous</td>
<td>adjective</td>
<td>异步的</td>
<td>英 [ə’sɪŋkrənəs; eɪ-] 美 [e’sɪŋkrənəs]</td>
</tr>
<tr>
<td>capacity</td>
<td>noun</td>
<td>能力、容量</td>
<td>英 [kə’pæsɪtɪ] 美 [kə’pæsəti]</td>
</tr>
<tr>
<td>caveats</td>
<td>noun</td>
<td>注意事项</td>
<td>单数：英 [‘kævɪæt; ‘keɪ-] 美 [‘kævɪæt; ‘ke-]</td>
</tr>
<tr>
<td>complexity</td>
<td>noun</td>
<td>复杂性</td>
<td>英 [kəm’pleksətɪ] 美 [kəm’plɛksəti]</td>
</tr>
<tr>
<td>concatenate</td>
<td>verb</td>
<td>连接</td>
<td>英 [kən’kætɪneɪt] 美 [kɑn’kætə,net]</td>
</tr>
<tr>
<td>concurrent</td>
<td>adjective</td>
<td>并发的</td>
<td>英 [kən’kʌr(ə)nt] 美 [kən’kɝənt]</td>
</tr>
<tr>
<td>consumption</td>
<td>noun</td>
<td>消耗</td>
<td>英 [kən’sʌm(p)ʃ(ə)n] 美 [kən’sʌmpʃən]</td>
</tr>
<tr>
<td>differentiate</td>
<td>verb</td>
<td>区别</td>
<td>英 [,dɪfə’renʃɪeɪt] 美 [,dɪfə’rɛnʃɪet]</td>
</tr>
<tr>
<td>efficiency</td>
<td>noun</td>
<td>效率</td>
<td>英 [ɪ’fɪʃ(ə)nsɪ] 美 [ɪˈfɪʃənsɪ]</td>
</tr>
<tr>
<td>elastic</td>
<td>adjective</td>
<td>灵活有弹性的</td>
<td>英 [ɪ’læstɪk] 美 [ɪ’læstɪk]</td>
</tr>
<tr>
<td>encapsulate</td>
<td>verb</td>
<td>压缩、封装</td>
<td>英 [ɪn’kæpsjʊleɪt; en-] 美 [ɪn’kæpsjə’let]</td>
</tr>
<tr>
<td>expenditure</td>
<td>noun</td>
<td>支出，经费</td>
<td>英 [ɪk’spendɪtʃə; ek-] 美 [ɪk’spɛndɪtʃɚ]</td>
</tr>
<tr>
<td>explicit</td>
<td>adjective</td>
<td>明确清楚的</td>
<td>英 [ɪk’splɪsɪt; ek-] 美 [ɪk’splɪsɪt]</td>
</tr>
<tr>
<td>failover</td>
<td>noun</td>
<td>故障切换</td>
<td>英 美 [feil’əuvər]</td>
</tr>
<tr>
<td>hierarchical</td>
<td>adjective</td>
<td>分层的</td>
<td>英 [haɪə’rɑːkɪk(ə)l] 美 [,haɪə’rɑrkɪkl]</td>
</tr>
<tr>
<td>incident</td>
<td>noun</td>
<td>事故</td>
<td>英 [‘ɪnsɪd(ə)nt] 美 [‘ɪnsɪdənt]</td>
</tr>
<tr>
<td>inexplicit</td>
<td>adjective</td>
<td>含糊不清的</td>
<td>英 [ɪnɪk’splɪsɪt; ɪnek-] 美 [ɪnɪk’splɪsɪt; ɪnek-]</td>
</tr>
<tr>
<td>infrastructure</td>
<td>noun</td>
<td>基础结构</td>
<td>英 [‘ɪnfrəstrʌktʃə] 美 [‘ɪnfrə’strʌktʃɚ]</td>
</tr>
<tr>
<td>intrusive</td>
<td>adjective</td>
<td>侵入式的</td>
<td>英 [ɪn’truːsɪv] 美 [ɪn’trusɪv]</td>
</tr>
<tr>
<td>intuitive</td>
<td>adjective</td>
<td>直觉的</td>
<td>英 [ɪn’tjuːɪtɪv] 美 [ɪn’tuɪtɪv]</td>
</tr>
<tr>
<td>latency</td>
<td>noun</td>
<td>延迟</td>
<td>英 [‘leɪtənsɪ] 美 [‘letnsi]</td>
</tr>
<tr>
<td>mechanism</td>
<td>noun</td>
<td>机制</td>
<td>英 [‘mek(ə)nɪz(ə)m] 美 [‘mɛkənɪzəm]</td>
</tr>
<tr>
<td>metrics</td>
<td>noun</td>
<td>度量指标</td>
<td>英 [‘metrɪks] 美 [‘mɛtrɪks]</td>
</tr>
<tr>
<td>miscellaneous</td>
<td>adjective</td>
<td>混杂、各式各样的</td>
<td>英 [,mɪsə’leɪnɪəs] 美 [‘mɪsə’lenɪəs]</td>
</tr>
<tr>
<td>notation</td>
<td>noun</td>
<td>注释、标注</td>
<td>英 [nəʊ’teɪʃ(ə)n] 美 [noʊˈteɪʃən]</td>
</tr>
<tr>
<td>optimization</td>
<td>noun</td>
<td>优化</td>
<td>英 [,ɒptɪmaɪ’zeɪʃən] 美 [,ɑptəmɪ’zeʃən]</td>
</tr>
<tr>
<td>optimize</td>
<td>verb</td>
<td>优化</td>
<td>英 [‘ɒptɪmaɪz] 美 [‘ɑptɪmaɪz]</td>
</tr>
<tr>
<td>polyfill</td>
<td>noun</td>
<td>填充物</td>
<td></td>
</tr>
<tr>
<td>populate</td>
<td>verb</td>
<td>输入数据</td>
<td>英 [‘pɒpjʊleɪt] 美 [‘pɑpjulet]</td>
</tr>
<tr>
<td>privilege</td>
<td>noun</td>
<td>特权</td>
<td>英 [ˈprɪvəlɪdʒ] 美 [ˈprɪvəlɪdʒ]</td>
</tr>
<tr>
<td>protocol</td>
<td>noun</td>
<td>协议</td>
<td>英 [‘prəʊtəkɒl] 美 [‘protə’kɔl]</td>
</tr>
<tr>
<td>provision</td>
<td>noun</td>
<td>规定、条款</td>
<td>英 [prə’vɪʒ(ə)n] 美 [prə’vɪʒn]</td>
</tr>
<tr>
<td>redundancy</td>
<td>noun</td>
<td>冗余</td>
<td>英 [rɪ’dʌnd(ə)nsɪ] 美 [rɪ’dʌndənsi]</td>
</tr>
<tr>
<td>reliability</td>
<td>noun</td>
<td>可靠性</td>
<td>英 [rɪ,laɪə’bɪlətɪ] 美 [rɪ,laɪə’bɪləti]</td>
</tr>
<tr>
<td>resilience</td>
<td>noun</td>
<td>回弹性</td>
<td>英 [rɪ’zɪlɪəns] 美 [rɪˈzɪliəns]</td>
</tr>
<tr>
<td>retain</td>
<td>verb</td>
<td>保持</td>
<td>英 [rɪ’teɪn] 美 [rɪ’ten]</td>
</tr>
<tr>
<td>robust</td>
<td>adjective</td>
<td>强健的</td>
<td>英 [rə(ʊ)’bʌst] 美 [ro’bʌst]</td>
</tr>
<tr>
<td>roll off</td>
<td>verb</td>
<td>渐渐地退出</td>
<td>-</td>
</tr>
<tr>
<td>scalability</td>
<td>noun</td>
<td>可扩展性</td>
<td>英 美 [,skeilə’biliti]</td>
</tr>
<tr>
<td>scenarios</td>
<td>noun</td>
<td>场景</td>
<td>英 美 [sɪ’nɛrɪ,o]</td>
</tr>
<tr>
<td>scope</td>
<td>noun</td>
<td>范围</td>
<td>英 [skəʊp] 美 [skop]</td>
</tr>
<tr>
<td>simultaneously</td>
<td>adverb</td>
<td>同时地</td>
<td>英 [,sɪml’teɪnɪəslɪ] 美 [saɪməl’tenɪəsli]</td>
</tr>
<tr>
<td>subsidiary</td>
<td>noun</td>
<td>子公司</td>
<td>英 [səb’sɪdɪərɪ] 美 [səb’sɪdɪɛri]</td>
</tr>
<tr>
<td>sustainable</td>
<td>adjective</td>
<td>可持续的</td>
<td>英 [sə’steɪnəb(ə)l] 美 [sə’stenəbl]</td>
</tr>
<tr>
<td>takeaway</td>
<td>noun</td>
<td>收获、学到什么</td>
<td>英 [‘teɪkəweɪ] 美 [‘tekə’we]</td>
</tr>
<tr>
<td>threshold</td>
<td>noun</td>
<td>阈值</td>
<td>英 [‘θreʃəʊld; ‘θreʃ,həʊld] 美 [‘θrɛʃhold]</td>
</tr>
<tr>
<td>thrilled</td>
<td>adjective</td>
<td>非常兴奋的</td>
<td>英 [θrɪld] 美 [θrɪld]</td>
</tr>
<tr>
<td>throughput</td>
<td>noun</td>
<td>吞吐量</td>
<td>英 [‘θruːpʊt] 美 [‘θrʊ’pʊt]</td>
</tr>
<tr>
<td>tilde</td>
<td>noun</td>
<td>波浪号～</td>
<td>英 [‘tɪldə] 美 [‘tɪldə]</td>
</tr>
<tr>
<td>tolerance</td>
<td>noun</td>
<td>容忍</td>
<td>英 [‘tɒl(ə)r(ə)ns] 美 [‘tɑlərəns]</td>
</tr>
<tr>
<td>traceability</td>
<td>noun</td>
<td>可追溯性</td>
<td>英 [,treɪsə’bɪlətɪ] 美 [,tresə’bɪləti]</td>
</tr>
<tr>
<td>undertake</td>
<td>verb</td>
<td>承担</td>
<td>英 [ʌndə’teɪk] 美 [,ʌndɚ’tek]</td>
</tr>
<tr>
<td>utilization</td>
<td>noun</td>
<td>利用，使用</td>
<td>英 [,juːtɪlaɪ’zeɪʃən] 美 [ˌjuːtəlaɪ’zeɪʃn]</td>
</tr>
<tr>
<td>workaround</td>
<td>noun</td>
<td>解决方案</td>
<td>英 美 [‘wə:kə,raund]</td>
</tr>
</tbody>
</table>
<h2 id="其他网站"><a href="#其他网站" class="headerlink" title="其他网站"></a>其他网站</h2><p><a href="https://www.51test.net/show/9115284.html" target="_blank" rel="noopener">程序员常用英语词汇</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>英语词汇</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机Linux的root或普通用户密码忘记找回</title>
    <url>/2018/07/31/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%9A%84root%E6%88%96%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%89%BE%E5%9B%9E/</url>
    <content><![CDATA[<h1 id="启动VMware的Linux"><a href="#启动VMware的Linux" class="headerlink" title="启动VMware的Linux"></a>启动VMware的Linux</h1><ol>
<li>进入GRUB界面后，有几秒钟时间给你。进入GRUB出现：<br> Red Hat Enterprise Linux Server (2.6.18-8.e15xen) <a id="more"></a></li>
<li>倒计时结束前，键入e出现：<br>root（hd0,0）<br>kernel /xen.gz-2.6.28-8.e15<br>module /vmlinux-2.6.18.e15xen ro root=/dev/VolGroup00/LogVo100 rhgb quiet<br>module /initrd-2.6.18-8.e15xen.img<br>上下键移到quiet那一行，按e进入，加上 linux single或者1即可，回车</li>
<li>按b后进入重启模式，一定注意出现：<br> Starting udev:<br> 在后面输入boot回车</li>
<li>之后出现命令行：<br> sh-3.2#</li>
<li>输入passwd，回车即可修改root密码，输入两次密码</li>
<li>完成之后reboot即可重启。</li>
</ol>
<h1 id="普通用户密码忘记了，比较简单"><a href="#普通用户密码忘记了，比较简单" class="headerlink" title="普通用户密码忘记了，比较简单"></a>普通用户密码忘记了，比较简单</h1><ol>
<li>在root账户下，打开/etc/shadow (不是passwd文件，因为密码实际上经过加密后放在了“影子口令”文件shadow中了。passwd文件每个用户均可见，但是shadow只有root可以见)。</li>
<li>找到普通用户名cicikasa，然后删除第二个域即可，域之间用“:”隔开的，如下：<br>cicikasa:TdkakkkYUukkjkjk:14672:0:99999:7:::<br>上述红色部分就是经过加密的密码，删除即可</li>
<li>在普通用户下，输入passwd即可输入新密码</li>
</ol>
<h1 id="如果想修改VMware的bios"><a href="#如果想修改VMware的bios" class="headerlink" title="如果想修改VMware的bios"></a>如果想修改VMware的bios</h1><p>在VMWare中将BIOS设成光驱启动:<br>启动时(点击启动虚拟机按钮),按F2 ,进入BIOS 设置,找到 BOOT—把CDROM光驱，移动到最上面即可。根据提示进行设置，一般按“-”号进行设置。<br>注意：启动时，点了启动虚拟机按钮后一定要在点一下窗口（或者Ctrl +G），然后快按F2。否则，窗口没激活，F2是不起作用的.</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>密码找回</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机VirtualBox中挂载新硬盘</title>
    <url>/2018/03/18/%E8%99%9A%E6%8B%9F%E6%9C%BAVirtualBox%E4%B8%AD%E6%8C%82%E8%BD%BD%E6%96%B0%E7%A1%AC%E7%9B%98/</url>
    <content><![CDATA[<p>在VirtualBox中装好Linux后，发现硬盘空间太小，怎样才能增加硬盘容量？那就是再建一个硬盘：</p>
<h5 id="添加新硬盘"><a href="#添加新硬盘" class="headerlink" title="添加新硬盘"></a>添加新硬盘</h5><blockquote>
<p>设置 -&gt; Storage(存储) -&gt; SATA控制器-&gt;右击，选择”添加虚拟硬盘”<br>然后，根据需求创建合适的硬盘<br><a id="more"></a></p>
</blockquote>
<h5 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h5><p>  查看现有系统的磁盘空间</p>
<blockquote>
<p>sudo fdisk -l</p>
</blockquote>
<p>  可看到新加的虚拟硬盘，一般名为：Disk /dev/sdb</p>
<h5 id="给新加的硬盘分区"><a href="#给新加的硬盘分区" class="headerlink" title="给新加的硬盘分区"></a>给新加的硬盘分区</h5><blockquote>
<p>fdisk /dev/sdb  </p>
</blockquote>
<p>  键入m,可看到帮助信息</p>
<blockquote>
<p>command (m for help):m</p>
</blockquote>
<p>  增加新分区</p>
<blockquote>
<p>command (m for help):n  </p>
</blockquote>
<p>  选择基本分区，输入：p 建一个分区</p>
<blockquote>
<p>Partition number(1-4):  </p>
</blockquote>
<p>  回车</p>
<blockquote>
<p>First cylinder (1-15908,default 1):Enter</p>
</blockquote>
<p>  写入并退出</p>
<blockquote>
<p>command (m for help):w</p>
</blockquote>
<h5 id="格式化磁盘分区"><a href="#格式化磁盘分区" class="headerlink" title="格式化磁盘分区"></a>格式化磁盘分区</h5><p>  用ext4格式对/dev/sdb1进入格式化</p>
<blockquote>
<p>sudo mkfs.ext4 /dev/sdb1</p>
</blockquote>
<h5 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h5><p>  创建新的挂载点</p>
<blockquote>
<p>sudo mkdir /work</p>
</blockquote>
<p>  将新磁盘分区挂载到/work目录下</p>
<blockquote>
<p>sudo mount -t ext4 /dev/sdb1 /work</p>
</blockquote>
<p>  查看挂载</p>
<blockquote>
<p>df -h</p>
</blockquote>
<p>  可以看到新加的硬盘：/dev/sdb1</p>
<h5 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h5><p>  修改文件</p>
<blockquote>
<p>sudo vim /etc/fstab</p>
</blockquote>
<p>  在最后一行加入：</p>
<blockquote>
<p>/dev/sdb1 /work ext4 errors=remount-ro 0 1</p>
</blockquote>
<p>  完成!</p>
<hr>
<h4 id="补充：为挂载点扩容"><a href="#补充：为挂载点扩容" class="headerlink" title="补充：为挂载点扩容"></a>补充：为挂载点扩容</h4><p>假设之前我们有一个挂载点为 <em>/mydata</em> ，但该 <em>/mydata</em> 已经写满，但依然想在 <em>/mydata</em> 下添加新的数据，这时可以使用软链接将 <em>/mydata</em> 软链接到一个新挂载的磁盘分区上以实现扩容。具体步骤如下。</p>
<p><strong>1. 创建一个目录，以便稍后作为挂载点：</strong></p>
<blockquote>
<p>mkdir /newdata</p>
</blockquote>
<p><strong>2. 将 /dev/sdb1 分区挂载到 /newdata 下：</strong></p>
<blockquote>
<p>mount /dev/sdb1 /newdata</p>
</blockquote>
<p><strong>3. 新建 /mydata 到 /newdata 的软链接：</strong></p>
<blockquote>
<p>ln -s /newdata /mydata</p>
</blockquote>
<p>  此时在 /mydata 目录下会有一个软链接文件 <em>newdata</em> 指向 <em>/newdata/</em> ，即 <em>newdata-&gt; /newdata/</em> 。这样一来，只要我们向 <em>/mydata/newdata</em> 下写文件，实际就写入了 <em>/newdata/</em> 目录下，相当于我们为原 <em>/mydata</em> 挂载点新增加了一部分使用空间。  </p>
<p>  也可以手动指定该软链接文件的名称：</p>
<blockquote>
<p>ln -s /newdata /mydata/customed_name</p>
</blockquote>
<p>  这样就有 /mydata/customed_name -&gt; /newdata  </p>
<p>  <strong>注：</strong> 我们也可以利用软链接的这一用途，将比较大的日志文件链接到存储空间充足的磁盘分区的挂载点上。<br>  举例来说，如果 /opt/tomcat/logs/catalina.out 日志文件输入很多，占用空间很大，而 /opt 挂载点中所剩空间已经不多，存在溢出风险，通过下面两步就可以将该日志文件软链接到另一个磁盘分区的挂载点上：  </p>
<blockquote>
<p>touch /newdata/catalina_link.out<br>ln -sf /newdata/catalina_link.out /opt/tomcat/logs/catalina.out</p>
</blockquote>
<p>  <strong><em>这里还需要注意三点：</em></strong></p>
<p>  一是必须先创建一个被链接的文件，否则软链接后失败；<br>  二是强制软链接会清空之前 /opt/tomcat/logs/catalina.out 日志文件中的全部内容清空；<br>  三是需要重启 tomcat 目录后才能继续向 /opt/tomcat/logs/catalina.out 写入。  </p>
]]></content>
      <categories>
        <category>OS</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>Linux挂载硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>设置mac自带的vim语法高亮</title>
    <url>/2018/06/15/%E8%AE%BE%E7%BD%AEmac%E8%87%AA%E5%B8%A6%E7%9A%84vim%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<h4 id="最终效果图大概是这个样子："><a href="#最终效果图大概是这个样子：" class="headerlink" title="最终效果图大概是这个样子："></a>最终效果图大概是这个样子：</h4><p><img src="https://DaiHuiBlog.github.io/images/posts/设置mac自带的vim语法高亮/1.png" alt="avatar">  </p>
<a id="more"></a>
<h4 id="设置vimrc"><a href="#设置vimrc" class="headerlink" title="设置vimrc"></a>设置vimrc</h4><p>vimrc文件是vim的环境设置文件。<br>整体的vim的设置是在 <strong>/etc/vimrc</strong> 文件中。<br>不建议修改/etc/vimrc 文件，每个用户可以在用户根目录中设置vim，新建<strong> ~/.vimrc</strong></p>
<blockquote>
<p>touch .vimrc    </p>
</blockquote>
<h5 id="在-vimrc中添加以下内容"><a href="#在-vimrc中添加以下内容" class="headerlink" title="在.vimrc中添加以下内容"></a>在.vimrc中添加以下内容</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">"=========================================================================</span><br><span class="line">" DesCRiption: 适合自己使用的vimrc文件，for Mac/Linux/Windows, GUI/Console</span><br><span class="line">"</span><br><span class="line">" Last Change: 2017年09月11日  </span><br><span class="line">"</span><br><span class="line">" Version: 1.80</span><br><span class="line">"</span><br><span class="line">"=========================================================================</span><br><span class="line"></span><br><span class="line">set nocompatible " 关闭 vi 兼容模式</span><br><span class="line">syntax on " 自动语法高亮</span><br><span class="line">colorscheme molokai " 设定配色方案</span><br><span class="line">set number " 显示行号</span><br><span class="line">set cursorline " 突出显示当前行</span><br><span class="line">set ruler " 打开状态栏标尺</span><br><span class="line">set shiftwidth=4 " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</span><br><span class="line">set softtabstop=4 " 使得按退格键时可以一次删掉 4 个空格</span><br><span class="line">set tabstop=4 " 设定 tab 长度为 4</span><br><span class="line">set nobackup " 覆盖文件时不备份</span><br><span class="line">set autochdir " 自动切换当前目录为当前文件所在的目录</span><br><span class="line">filetype plugin indent on " 开启插件</span><br><span class="line">set backupcopy=yes " 设置备份时的行为为覆盖</span><br><span class="line">set ignorecase smartcase " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感</span><br><span class="line">set nowrapscan " 禁止在搜索到文件两端时重新搜索</span><br><span class="line">set incsearch " 输入搜索内容时就显示搜索结果</span><br><span class="line">set hlsearch " 搜索时高亮显示被找到的文本</span><br><span class="line">set noerrorbells " 关闭错误信息响铃</span><br><span class="line">set novisualbell " 关闭使用可视响铃代替呼叫</span><br><span class="line">set t_vb= " 置空错误铃声的终端代码</span><br><span class="line">" set showmatch " 插入括号时，短暂地跳转到匹配的对应括号</span><br><span class="line">" set matchtime=2 " 短暂跳转到匹配括号的时间</span><br><span class="line">set magic " 设置魔术</span><br><span class="line">set hidden " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存</span><br><span class="line">set guioptions-=T " 隐藏工具栏</span><br><span class="line">set guioptions-=m " 隐藏菜单栏</span><br><span class="line">set smartindent " 开启新行时使用智能自动缩进</span><br><span class="line">set backspace=indent,eol,start</span><br><span class="line">" 不设定在插入状态无法用退格键和 Delete 键删除回车符</span><br><span class="line">set cmdheight=1 " 设定命令行的行数为 1</span><br><span class="line">set laststatus=2 " 显示状态栏 (默认值为 1, 无法显示状态栏)</span><br><span class="line">set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\</span><br><span class="line">" 设置在状态行显示的信息</span><br><span class="line">set foldenable " 开始折叠</span><br><span class="line">set foldmethod=syntax " 设置语法折叠</span><br><span class="line">set foldcolumn=0 " 设置折叠区域的宽度</span><br><span class="line">setlocal foldlevel=1 " 设置折叠层数为</span><br><span class="line">" set foldclose=all " 设置为自动关闭折叠</span><br><span class="line">" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;</span><br><span class="line">" 用空格键来开关折叠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" return OS type, eg: windows, or linux, mac, et.st..</span><br><span class="line">function! MySys()</span><br><span class="line">if has("win16") || has("win32") || has("win64") || has("win95")</span><br><span class="line">return "windows"</span><br><span class="line">elseif has("unix")</span><br><span class="line">return "linux"</span><br><span class="line">endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">" 用户目录变量$VIMFILES</span><br><span class="line">if MySys() == "windows"</span><br><span class="line">let $VIMFILES = $VIM.'/vimfiles'</span><br><span class="line">elseif MySys() == "linux"</span><br><span class="line">let $VIMFILES = $HOME.'/.vim'</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" 设定doc文档目录</span><br><span class="line">let helptags=$VIMFILES.'/doc'</span><br><span class="line"></span><br><span class="line">" 设置字体 以及中文支持</span><br><span class="line">if has("win32")</span><br><span class="line">set guifont=Inconsolata:h12:cANSI</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" 配置多语言环境</span><br><span class="line">if has("multi_byte")</span><br><span class="line">" UTF-8 编码</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set formatoptions+=mM</span><br><span class="line">set fencs=utf-8,gbk</span><br><span class="line"></span><br><span class="line">if v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'</span><br><span class="line">set ambiwidth=double</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">if has("win32")</span><br><span class="line">source $VIMRUNTIME/delmenu.vim</span><br><span class="line">source $VIMRUNTIME/menu.vim</span><br><span class="line">language messages zh_CN.utf-8</span><br><span class="line">endif</span><br><span class="line">else</span><br><span class="line">echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">" Buffers操作快捷方式!</span><br><span class="line">nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;</span><br><span class="line">nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" Tab操作快捷方式!</span><br><span class="line">nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;</span><br><span class="line">nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">"关于tab的快捷键</span><br><span class="line">" map tn :tabnext&lt;cr&gt;</span><br><span class="line">" map tp :tabprevious&lt;cr&gt;</span><br><span class="line">" map td :tabnew .&lt;cr&gt;</span><br><span class="line">" map te :tabedit</span><br><span class="line">" map tc :tabclose&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动</span><br><span class="line">"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的</span><br><span class="line">"时候会变得非常方便.</span><br><span class="line">nnoremap &lt;C-h&gt; &lt;C-w&gt;h</span><br><span class="line">nnoremap &lt;C-j&gt; &lt;C-w&gt;j</span><br><span class="line">nnoremap &lt;C-k&gt; &lt;C-w&gt;k</span><br><span class="line">nnoremap &lt;C-l&gt; &lt;C-w&gt;l</span><br><span class="line"></span><br><span class="line">"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）</span><br><span class="line">nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;</span><br><span class="line">nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" set fileformats=unix,dos,mac</span><br><span class="line">" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;</span><br><span class="line">" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result</span><br><span class="line">" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;</span><br><span class="line">" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">" 让 Tohtml 产生有 CSS 语法的 html</span><br><span class="line">" syntax/2html.vim，可以用:runtime! syntax/2html.vim</span><br><span class="line">let html_use_css=1</span><br><span class="line"></span><br><span class="line">" Python 文件的一般设置，比如不要 tab 等</span><br><span class="line">autocmd FileType python set tabstop=4 shiftwidth=4 expandtab</span><br><span class="line">autocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">" 选中状态下 Ctrl+c 复制</span><br><span class="line">vmap &lt;C-c&gt; "+y</span><br><span class="line"></span><br><span class="line">" 打开javascript折叠</span><br><span class="line">let b:javascript_fold=1</span><br><span class="line">" 打开javascript对dom、html和css的支持</span><br><span class="line">let javascript_enable_domhtmlcss=1</span><br><span class="line">" 设置字典 ~/.vim/dict/文件的路径</span><br><span class="line">autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dict</span><br><span class="line">autocmd filetype css set dictionary=$VIMFILES/dict/css.dict</span><br><span class="line">autocmd filetype php set dictionary=$VIMFILES/dict/php.dict</span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - bufexplorer.vim Buffers切换</span><br><span class="line">" \be 全屏方式查看全部打开的文件列表</span><br><span class="line">" \bv 左右方式查看 \bs 上下方式查看</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - taglist.vim 查看函数列表，需要ctags程序</span><br><span class="line">" F4 打开隐藏taglist窗口</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">if MySys() == "windows" " 设定windows系统中ctags程序的位置</span><br><span class="line">let Tlist_Ctags_Cmd = '"'.$VIMRUNTIME.'/ctags.exe"'</span><br><span class="line">elseif MySys() == "linux" " 设定windows系统中ctags程序的位置</span><br><span class="line">let Tlist_Ctags_Cmd = '/usr/bin/ctags'</span><br><span class="line">endif</span><br><span class="line">nnoremap &lt;silent&gt;&lt;F4&gt; :TlistToggle&lt;CR&gt;</span><br><span class="line">let Tlist_Show_One_File = 1 " 不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1 " 如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_Use_Right_Window = 1 " 在右侧窗口中显示taglist窗口</span><br><span class="line">let Tlist_File_Fold_Auto_Close=1 " 自动折叠当前非编辑文件的方法列表</span><br><span class="line">let Tlist_Auto_Open = 0</span><br><span class="line">let Tlist_Auto_Update = 1</span><br><span class="line">let Tlist_Hightlight_Tag_On_BufEnter = 1</span><br><span class="line">let Tlist_Enable_Fold_Column = 0</span><br><span class="line">let Tlist_Process_File_Always = 1</span><br><span class="line">let Tlist_Display_Prototype = 0</span><br><span class="line">let Tlist_Compact_Format = 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。</span><br><span class="line">" \m mark or unmark the word under (or before) the cursor</span><br><span class="line">" \r manually input a regular expression. 用于搜索.</span><br><span class="line">" \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .</span><br><span class="line">" \* 当前MarkWord的下一个 \# 当前MarkWord的上一个</span><br><span class="line">" \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录</span><br><span class="line">" :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree</span><br><span class="line">" o 打开关闭文件或者目录 t 在标签页中打开</span><br><span class="line">" T 在后台标签页中打开 ! 执行此文件</span><br><span class="line">" p 到上层目录 P 到根目录</span><br><span class="line">" K 到第一个节点 J 到最后一个节点</span><br><span class="line">" u 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）</span><br><span class="line">" r 递归刷新当前目录 R 递归刷新当前根目录</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" F3 NERDTree 切换</span><br><span class="line">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NERD_commenter.vim 注释代码用的，</span><br><span class="line">" [count],cc 光标以下count行逐行添加注释(7,cc)</span><br><span class="line">" [count],cu 光标以下count行逐行取消注释(7,cu)</span><br><span class="line">" [count],cm 光标以下count行尝试添加块注释(7,cm)</span><br><span class="line">" ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。</span><br><span class="line">" 注：count参数可选，无则默认为选中行或当前行</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let NERDSpaceDelims=1 " 让注释符与语句之间留一个空格</span><br><span class="line">let NERDCompactSexyComs=1 " 多行注释时样子更好看</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"</span><br><span class="line">let g:DoxygenToolkit_briefTag_funcName="yes"</span><br><span class="line">map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;df :Dox&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;db :DoxBlock&lt;CR&gt;</span><br><span class="line">map &lt;leader&gt;dc a &lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – ZenCoding.vim 很酷的插件，HTML代码生成</span><br><span class="line">" 插件最新版：http://github.com/mattn/zencoding-vim</span><br><span class="line">" 常用命令可看：http://nootn.com/blog/Tool/23/</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – checksyntax.vim JavaScript常见语法错误检查</span><br><span class="line">" 默认快捷方式为 F5</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:checksyntax_auto = 0 " 不自动检查</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - NeoComplCache.vim 自动补全插件</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">let g:AutoComplPop_NotEnableAtStartup = 1</span><br><span class="line">let g:NeoComplCache_EnableAtStartup = 1</span><br><span class="line">let g:NeoComplCache_SmartCase = 1</span><br><span class="line">let g:NeoComplCache_TagsAutoUpdate = 1</span><br><span class="line">let g:NeoComplCache_EnableInfo = 1</span><br><span class="line">let g:NeoComplCache_EnableCamelCaseCompletion = 1</span><br><span class="line">let g:NeoComplCache_MinSyntaxLength = 3</span><br><span class="line">let g:NeoComplCache_EnableSkipCompletion = 1</span><br><span class="line">let g:NeoComplCache_SkipInputTime = '0.5'</span><br><span class="line">let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'</span><br><span class="line">" &lt;TAB&gt; completion.</span><br><span class="line">inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"</span><br><span class="line">" snippets expand key</span><br><span class="line">imap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span><br><span class="line">smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span><br><span class="line">" % 正向匹配 g% 反向匹配</span><br><span class="line">" [% 定位块首 ]% 定位块尾</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span><br><span class="line">" SVN/git管理工具</span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">"-----------------------------------------------------------------</span><br><span class="line">" plugin – a.vim</span><br><span class="line">"-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h5 id="设置颜色主题"><a href="#设置颜色主题" class="headerlink" title="设置颜色主题"></a>设置颜色主题</h5><p>进入对应目录准备颜色文件，没有就创建对应目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">daihui@daihuideMBP ~ cd .vim/colors</span><br><span class="line">daihui@daihuideMBP ~/.vim/colors pwd</span><br><span class="line">/Users/daihui/.vim/colors</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在~/.vim/colors目录下新建一个颜色文件</span></span><br><span class="line">daihui@daihuideMBP ~/.vim/colors touch molokai.vim</span><br></pre></td></tr></table></figure>
<p>molokai.vim 文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">" Vim color file</span><br><span class="line">"</span><br><span class="line">" Author: Tomas Restrepo &lt;tomas@winterdom.com&gt;</span><br><span class="line">"</span><br><span class="line">" Note: Based on the monokai theme for textmate</span><br><span class="line">" by Wimer Hazenberg and its darker variant</span><br><span class="line">" by Hamish Stuart Macpherson</span><br><span class="line">"</span><br><span class="line"></span><br><span class="line">hi clear</span><br><span class="line"></span><br><span class="line">set background=dark</span><br><span class="line">if version &gt; 580</span><br><span class="line">    " no guarantees for version 5.8 and below, but this makes it stop</span><br><span class="line">    " complaining</span><br><span class="line">    hi clear</span><br><span class="line">    if exists("syntax_on")</span><br><span class="line">        syntax reset</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line">let g:colors_name="molokai"</span><br><span class="line"></span><br><span class="line">if exists("g:molokai_original")</span><br><span class="line">    let s:molokai_original = g:molokai_original</span><br><span class="line">else</span><br><span class="line">    let s:molokai_original = 0</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hi Boolean         guifg=#AE81FF</span><br><span class="line">hi Character       guifg=#E6DB74</span><br><span class="line">hi Number          guifg=#AE81FF</span><br><span class="line">hi String          guifg=#E6DB74</span><br><span class="line">hi Conditional     guifg=#F92672               gui=bold</span><br><span class="line">hi Constant        guifg=#AE81FF               gui=bold</span><br><span class="line">hi Cursor          guifg=#000000 guibg=#F8F8F0</span><br><span class="line">hi Debug           guifg=#BCA3A3               gui=bold</span><br><span class="line">hi Define          guifg=#66D9EF</span><br><span class="line">hi Delimiter       guifg=#8F8F8F</span><br><span class="line">hi DiffAdd                       guibg=#13354A</span><br><span class="line">hi DiffChange      guifg=#89807D guibg=#4C4745</span><br><span class="line">hi DiffDelete      guifg=#960050 guibg=#1E0010</span><br><span class="line">hi DiffText                      guibg=#4C4745 gui=italic,bold</span><br><span class="line"></span><br><span class="line">hi Directory       guifg=#A6E22E               gui=bold</span><br><span class="line">hi Error           guifg=#960050 guibg=#1E0010</span><br><span class="line">hi ErrorMsg        guifg=#F92672 guibg=#232526 gui=bold</span><br><span class="line">hi Exception       guifg=#A6E22E               gui=bold</span><br><span class="line">hi Float           guifg=#AE81FF</span><br><span class="line">hi FoldColumn      guifg=#465457 guibg=#000000</span><br><span class="line">hi Folded          guifg=#465457 guibg=#000000</span><br><span class="line">hi Function        guifg=#A6E22E</span><br><span class="line">hi Identifier      guifg=#FD971F</span><br><span class="line">hi Ignore          guifg=#808080 guibg=bg</span><br><span class="line">hi IncSearch       guifg=#C4BE89 guibg=#000000</span><br><span class="line"></span><br><span class="line">hi Keyword         guifg=#F92672               gui=bold</span><br><span class="line">hi Label           guifg=#E6DB74               gui=none</span><br><span class="line">hi Macro           guifg=#C4BE89               gui=italic</span><br><span class="line">hi SpecialKey      guifg=#66D9EF               gui=italic</span><br><span class="line"></span><br><span class="line">hi MatchParen      guifg=#000000 guibg=#FD971F gui=bold</span><br><span class="line">hi ModeMsg         guifg=#E6DB74</span><br><span class="line">hi MoreMsg         guifg=#E6DB74</span><br><span class="line">hi Operator        guifg=#F92672</span><br><span class="line"></span><br><span class="line">" complete menu</span><br><span class="line">hi Pmenu           guifg=#66D9EF guibg=#000000</span><br><span class="line">hi PmenuSel                      guibg=#808080</span><br><span class="line">hi PmenuSbar                     guibg=#080808</span><br><span class="line">hi PmenuThumb      guifg=#66D9EF</span><br><span class="line"></span><br><span class="line">hi PreCondit       guifg=#A6E22E               gui=bold</span><br><span class="line">hi PreProc         guifg=#A6E22E</span><br><span class="line">hi Question        guifg=#66D9EF</span><br><span class="line">hi Repeat          guifg=#F92672               gui=bold</span><br><span class="line">hi Search          guifg=#FFFFFF guibg=#455354</span><br><span class="line">" marks column</span><br><span class="line">hi SignColumn      guifg=#A6E22E guibg=#232526</span><br><span class="line">hi SpecialChar     guifg=#F92672               gui=bold</span><br><span class="line">hi SpecialComment  guifg=#465457               gui=bold</span><br><span class="line">hi Special         guifg=#66D9EF guibg=bg      gui=italic</span><br><span class="line">hi SpecialKey      guifg=#888A85               gui=italic</span><br><span class="line">if has("spell")</span><br><span class="line">    hi SpellBad    guisp=#FF0000 gui=undercurl</span><br><span class="line">    hi SpellCap    guisp=#7070F0 gui=undercurl</span><br><span class="line">    hi SpellLocal  guisp=#70F0F0 gui=undercurl</span><br><span class="line">    hi SpellRare   guisp=#FFFFFF gui=undercurl</span><br><span class="line">endif</span><br><span class="line">hi Statement       guifg=#F92672               gui=bold</span><br><span class="line">hi StatusLine      guifg=#455354 guibg=fg</span><br><span class="line">hi StatusLineNC    guifg=#808080 guibg=#080808</span><br><span class="line">hi StorageClass    guifg=#FD971F               gui=italic</span><br><span class="line">hi Structure       guifg=#66D9EF</span><br><span class="line">hi Tag             guifg=#F92672               gui=italic</span><br><span class="line">hi Title           guifg=#ef5939</span><br><span class="line">hi Todo            guifg=#FFFFFF guibg=bg      gui=bold</span><br><span class="line"></span><br><span class="line">hi Typedef         guifg=#66D9EF</span><br><span class="line">hi Type            guifg=#66D9EF               gui=none</span><br><span class="line">hi Underlined      guifg=#808080               gui=underline</span><br><span class="line"></span><br><span class="line">hi VertSplit       guifg=#808080 guibg=#080808 gui=bold</span><br><span class="line">hi VisualNOS                     guibg=#403D3D</span><br><span class="line">hi Visual                        guibg=#403D3D</span><br><span class="line">hi WarningMsg      guifg=#FFFFFF guibg=#333333 gui=bold</span><br><span class="line">hi WildMenu        guifg=#66D9EF guibg=#000000</span><br><span class="line"></span><br><span class="line">if s:molokai_original == 1</span><br><span class="line">   hi Normal          guifg=#F8F8F2 guibg=#272822</span><br><span class="line">   hi Comment         guifg=#75715E</span><br><span class="line">   hi CursorLine                    guibg=#3E3D32</span><br><span class="line">   hi CursorColumn                  guibg=#3E3D32</span><br><span class="line">   hi LineNr          guifg=#BCBCBC guibg=#3B3A32</span><br><span class="line">   hi NonText         guifg=#BCBCBC guibg=#3B3A32</span><br><span class="line">else</span><br><span class="line">   hi Normal          guifg=#F8F8F2 guibg=#1B1D1E</span><br><span class="line">   hi Comment         guifg=#465457</span><br><span class="line">   hi CursorLine                    guibg=#293739</span><br><span class="line">   hi CursorColumn                  guibg=#293739</span><br><span class="line">   hi LineNr          guifg=#BCBCBC guibg=#232526</span><br><span class="line">   hi NonText         guifg=#BCBCBC guibg=#232526</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">"</span><br><span class="line">" Support for 256-color terminal</span><br><span class="line">"</span><br><span class="line">if &amp;t_Co &gt; 255</span><br><span class="line">   hi Boolean         ctermfg=135</span><br><span class="line">   hi Character       ctermfg=144</span><br><span class="line">   hi Number          ctermfg=135</span><br><span class="line">   hi String          ctermfg=144</span><br><span class="line">   hi Conditional     ctermfg=161               cterm=bold</span><br><span class="line">   hi Constant        ctermfg=135               cterm=bold</span><br><span class="line">   hi Cursor          ctermfg=16  ctermbg=253</span><br><span class="line">   hi Debug           ctermfg=225               cterm=bold</span><br><span class="line">   hi Define          ctermfg=81</span><br><span class="line">   hi Delimiter       ctermfg=241</span><br><span class="line"></span><br><span class="line">   hi DiffAdd                     ctermbg=24</span><br><span class="line">   hi DiffChange      ctermfg=181 ctermbg=239</span><br><span class="line">   hi DiffDelete      ctermfg=162 ctermbg=53</span><br><span class="line">   hi DiffText                    ctermbg=102 cterm=bold</span><br><span class="line"></span><br><span class="line">   hi Directory       ctermfg=118               cterm=bold</span><br><span class="line">   hi Error           ctermfg=219 ctermbg=89</span><br><span class="line">   hi ErrorMsg        ctermfg=199 ctermbg=16    cterm=bold</span><br><span class="line">   hi Exception       ctermfg=118               cterm=bold</span><br><span class="line">   hi Float           ctermfg=135</span><br><span class="line">   hi FoldColumn      ctermfg=67  ctermbg=16</span><br><span class="line">   hi Folded          ctermfg=67  ctermbg=16</span><br><span class="line">   hi Function        ctermfg=118</span><br><span class="line">   hi Identifier      ctermfg=208</span><br><span class="line">   hi Ignore          ctermfg=244 ctermbg=232</span><br><span class="line">   hi IncSearch       ctermfg=193 ctermbg=16</span><br><span class="line"></span><br><span class="line">   hi Keyword         ctermfg=161               cterm=bold</span><br><span class="line">   hi Label           ctermfg=229               cterm=none</span><br><span class="line">   hi Macro           ctermfg=193</span><br><span class="line">   hi SpecialKey      ctermfg=81</span><br><span class="line"></span><br><span class="line">   hi MatchParen      ctermfg=16  ctermbg=208 cterm=bold</span><br><span class="line">   hi ModeMsg         ctermfg=229</span><br><span class="line">   hi MoreMsg         ctermfg=229</span><br><span class="line">   hi Operator        ctermfg=161</span><br><span class="line"></span><br><span class="line">   " complete menu</span><br><span class="line">   hi Pmenu           ctermfg=81  ctermbg=16</span><br><span class="line">   hi PmenuSel                    ctermbg=244</span><br><span class="line">   hi PmenuSbar                   ctermbg=232</span><br><span class="line">   hi PmenuThumb      ctermfg=81</span><br><span class="line"></span><br><span class="line">   hi PreCondit       ctermfg=118               cterm=bold</span><br><span class="line">   hi PreProc         ctermfg=118</span><br><span class="line">   hi Question        ctermfg=81</span><br><span class="line">   hi Repeat          ctermfg=161               cterm=bold</span><br><span class="line">   hi Search          ctermfg=253 ctermbg=66</span><br><span class="line"></span><br><span class="line">   " marks column</span><br><span class="line">   hi SignColumn      ctermfg=118 ctermbg=235</span><br><span class="line">   hi SpecialChar     ctermfg=161               cterm=bold</span><br><span class="line">   hi SpecialComment  ctermfg=245               cterm=bold</span><br><span class="line">   hi Special         ctermfg=81  ctermbg=232</span><br><span class="line">   hi SpecialKey      ctermfg=245</span><br><span class="line"></span><br><span class="line">   hi Statement       ctermfg=161               cterm=bold</span><br><span class="line">   hi StatusLine      ctermfg=238 ctermbg=253</span><br><span class="line">   hi StatusLineNC    ctermfg=244 ctermbg=232</span><br><span class="line">   hi StorageClass    ctermfg=208</span><br><span class="line">   hi Structure       ctermfg=81</span><br><span class="line">   hi Tag             ctermfg=161</span><br><span class="line">   hi Title           ctermfg=166</span><br><span class="line">   hi Todo            ctermfg=231 ctermbg=232   cterm=bold</span><br><span class="line"></span><br><span class="line">   hi Typedef         ctermfg=81</span><br><span class="line">   hi Type            ctermfg=81                cterm=none</span><br><span class="line">   hi Underlined      ctermfg=244               cterm=underline</span><br><span class="line"></span><br><span class="line">   hi VertSplit       ctermfg=244 ctermbg=232   cterm=bold</span><br><span class="line">   hi VisualNOS                   ctermbg=238</span><br><span class="line">   hi Visual                      ctermbg=235</span><br><span class="line">   hi WarningMsg      ctermfg=231 ctermbg=238   cterm=bold</span><br><span class="line">   hi WildMenu        ctermfg=81  ctermbg=16</span><br><span class="line"></span><br><span class="line">   hi Normal          ctermfg=252 ctermbg=233</span><br><span class="line">   hi Comment         ctermfg=59</span><br><span class="line">   hi CursorLine                  ctermbg=234   cterm=none</span><br><span class="line">   hi CursorColumn                ctermbg=234</span><br><span class="line">   hi LineNr          ctermfg=250 ctermbg=234</span><br><span class="line">   hi NonText         ctermfg=250 ctermbg=234</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h5 id="重启vim再进来看看"><a href="#重启vim再进来看看" class="headerlink" title="重启vim再进来看看"></a>重启vim再进来看看</h5><p><a href="https://blog.csdn.net/ccorg/article/details/77940023" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>学不会的华为 IPD，其实是这样！</title>
    <url>/2022/12/21/%E4%BD%A0%E5%AD%A6%E4%B8%8D%E4%BC%9A%E7%9A%84%E5%8D%8E%E4%B8%BA%20IPD%EF%BC%8C%E5%85%B6%E5%AE%9E%E6%98%AF%E8%BF%99%E6%A0%B7%EF%BC%81/</url>
    <content><![CDATA[<p>美国著名作家弗格森说了一句话 “谁也无法说服他人改变，因为我们每个人都守着一扇只能从内心开启的改变之门，不论动之以情或晓之以理，我们都不能替别人开门”。</p>
<p>改变真的是由内而外的？不是！改变是由外而内，再由内而外的过程。只有当我们有信息输入，在新的信息下触发自身，只有触发自身的信息才能引发一场由内而外的改变。我们将用以下的文章内容来提供触发信息。</p>
<a id="more"></a>
<h4 id="一、让你的企业成为资产的思维"><a href="#一、让你的企业成为资产的思维" class="headerlink" title="一、让你的企业成为资产的思维"></a><strong>一、让你的企业成为资产的思维</strong></h4><p>企业经营的目标是要创造价值、利润，那么如何创造客户、并且持续不断的为客户创造价值、留住客户，是企业经营的法宝。产品无疑在企业与客户之间建立了一座桥梁。企业通过产品为客户创造价值。持续不断的高品质的产品输出，是一个企业持续立于不败之地的法宝。</p>
<p>然而，一个企业要成长，就要未雨绸缪、不断变革，以保持持续的生命力。华为公司就是一家保持持续变革的伟大公司，持续管理变革的目标就是实现高效的流程化运作，确保端到端的自动优质交付，从而实现企业的自动化管道系统。</p>
<p>今天我们向华为学习企业的变革之下的研发流程体系，其实是一个研发管道系统，在华为，这条管道叫做——IPD 体系。华为公司认为，研发不仅是研发部门的事，更是关系公司市场到产品变现的全流程。IPD 是企业实现产品商业化的管道系统，IPD 体系构建了产品从 idea 到产品变现的全流程。</p>
<p>经营企业需要具备系统性的全局思维，将企业看做资产的思维，企业是不断创造价值的资产，需要融入经营者的经营思维、战略思维、管理思维、并赋予工具、流程和方法，让其实现自动化运行的系统。当然不是所有企业都可以看成资产，只有创造价值，创造利润的企业才能称为资产。</p>
<p>作为经营者、管理者需要以经营资产的思维来经营企业。</p>
<h4 id="二、IPD-的起源和发展"><a href="#二、IPD-的起源和发展" class="headerlink" title="二、IPD 的起源和发展"></a><strong>二、IPD 的起源和发展</strong></h4><p><strong>1、跨界的 IBM 领导者为何要建 IPD</strong></p>
<p>IPD 起源于这家公司——IBM，一个世界级的巨无霸，全球最大的信息技术和业务解决方案公司，拥有 30 多万员工，业务遍及 160 多个国家和地区。2018 年《财富》世界 500 强排行榜发布，IBM 位列 92 位。</p>
<p>那么就是这样一家世界级的公司，在 1991～1993 年间累计面临巨大的财务困境，三年间累计亏损达 162 亿美元，几乎是每天亏损掉 1480 万美元。93 年的 4 月 1 日，54 岁，路易斯 · 郭士纳临危受命，担任 IBM 的执行总裁。</p>
<p>郭士纳的上任当时并不被人们看好，包含美国的媒体，人们不相信一个曾经以食品和烟草起家的公司老板，能够扭转 IBM 的困局。</p>
<p>郭士纳就任后，做了三件事：</p>
<p>第一件事：让 IBM 停止流血；郭士纳裁剪了 IBM 流血的部门和人员，半年内果断裁人 4.5 万。</p>
<p>第二件事：重振大型机业务，拓展服务业范围，并带领 IBM 重新向 PC 市场发动攻击。</p>
<p>第三件事：梳理公司流程体制，进行流程重构和再造工程。</p>
<p>这第三件事情是与新班子花了近一年时间，研究如何对 IBM 进行 “再造工程”。IBM 组织团队进行分析，经过分析后，他们发现公司三个方面上远远落后于业界最佳——研发费用、研发浪费和产品上市时间。</p>
<p>分析的结果：IBM 研发费用为销售收入的 12%，而业界最佳为 6%；　　研发损失费用为整个研发费用的 25%，而业界最佳仅为 3.3%；而在上市时间（指产品从概念产生到投放市场所需的时间）方面，36.5% 项目的上市时间是业界最佳的 1.25 倍，其余项目的上市时间多于业界最佳的 1.5-2 倍。</p>
<p>为了重新获得市场竞争优势，IBM 提出了两个 50% 的目标，一是，将产品上市时间减少 50%，二是，在不影响产品开发结果的情况下，将研发费用减少 50% 的目标。</p>
<p>为达成这个目标，IBM 公司应用了 PACE 的方法（Product And Cycle-time Excellence，产品及周期优化法）从流程重整和产品重整两个方面来达到缩短产品上市时间、提高产品利润的目标。</p>
<p>时隔三年，1995 年，IBM 营收突破了 700 亿美元大关，IBM 的大型机业务也复活了。利润 60 亿美元。不得不说，IBM 公司流程重构在提升自身竞争力上发挥了巨大的作用。</p>
<p>IBM 成为了全球率先应用 IPD 方法并取得成功实践的企业，这就是 IPD 的起源。</p>
<p>美国著名的 PTRM 公司总结实施 IPD 后带来的好处是：</p>
<p><img src="https://pic3.zhimg.com/v2-cbb22c372c41b100de7a85da06ff48f6_r.jpg" alt=""></p>
<p>IPD 是集成产品开发的英文单词首字母，经过 IBM 公司实践的一套先进的、成熟的研发管理思想、模式和方法。</p>
<p><strong>2、华为搭上 IPD 的快车</strong></p>
<p>1997 年西方圣诞节前一周，任总重点考察了 IBM。圣诞节前夕美国各大企业都已经放假了，但 IBM 包括 CEO 郭士纳在内的高层领导均照常上班，并真诚而系统地向任正非介绍了他们的管理内涵。</p>
<p>这次调研中整整一天时间，IBM 从产品预研到项目管理、从生产流程到项目寿命终结的投资评审做了详尽的介绍。为了强化任正非对 IPD 的认识，IBM 副总裁送给他一本哈佛大学出版的关于研发管理的著作，后来他发现朗讯、惠普等美国著名企业也都实施这样的研发模式。</p>
<p>这次考察更加坚定了任正非对华为实施变革的坚定决心，华为要像 IBM 一样强大，不仅自己要以郭士纳为榜样，而且华为必须虔诚地拜 IBM 为师，不惜一切代价将其管理精髓移植到华为身上。</p>
<p>1998 年 8 月初，华为与 IBM 中国区总裁周伟焜签订了金额 20 亿人民币的变革项目合作协议，当时 20 亿是华为当年全年的利润，可见任总的魄力非常人所能及也。</p>
<p>这个项目包含了 IPD（集成产品开发）、ISC（集成供应链）、IT 系统重整、财务四统一等 8 个管理变革项目。这成为是华为历史上最重要的转折点，这个项目将华为带进了高速赛道。</p>
<p>华为公司第一家引进和实施 IPD，也是受益最大的国内企业。从 98 年的 IPD1.0 到 2014 年的 IPD7.0, 华为不断升级优化。</p>
<p>华为公司 1998 年启动 IPD 项目，分为关注、发明、推广 3 个阶段。根据 1998 年的计划，用两年多的时间就可以实现全面推广。</p>
<p>华为在 2001 年华为颁布了《华为基本法》，基本法一个重要的方面是统一了公司变革的思想。</p>
<p>经过了四年的梳理建设，IPD 在 2002 年在全公司推广使用。华为公司走上了与世界领先企业并肩同行的管理道路。</p>
<h4 id="三、IPD-的核心思想"><a href="#三、IPD-的核心思想" class="headerlink" title="三、IPD 的核心思想"></a><strong>三、IPD 的核心思想</strong></h4><p><strong>1. 研发本质是研发是企业的一项投资</strong></p>
<p>首先，IPD 认为研发是一项投资；因为这是一项投资决策，所以，需要对它进行有效的投资组合分析，在开发过程中，设置检查点，通过阶段性评审来决定项目是继续、暂停、终止还是改变方向。</p>
<p><strong>IPD(Integrated product development 集成产品开发)，IPD 是一套先进的、成熟的研发管理思想、模式和方法。</strong></p>
<p><strong>2. 基于市场的研发才是有效投资</strong></p>
<p>IPD 强调，产品创新一定要是基于市场需求和竞争分析的创新，要准确地做正确的事情，要将正确定义产品概念、充分理解市场需求作为流程的第一步。</p>
<p>在 IT 圈有个现象，一天公司其中一个人有个创意，然后召集人员参与讨论，之后，就规划出一个产品创意来，然后互相鼓励，觉得我们这个创意就是最牛逼的，我们是世界第一，没有人想到，只有我们想到。并且互相叮嘱，我们要保密哦，要充分注重信息安全，不能透露给外人。这样的产品规划，我们通常叫做意向创业；貌似具有非常强的执行力，立即组建团队，就卷起袖子加油干！立项、设计、开发、出样机、投生产。节奏很快，也很有魄力。恨不得 3 个月就能出产品，然后做营销、做销售。经历了千辛万苦，产品出来后，面向市场发布，结果无人问津。</p>
<p>这里我们强调产品一定是基于市场需求的开发，一定要解决市场的问题和痛点，痒点都不行，必须是痛点。</p>
<p>所以说，这种方式就不满足 IPD 的核心思想。我们说市场的端到端，是需求来源于市场，最终产品回归于市场。你都没有做充分的市场调研，怎么能够被市场所接受。</p>
<p><strong>3. 如何穿越部门墙建立研发快车道</strong></p>
<p>一个产品，尤其是以硬件为主的产品，设计产品的方方面面、结构、硬件、软件、工程、制造、采购、包装、市场推广等，是需要全部门协同配合的一个事情。所以必须要有跨部门的团队协作。</p>
<p>采用跨部门的产品开发团队 (Product Development Team, 简称 PDT)，通过有效的沟通、协调以及决策，到达尽快将产品推向市场的目的。</p>
<p>有的创业者，把这个事情想得太简单，完全没有搞清楚状况，拖几个人就开始干，在他们的理念中，出产品就是出样机，觉得样机出来了，产品就出来了，殊不知一个产品样机出来，仅仅只等效于产品开发过程只完成 40%，还有大量的工作要做。</p>
<p>并且，在这种思想下，产品的是不完善的，是不具备量产化的，以样机为产品终结的思想，完全不会考虑到产品的后端需求。比如可测试性、可制造性、可服务性等 DFX 的需求。</p>
<p>跨部门的团队，强调无缝沟通，强调把专业的团队串起来，为了一个共同的目标而努力。</p>
<p>老罗有这么一句对自己的总结 “只有等到你掉到坑里的时候，你才刻骨铭心地意识到前辈们的忠告是如此的正确”。</p>
<p>创业初期，老罗一直认为，除了乔布斯，锤子拥有世界上一流的工业设计团队。于是呢，我们看到，老罗开始打造工艺品，追求完美的产品设计。在产品转生产试制的时候，多次亲自在富士康的生产线跟线。在追求产品完美外观和软件体验细节的上面，忽略了产品的可实现性。后来老罗在一次产品发布会上深刻总结了做产品不是做艺术品，需要充分考虑产品的可制造性。其实老罗在 2012 年摩托罗拉大裁员的时候吸收了一大批摩托罗拉的技术专家。如果当时，他充分利用各类部门技术专家的优势，锤子 T1 手机就不会遭遇 “噩梦一般的三个月”。</p>
<p><strong>4. 给新产品开发造一个发动机</strong></p>
<p>IPD 同样也关注平台，平台化的开发带来了两大好处，铁打的银盘流水的兵，即使关键岗位的人员流动也不会对企业带来影响，平台让我们的开发成果得到积累和沉淀；另一方面，平台化的开发，支撑了我们新产品开发的速度。</p>
<p><strong>5. 每个人都应该知道该干什么的方法</strong></p>
<p>结构化的流程，所谓结构化，是指相互关联的工作要有一个框架结构，并要有一定的组织原则来支持它；每项工作都应清清楚楚地明确规定出来。所有与产品开发有关的人应该清楚他们所参与的是什么工作，用什么方法去完成。</p>
<p>同时，有了结构化的流程，我们就不在受关键岗位、关键人才的限制。</p>
<p>几年前，我就职过的一家公司，一个项目经理总览了一个产品系列的所有软硬件的全套技术和技术文件，以此为由，要求公司 CEO 给他加薪，CEO 最后不得不接受。当然，我们不希望这样的事情发生，同时我们也期望给公司员工带来更多的福利。可是这种情况在公司发展，对公司的发展，对员工的发展都是非常不利的。</p>
<p><strong>6. 海陆空模式远比顺序模式强大</strong></p>
<p><strong>异步开发模式</strong>，也称并行工程。通过严谨的计划、系统的设计、严格的流程控制，节点评审，把原来的许多后续活动提前进行，缩短产品上市时间。</p>
<p>产品立项之后，总体方案评审通过，进入详细设计阶段，我们的动作就可以开始做了。</p>
<p>产品的宣传资料可以出了，产品样机还没有出来，产品的市场预热推广已经开始了。这就是并行工程。那么我们通常情况下，我们敢不敢在样机还没有出来的时候有已经开始了产品的市场动作？敢不敢？</p>
<p>我想很多企业是不敢的，产品没有出来就大量的投入营销，那么如果产品出不来怎么办呢？</p>
<p>而在 IPD 的流程体系中，产品不会不出来，而且计划是产品不会不按照原定计划出来。</p>
<p>一方面，IPD 强调的 “一次性把事情做好”；</p>
<p>另外一方面，IPD 有系统的流程控制方法来保证产品开发如期完成。</p>
<p><strong>重用性</strong> 尽量采用公共构建模块 (Common Building Block, 简称 CBB)，提高产品开发效率。</p>
<p><strong>CBB</strong>，称为公共构建模块，这些模块，可以是软件的、可以是硬件的、可以是测试的、可以是生产的。有了这些模块，我们开发过程就聚焦在模块之外的其他需求进行，一方面减少了工作量。</p>
<p>我在做手机的时候，我们曾做了一个 1.5 个月研发出一款手机并成功转量产的记录，就是充分应用了 CBB 的重用思想。</p>
<p><strong>7. 中小企业也可以插上 IPD 的翅膀</strong></p>
<p>第七个核心思想，阐述了 IPD 的灵活的，随着业务和技术的发展而变化的，可以全面应用，要可裁剪应用。因地制宜，随机应变。</p>
<p>至今，华为的 IPD 还在不断的优化和升级，并且运用在了终端、无线、存储等各个产品线。</p>
<p>而 IPD 最小的业务模式也同样适用于中小型企业。</p>
<p>以上这七个横向的内容就是 IPD 的核心思想，IPD 的核心思想是 IPD 最重要管理精髓。</p>
<p>当然除了横向的核心思想，IPD 还包含了纵向的核心内容：</p>
<p>第一个内容，IPD 包含了 MM 市场管理流程，核心思想中强调了新产品开发是基于市场需求的开发，所以从市场到产品开发，一定需要一个市场管理流程来支撑。市场管理流程通过对市场的收集、分析、做出业务规划，输出产品开发任务书，作为产品开发的输入，是市场到开发的转化过程；</p>
<p>第二个内容是 IPD 集成产品开发流程，这是我们实现产品开发落地的流程，怎样做出产品来，就是在这个流程中体现。后边的章节里我们会更详细的介绍。</p>
<p>第三个内容技术开发流程，这个流程是实现企业的技术积累，核心竞争力的沉淀；</p>
<p>第四个内容是项目管理流程，IPD 核心管理是基于项目管理来进行的，而项目管理是在管什么呢，是在管资源。</p>
<p>第五个内容矩阵型组织结构，这是团队形式，核心思想中包含了跨部门团队，这个跨部门团队需要一个矩阵式的管理。</p>
<p>第六个内容是：绩效与激励，从业务上来看着是一个支撑内容，为我们业务目标服务的。从管理上来看，这条非常重要，包含了企业文化、HR 的思想等。一句话，门朝哪里开，人就会从哪里走，就在这里来操作。我们的门要向着目标的方向打开。</p>
<p>第七个内容 是管理优化与变革，这里强调了随着业务的发展，我们前面的这六点基于管理的内容要不断的优化升级，以更好的适配公司业务的发展。在华为公司，专门成立了管理优化部门，每年投入销售额的 3-5% 进行管理的优化变革。同时公司内部也有一个管理优化报，面向全公司发布。</p>
<p>七横七纵，从概念上介绍了 IPD 的全貌，是 IPD 的精华所在，希望大家能够理解和运用它。</p>
<h4 id="四、八个特征掌握-IPD"><a href="#四、八个特征掌握-IPD" class="headerlink" title="四、八个特征掌握 IPD"></a><strong>四、八个特征掌握 IPD</strong></h4><p><strong>1. IPD 的一套框架</strong></p>
<p><img src="https://pic3.zhimg.com/v2-557be7394adda907102507443972ce8a_r.jpg" alt=""></p>
<p>从公司战略出发、收集市场信息、客户反馈、竞争信息、技术趋势、产品组合进入市场管理流程。通过市场管理流程的对信息的分析、转化为业务计划，输出产品规划的 charter（产品业务计划书）</p>
<p>输入到产品开发流程，一部分输送给技术开发流程。通过产品开发流程和技术开发流程，实现对产品和技术的输出。</p>
<p><strong>2. IPD 的两种评审模式 DCP 和 TR</strong></p>
<p><img src="https://pic1.zhimg.com/v2-1b93002f94e2aded7cb220d1241c15b8_r.jpg" alt=""></p>
<p>产品开发流程使用两种评审机制，一种是基于业务决策线的评审；另一种是基于技术线的决策评审。</p>
<p>业务决策评审是集成产品开发管理团队（IPMT）管理产品投资的重要手段，在决策评审中，IPMT 始终站在投资商的角度来进行评审。</p>
<p>业务决策评审包含了 charter 决策评审、概念决策评审、计划决策评审、验证决策评审、生命周期决策评审</p>
<p>另外一种是技术决策评审，通过技术评审，帮助产品开发团队尽早发现产品开发中存在的问题和风险，及时采取相应的解决方案和行动计划，保证产品开发质量，减少浪费。</p>
<p><strong>3. IPD 的三大业务流程</strong></p>
<p><img src="https://pic4.zhimg.com/v2-22db8a6eb8546a2cd01a4ebfafc16737_r.jpg" alt=""></p>
<p><strong>4. IPD 的四大组织</strong>  </p>
<p><img src="https://pic4.zhimg.com/v2-e9ee51a0800a6e6ddfac5209208838a7_r.jpg" alt=""></p>
<p>（1）集成组合管理团队（IPMT）：产品投资决策和评审机构，负责制定公司总的使命愿景和战略方向，并对新产品线的产生进行决策。通常是一个高层跨部门团队，成员包括各个部门最高主管。</p>
<p>（2）产品开发团队（PDT）：一个虚拟的组织，其成员在产品开发期间一起工作，由产品经理 / 项目经理组织，一般是产品经理 / 项目经理负责的矩阵组织结构。</p>
<p>（3）产品生命周期管理团队（LMT）：在产品生命周期中，联合研发、制造、销售、使用、安全部门等各方面的资源，从根本上保证了产品在全生命周期中的管理能够高效、有序，并使产品保持低故障率。</p>
<p>（4）技术开发团队（TMT）：利用从研究和试验获得的知识或技术，为产品开发提供新的工艺和系统而进行实质性的改进。</p>
<p> <strong>5. IPD 的五个业务决策评审点</strong></p>
<p><img src="https://pic2.zhimg.com/v2-dea016a73693563cde089ff9463e4259_r.jpg" alt=""></p>
<p>（1）Charter：立项评审</p>
<p>（2）CDCP(Concept?DCP)：概念决策评审</p>
<p>（3）PDCP(Plan?DCP)：计划决策评审</p>
<p>（4）ADCP(Availability?DCP)：可获得性决策评审</p>
<p>（5）EDCP(EOL?DCP)：生命周期终止决策评审</p>
<p><strong>6. IPD 的六个开发阶段</strong></p>
<p><img src="https://pic3.zhimg.com/v2-a9c7db1b072a48d9a4bde310d25b0252_r.jpg" alt=""></p>
<p><strong>7. IPD 的七个技术评审点</strong></p>
<p><img src="https://pic3.zhimg.com/v2-cfb4bd36c41890aeb65d95f6ec329b9e_r.jpg" alt=""></p>
<p>当然，IPD 流程中设置了很多机制来对这类问题的解决。比如说我们的研发质量规范、我们的代码规范、代码检视、单元测试、系统测试等等。</p>
<p>IPD 的流程中为了最大限度的节省缺陷或问题流入后端造成了损失。就体现在前面介绍的两种评审机制，不论是基于业务的还会基于技术的评审，只要上一个评审点没有通过，就无法进入下一个评审点。这种机制有效的解决和平衡的我们新产品开发过程中的遇到的问题。</p>
<p>每一个环节都有自己的客户，我们一定要清楚自己的客户是谁，我们是为谁在服务。IPD 强调下一道工序就是你的客户！</p>
<h4 id="五、实施-IPD，你也可以"><a href="#五、实施-IPD，你也可以" class="headerlink" title="五、实施 IPD，你也可以"></a><strong>五、实施 IPD，你也可以</strong></h4><p><strong>1. 小组织也可以 IPD</strong></p>
<p>重量级团队削弱了功能部门的影响力。事实：功能部门在 IPD 的执行与决策中都占据着关键的地位。但是角色发生了变化。就像在乐队的演奏中，每个人都有自己的角色。如果鼓手演奏的声音比其他人大，如果鼓手想控制整个音乐（即使鼓手的技能不够），虽然鼓手自己可能感觉很强大，但是整个音乐已经不和谐了，已经被破坏了。扪心自问，实事求是地考虑一下自己真正的权力来自哪里。功能部门在 IPD 中扮演着非常重要的角色，不过在 IPD 流程中以团队的形式进行运作很重要。如果没有本身优秀的强大功能部门，IPD 也无法发挥自己的作用。功能部门在许多方面都发挥着重要的作用，如对本部门员工技能的培养进行管理，制定功能部门策略，向 PDT 和 IPMT 做出并履行承诺，将本功能部门与其他部门及公司联合起来，加强本功能部门对承诺的执行。同样，IRB 和 EMT 已经签发了政策和指导来更好地支撑华为的重量级团队建设环境，包括激励，PBC 和资源池。可是每个团队成员仍然有责任充分参与团队工作，积极帮助团队实现目标。</p>
<p>IPD 组织结构通常可以看成一个小公司。这就是为什么华为 18.8 万人的企业中，研发能够快速响应的一个重要原因。</p>
<p><strong>误区一：IPD 是大公司的事情，我们是小公司，没有实施 IPD 的必要</strong></p>
<p>IPD 本身是一种产品研发的最佳实践，强调研发要做正确的事情，体现市场驱动，把研发资源投入到最有价值的项目中，这些理念对中小企业同样有非常大的指导意义；尤其中小企业面临资源匮乏，一个项目的失败可能会导致整个公司的倒闭，这种状态下，更应该践行 IPD 的研发方法，确保项目的成功率，甚至要追求 120% 的成功率。 <strong>我们是项目化公司，IPD 是产品开发，所以不适合我们</strong></p>
<p>IPD 本身是从商业角度分析产品和项目是否值得投资，即使项目化的公司，也需要追求项目的投入产出率，也需要时刻关注客户需求，尤其是国内项目化公司普遍面临缺乏平台、跨项目共享差、交付成本高的问题，IPD 的市场驱动、异步开发模式、项目决策分析都可以非常好地解决这些问题。所以项目化公司同样需要 IPD。<strong>IPD 实施推行需要非常高的成本，实施周期很长，我们目前没有能力搞。</strong></p>
<p>大家有这种认识纯粹是 IBM、IPD 实施顾问忽悠的结果，把 IPD 忽悠的多么神圣、多么高档、如此之难，进而从客户手里多搂钱，把实施费用搞的奇贵，从而让客户感觉 IPD 是非常贵族化的东西，身份的象征。其实街边小餐馆都是按照 IPD 的思路运作的，在哪里开？市场客户决定 —（IPD 之市场驱动）；费用多少？竞争对比分析而定 — （IPD 之竞争分析）；每天早上要准备多少材料？历史销售情况 + 今天的销售预期决定 — （IPD 之预算管理）；提供哪些种类？制作周期太长的不做，因为客户没有时间等 — （IPD 之产品交付）；丰盛大餐的不做，因为厨师水平要求高，费用高 — （IPD 之项目研发费用）；每天晚上核算今天盈利、与历史对比 — （IPD 之衡量指标与对比分析）；客户喜欢的、利润高的种类放在菜单最上面 — （IPD 之投资组合分析）；所以 IPD 在中小企业同样适用，并且可以分步实施，实施难度、成本都是在可控范围之内。 <strong>还有诸多疑虑……</strong></p>
<p>误区二：<strong>IPD 是要在速度与质量之间做出取舍？</strong></p>
<p>误区三：<strong>IPD 影响决策的速度？</strong></p>
<p>误区四：<strong>重量级团队削弱了功能部门的影响力？</strong></p>
<p><strong>……</strong></p>
<p><strong>2. 貌似缺失的质量控制缺是最有效的控制</strong></p>
<p>IPD 是速度与质量相结合。技术评审点即使技术评审又是质量评审，质量管理被融入在 IPD 的流程和体系当中，潜移默化的，自然的服务于产品和控制产品质量。IPD 的目的是保证速度，但同时也要保证产品的高质量。IPD 不仅要使产品开发速度更快，而且还提供了一种规范，保证能够生产出高质量的产品。</p>
<p><strong>3. 环环相扣，齿齿相连，一次性把事情做好</strong></p>
<p><strong>环环相扣，齿齿相连</strong></p>
<p>每个角色都处于 IPD 的一个环节，只有当上一个环节完成了，并且是按照产品质量要求完成了，才会流向下一个环节，正如流水生产线一样，只有上一个工序的工作完成了，且被检验为合格了才能流到下一个工序。也只有上一个工序完成时，下一个工序才能开始，一切都在项目计划的控制之中。每个工序都会对下一个工序产生影响。</p>
<p><strong>一次性把事情做好！慢即是快。</strong></p>
<p>从整个 IPD 的核心思想方面来说，所有的流程和关键的评审点都是围绕这个 “一次性把事情做好” 这句话来的，因为在研发当中，一次性把事情做好，效率才是最高的。比如原本计划下个月的进行新产品的试制，原材料已经准备好，生产计划已经按照出生产线为我们的试制产品做准备。如果产品试制不能如期进行，生产线的计划将被打乱。相关的人员安排可能临时不能调度，原计划的试制期间的生产资源就会造成浪费。</p>
<p><strong>【结尾】</strong></p>
<p>公司的战略是选择方向，就是解决做正确的事情，做与公司目标相匹配的事情。</p>
<p>IPD(Integrated product development 集成产品开发) 是针对公司已经选择确定战略规划之下，正确的做公司规划的产品开发的事情，即使通常我们讲的正确的做事。</p>
<p>只有做正确的事情和正确的做事，才能保障经营的不败。</p>
<p>我想把一个复杂的系统，还原成一个常识的理解。只要我们理解和认识了 IPD，我们也同样可以穿上 IPD 之鞋，谁说灰姑娘就不能穿上漂亮的舞鞋跳舞呢？</p>
<blockquote>
<p>原文地址 <a href="https://zhuanlan.zhihu.com/p/392385187" target="_blank" rel="noopener">知乎</a></p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>IPD</tag>
        <tag>华为</tag>
      </tags>
  </entry>
</search>
